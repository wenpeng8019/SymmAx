<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SymmAx</title>
<style>
    /* ================================ */
    /* üé® ‰∏ªÈ¢òÈÖçËâ≤ÂèòÈáè */
    /* ================================ */
    :root {
        /* ËÉåÊôØËâ≤ */
        --bg-primary: #f0f0f0;
        --bg-secondary: #fff;
        --bg-panel: rgba(255, 255, 255, 0.95);
        --bg-panel-header: #f8f9fa;
        --bg-input: #fff;
        --input-focus-bg: #f0f8ff;
        
        /* ÊåâÈíÆËâ≤ */
        --bg-button: #3498db;
        --bg-button-hover: #2980b9;
        --bg-button-danger: #dc3545;
        --bg-button-danger-hover: #c82333;
        
        /* ÊñáÊú¨Ëâ≤ */
        --text-primary: #333;
        --text-secondary: #6c757d;
        --text-muted: #9ca3af;
        --text-button: #fff;
        
        /* ËæπÊ°ÜËâ≤ */
        --border-primary: #dee2e6;
        --border-secondary: #e5e7eb;
        --border-input: #ced4da;
        
        /* Èò¥ÂΩ± */
        --shadow-panel: 0 4px 12px rgba(0, 0, 0, 0.15);
        --shadow-light: 0 2px 8px rgba(0, 0, 0, 0.1);
        
        /* Âº∫Ë∞ÉËâ≤ */
        --accent-blue: #3498db;
        --accent-light: #e3f2fd;
    }

    body.dark-mode {
        --bg-primary: #1a1a1a;
        --bg-secondary: #2d2d2d;
        --bg-panel: rgba(45, 45, 45, 0.95);
        --bg-panel-header: #333;
        --bg-input: #2a2a2a;
        --input-focus-bg: #353535;
        --bg-button: #4a9eff;
        --bg-button-hover: #66b3ff;
        --bg-button-danger: #ff4757;
        --bg-button-danger-hover: #ff6b7b;
        --text-primary: #e0e0e0;
        --text-secondary: #a0a0a0;
        --text-muted: #6b7280;
        --border-primary: #404040;
        --border-secondary: #505050;
        --border-input: #555;
        --shadow-panel: 0 4px 12px rgba(0, 0, 0, 0.4);
        --shadow-light: 0 2px 8px rgba(0, 0, 0, 0.3);
        --accent-blue: #4a9eff;
        --accent-light: #1e3a5f;
    }

    /* ================================ */
    /* Âü∫Á°ÄÊ†∑Âºè */
    /* ================================ */
    body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: var(--bg-primary);
        color: var(--text-primary);
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
        user-select: none;
        transition: background-color 0.3s, color 0.3s;
    }

    canvas {
        display: block;
        /* cursor ÈÄöËøá JavaScript ËÆæÁΩÆÔºàCROSSHAIR ÂèòÈáèÔºâÔºåEdge ÊµèËßàÂô®ÈúÄË¶ÅËá™ÂÆö‰πâÂÖâÊ†á */
        
        /* Èò≤Ê≠¢ÊãñÊãΩÂíåÈÄâÊã©ÔºàÈíàÂØπ Edge ÊµèËßàÂô®ÊâãÂäøÔºâ*/
        user-select: none;
        -webkit-user-select: none;
        -webkit-user-drag: none;
        -webkit-touch-callout: none;
    }

    /* ËæìÂÖ•Ê°ÜÂèØÈÄâÊã©ÊñáÊú¨ */
    input, .function-input, .range-input {
        user-select: text;
    }

    /* ================================ */
    /* Èù¢ÊùøÈÄöÁî®Ê†∑Âºè */
    /* ================================ */
    .elements-panel, .property-panel {
        position: fixed;
        top: 20px;
        right: 20px;
        width: 280px;
        max-height: calc(100vh - 188px);
        background: var(--bg-panel);
        border: 1px solid var(--border-primary);
        border-radius: 8px;
        box-shadow: var(--shadow-panel);
        backdrop-filter: blur(10px);
        z-index: 1000;
        display: none;
        flex-direction: column;
        transition: background 0.3s, border-color 0.3s, left 0.3s, right 0.3s;
    }

    .elements-panel.left-align, .property-panel.left-align {
        left: 20px;
        right: auto;
    }

    .property-panel {
        width: 325px;
        z-index: 1001;
    }

    .elements-panel.show, .property-panel.show {
        display: flex;
    }

    .panel-header {
        padding: 15px 20px;
        border-bottom: 1px solid var(--border-secondary);
        font-weight: bold;
        font-size: 16px;
        color: var(--text-primary);
        background: var(--bg-panel-header);
        border-radius: 8px 8px 0 0;
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-shrink: 0;
        transition: all 0.3s;
    }

    .panel-toggle {
        background: none;
        border: none;
        font-size: 18px;
        cursor: pointer;
        color: #666;
        padding: 2px;
        transition: color 0.2s;
    }

    .panel-toggle:hover {
        color: #333;
    }

    /* ÂÖÉÁ¥†ÂàóË°® */
    .elements-list {
        flex: 1;
        overflow-y: auto;
        padding: 10px;
        min-height: 0;
        scrollbar-width: thin;
        scrollbar-color: var(--text-muted) var(--bg-secondary);
    }

    .elements-list::-webkit-scrollbar {
        width: 6px;
    }

    .elements-list::-webkit-scrollbar-track {
        background: var(--bg-secondary);
        border-radius: 3px;
    }

    .elements-list::-webkit-scrollbar-thumb {
        background: var(--text-muted);
        border-radius: 3px;
    }

    .elements-list::-webkit-scrollbar-thumb:hover {
        background: var(--text-secondary);
    }

    /* ÂÖÉÁ¥†È°π */
    .element-item {
        position: relative;
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px 16px 12px 12px;
        margin-bottom: 8px;
        background: #f8f9fa;
        border: 1px solid #e9ecef;
        border-radius: 8px;
        font-size: 14px;
        transition: all 0.15s;
        overflow: hidden;
        /* Á¶ÅÊ≠¢ÊñáÊú¨ÈÄâÊã© */
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
    }

    .element-item:hover {
        background: #e9ecef;
        border-color: #dee2e6;
        transform: translateY(-1px);
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.06);
    }

    .element-item:not(:hover) {
        transform: none !important;
        box-shadow: none !important;
    }

    .element-item.selected {
        background: linear-gradient(135deg, #eaf5fd, #f5faff) !important;
        border: 2px solid #3498db !important;
        box-shadow: 0 2px 8px rgba(52, 152, 219, 0.3) !important;
    }

    .element-item.selected .element-type {
        color: #2980b9 !important;
        font-weight: bold !important;
    }

    .element-item.hidden {
        opacity: 0.6;
    }

    .element-item.hidden .element-type::after {
        content: ' (ÈöêËóè)';
        color: #dc3545;
        font-weight: normal;
    }

    @keyframes slideInRight {
        from {
            opacity: 0;
            transform: translateX(5px) scale(0.98);
        }
        to {
            opacity: 1;
            transform: translateX(0) scale(1);
        }
    }

    .element-item.new-item {
        animation: slideInRight 0.15s ease-out;
        box-shadow: none !important;
    }

    /* ÂÖÉÁ¥†‰ø°ÊÅØ */
    .element-info {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 2px;
    }

    .element-type {
        position: relative;
        font-weight: bold;
        color: #495057;
    }

    .element-type::before {
        content: '';
        display: inline-block;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        margin-right: 8px;
        vertical-align: middle;
    }

    .element-item[data-type="0"] .element-type::before { background: #ff6b6b; }
    .element-item[data-type="1"] .element-type::before { background: #3498db; }
    .element-item[data-type="2"] .element-type::before { background: #96ceb4; }
    .element-item[data-type="3"] .element-type::before { background: #17a2b8; }
    .element-item[data-type="4"] .element-type::before { background: #9932cc; }
    .element-item[data-type="5"] .element-type::before { background: #feca57; }
    .element-item[data-type="6"] .element-type::before { background: #ff69b4; }
    .element-item[data-type="7"] .element-type::before { background: #e67e22; }
    .element-item[data-type="8"] .element-type::before { background: #48c774; }

    .element-props {
        font-size: 12px;
        color: #6c757d;
    }


    /* ÂÖÉÁ¥†Êìç‰ΩúÊåâÈíÆ */
    .element-actions {
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .element-btn {
        background: none;
        border: none;
        cursor: pointer;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .element-btn.toggle {
        color: #3498db;
        padding: 6px 10px;
        border-radius: 4px;
        font-size: 12px;
        font-weight: 500;
    }

    .element-btn.toggle:hover {
        background: #e3f2fd;
        color: #0056b3;
    }

    .element-btn.delete, .element-btn.options {
        position: absolute;
        width: 20px;
        height: 20px;
        color: white;
        border-radius: 6px 0 0 6px;
        font-size: 10px;
        font-weight: bold;
        opacity: 0;
        transform: scale(0.8);
        transition: all 0.2s;
    }

    .element-btn.delete {
        bottom: 0;
        right: 0;
        background: #dc3545;
    }

    .element-btn.options {
        top: 0;
        right: 0;
        background: #6c757d;
        line-height: 1;
    }

    .element-item:hover .element-btn.delete,
    .element-item:hover .element-btn.options {
        opacity: 1;
        transform: scale(1);
    }

    .element-btn.delete:hover {
        background: #c82333;
        transform: scale(1.05);
        box-shadow: 0 2px 6px rgba(220, 53, 69, 0.3);
    }

    .element-btn.options:hover {
        background: #5a6268;
        transform: scale(1.05);
        box-shadow: 0 2px 6px rgba(108, 117, 125, 0.3);
    }

    .element-btn.delete:active, .element-btn.options:active {
        transform: scale(0.95);
    }

    .element-btn.transform {
        color: #28a745;
        opacity: 0.7;
        width: 24px;
        height: 24px;
        border-radius: 4px;
    }

    .element-item:hover .element-btn.transform {
        opacity: 1;
    }

    .element-btn.transform:hover {
        background: rgba(40, 167, 69, 0.1);
        color: #28a745;
        transform: scale(1.1);
    }

    .element-btn.transform:active {
        transform: scale(0.95);
    }

    .element-btn.transform svg {
        width: 12px;
        height: 12px;
    }

    /* Á©∫ÂàóË°®ÊèêÁ§∫ */
    .empty-message {
        text-align: center;
        color: #999;
        padding: 40px 20px;
        font-size: 14px;
        line-height: 1.6;
    }

    .empty-message::before {
        content: 'üé®';
        display: block;
        font-size: 32px;
        margin-bottom: 10px;
        opacity: 0.5;
    }

    /* ================================ */
    /* ÂáΩÊï∞ÊåâÈíÆ */
    /* ================================ */
    .function-button {
        position: fixed;
        bottom: 80px;
        right: 20px;
        width: 48px;
        height: 48px;
        background: rgba(70, 70, 70, 0.9);
        border: 2px solid rgba(255, 255, 255, 0.2);
        border-radius: 50%;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.3s;
        z-index: 1500;
        backdrop-filter: blur(10px);
    }

    .function-button:hover {
        transform: translateY(-2px) scale(1.05);
        background: rgba(90, 90, 90, 0.95);
        border-color: rgba(255, 255, 255, 0.4);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    .function-button:active {
        transform: scale(0.98);
        background: rgba(60, 60, 60, 0.95);
    }

    .function-icon {
        color: rgba(255, 255, 255, 0.9);
        font-size: 16px;
        font-weight: 600;
        font-style: italic;
    }

    /* ================================ */
    /* ÂØπËØùÊ°ÜÈÄöÁî®Ê†∑Âºè */
    /* ================================ */
    .function-overlay, .attribute-overlay, .help-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.6);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 2000;
        backdrop-filter: blur(5px);
    }

    .function-overlay.show, .attribute-overlay.show, .help-overlay.show {
        display: flex;
    }

    @keyframes dialogSlideIn {
        from {
            opacity: 0;
            transform: scale(0.9) translateY(-20px);
        }
        to {
            opacity: 1;
            transform: scale(1) translateY(0);
        }
    }

    /* ÂáΩÊï∞ÂØπËØùÊ°Ü */
    .function-dialog, .settings-dialog {
        background: var(--bg-panel);
        border: 1px solid var(--border-primary);
        border-radius: 12px;
        box-shadow: var(--shadow-panel);
        max-width: 90vw;
        max-height: 80vh;
        overflow: hidden;
        animation: dialogSlideIn 0.4s ease-out;
        transition: background 0.3s, border-color 0.3s;
    }

    .function-dialog {
        width: 500px;
    }

    .settings-dialog {
        width: 400px;
    }

    /* ÂØπËØùÊ°ÜÂ§¥ÈÉ® */
    .function-header, .settings-header {
        padding: 24px 28px 20px;
        border-bottom: 1px solid var(--border-primary);
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: var(--bg-panel-header);
        transition: background 0.3s, border-color 0.3s;
    }

    .settings-header {
        padding: 20px 24px 16px;
        border-bottom: 1px solid var(--border-primary);
    }

    .function-title, .settings-title {
        font-size: 18px;
        font-weight: 500;
        margin: 0;
        color: var(--text-primary);
        transition: color 0.3s;
    }

    .function-close, .settings-close {
        background: none;
        border: none;
        font-size: 20px;
        color: var(--text-secondary);
        cursor: pointer;
        padding: 8px;
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 6px;
        transition: all 0.2s;
    }

    .settings-close {
        width: 30px;
        height: 30px;
        font-size: 24px;
    }

    .function-close:hover, .settings-close:hover {
        background: var(--bg-secondary);
        color: var(--text-primary);
    }

    /* ÂØπËØùÊ°ÜÂÜÖÂÆπ */
    .function-content, .settings-content {
        padding: 28px 32px;
        max-height: 50vh;
        overflow-y: auto;
        background: var(--bg-panel);
        transition: background 0.3s;
    }

    .settings-content {
        padding: 24px;
        max-height: 60vh;
    }

    /* ÂØπËØùÊ°ÜÂÜÖÂÆπÊªöÂä®Êù° */
    .function-content, .settings-content {
        scrollbar-width: thin;
        scrollbar-color: var(--text-muted) transparent;
    }

    .function-content::-webkit-scrollbar,
    .settings-content::-webkit-scrollbar {
        width: 8px;
    }

    .function-content::-webkit-scrollbar-track,
    .settings-content::-webkit-scrollbar-track {
        background: transparent;
    }

    .function-content::-webkit-scrollbar-thumb,
    .settings-content::-webkit-scrollbar-thumb {
        background-color: var(--text-muted);
        border-radius: 4px;
        opacity: 0.6;
    }

    .function-content::-webkit-scrollbar-thumb:hover,
    .settings-content::-webkit-scrollbar-thumb:hover {
        background-color: var(--text-secondary);
        opacity: 0.8;
    }

    .function-group, .setting-group {
        margin-bottom: 28px;
    }

    .setting-group {
        margin-bottom: 24px;
    }

    .function-group:last-child, .setting-group:last-child {
        margin-bottom: 0;
    }

    .function-label, .setting-label {
        display: block;
        font-weight: 500;
        color: var(--text-primary);
        margin-bottom: 8px;
        font-size: 14px;
        transition: color 0.3s;
    }

    .setting-label {
        font-weight: 600;
        color: var(--text-primary);
    }

    .function-description, .setting-description {
        font-size: 13px;
        color: var(--text-secondary);
        margin-bottom: 16px;
        line-height: 1.4;
        transition: color 0.3s;
    }

    .setting-description {
        font-size: 12px;
        color: var(--text-secondary);
        margin-bottom: 12px;
    }

    /* ËæìÂÖ•Ê°ÜÁªÑ */
    .function-input-group {
        display: flex;
        align-items: center;
        background: var(--bg-input);
        border: 1px solid var(--border-input);
        border-radius: 8px;
        padding: 2px;
        transition: all 0.2s;
    }

    .function-input-group:focus-within {
        border-color: var(--accent-blue);
        box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.08);
        background: var(--input-focus-bg);
    }

    .function-prefix {
        padding: 12px 14px;
        font-size: 15px;
        font-weight: 500;
        color: var(--text-muted);
        background: var(--bg-panel-header);
        border-radius: 6px;
        margin-right: 6px;
        transition: all 0.2s;
    }

    .function-input, .range-input {
        border: none;
        background: transparent;
        padding: 12px 14px;
        font-size: 15px;
        color: var(--text-primary);
        outline: none;
        font-family: 'SF Mono', Monaco, Consolas, monospace;
        transition: color 0.2s;
    }

    .function-input {
        flex: 1;
    }

    .function-input::placeholder {
        color: var(--text-muted);
        font-style: italic;
    }

    .range-input {
        border: 1px solid var(--border-input);
        border-radius: 6px;
        padding: 8px 12px;
        font-size: 14px;
        width: 80px;
        text-align: center;
        background: var(--bg-input);
        color: var(--text-primary);
        transition: background 0.3s, border-color 0.3s, color 0.3s;
    }

    .range-input:focus {
        border-color: var(--accent-blue);
        box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.08);
        background: var(--input-focus-bg);
    }

    .function-range-group {
        display: flex;
        align-items: center;
        gap: 12px;
        flex-wrap: wrap;
    }

    .range-label {
        font-size: 14px;
        color: var(--text-secondary);
        font-weight: 500;
        transition: color 0.3s;
    }

    /* ÂØπËØùÊ°ÜÂ∫ïÈÉ®ÊåâÈíÆ */
    .function-footer, .settings-footer {
        padding: 20px 32px 24px;
        border-top: 1px solid var(--border-primary);
        display: flex;
        justify-content: flex-end;
        gap: 12px;
        background: var(--bg-panel-header);
        transition: background 0.3s, border-color 0.3s;
    }

    .settings-footer {
        padding: 16px 24px 20px;
        border-top: 1px solid var(--border-primary);
    }

    .function-btn, .settings-btn {
        padding: 12px 24px;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 600;
        transition: all 0.2s;
        min-width: 80px;
    }

    .settings-btn {
        padding: 8px 16px;
        font-weight: 500;
        border-radius: 6px;
        min-width: auto;
    }

    .function-btn.cancel, .settings-btn.cancel {
        background: #fff;
        color: #7f8c8d;
        border: 1px solid #e1e8ed;
    }

    .function-btn.cancel:hover, .settings-btn.cancel:hover {
        background: #f8f9fa;
        color: #5a6c7d;
        border-color: #d1d9e0;
    }

    .settings-btn.cancel:hover {
        background: #e9ecef;
    }

    .function-btn.preview {
        background: #ecf0f1;
        color: #34495e;
        border: 1px solid #bdc3c7;
    }

    .function-btn.preview:hover {
        background: #d5dbdb;
        color: #2c3e50;
    }

    .function-btn.apply, .settings-btn.apply {
        background: #3498db;
        color: white;
        border: 1px solid #3498db;
    }

    .function-btn.apply:hover, .settings-btn.apply:hover {
        background: #2980b9;
        border-color: #2980b9;
        transform: translateY(-1px);
        box-shadow: 0 2px 8px rgba(52, 152, 219, 0.3);
    }

    /* È¢úËâ≤ÂíåÁ∫øÂÆΩÈÄâÊã©Âô® */
    .color-picker-group {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
    }

    .color-option {
        width: 32px;
        height: 32px;
        border-radius: 6px;
        border: 2px solid #e0e0e0;
        cursor: pointer;
        transition: all 0.2s;
        position: relative;
    }

    .color-option:hover {
        transform: scale(1.1);
        border-color: #999;
    }

    .color-option.selected {
        border-color: #007bff;
        transform: scale(1.15);
    }

    .color-option.selected::after {
        content: '‚úì';
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: white;
        font-weight: bold;
        font-size: 14px;
        text-shadow: 0 0 3px rgba(0, 0, 0, 0.5);
        z-index: 2;
    }

    .color-option.auto-color {
        background: linear-gradient(45deg, #333 50%, #fff 50%) !important;
    }

    .color-option.auto-color span {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 9px;
        font-weight: bold;
        color: #666;
        text-shadow: 0 0 2px white;
        z-index: 1;
        pointer-events: none;
    }

    .width-picker-group {
        display: flex;
        flex-direction: column;
        gap: 10px;
    }

    .width-slider {
        width: 100%;
        height: 3px;
        border-radius: 2px;
        background: #e0e0e0;
        outline: none;
        cursor: pointer;
        appearance: none;
    }

    .width-slider::-webkit-slider-thumb {
        appearance: none;
        width: 14px;
        height: 14px;
        border-radius: 50%;
        background: #007bff;
        cursor: pointer;
        border: 2px solid #fff;
        box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }

    .width-slider::-moz-range-thumb {
        width: 14px;
        height: 14px;
        border-radius: 50%;
        background: #007bff;
        cursor: pointer;
        border: 2px solid #fff;
        box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }

    .width-slider::-webkit-slider-track,
    .width-slider::-moz-range-track {
        height: 3px;
        border-radius: 2px;
        background: #e0e0e0;
        border: none;
    }

    .width-display {
        display: flex;
        align-items: center;
        gap: 5px;
        font-size: 14px;
        color: #333;
    }

    .width-value {
        font-weight: 600;
        color: #007bff;
    }

    .width-unit {
        color: #666;
    }

    .width-preview {
        background: #666;
        border-radius: 2px;
        margin: 10px 0;
        height: 2px;
        width: 100px;
        transition: height 0.2s;
    }

    /* ================================ */
    /* ÁªòÂà∂ËèúÂçï */
    /* ================================ */
    .draw-menu {
        position: fixed;
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        border: 1px solid #e9ecef;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15), 0 2px 4px rgba(0, 0, 0, 0.1);
        z-index: 1001;
        min-width: 140px;
        padding: 8px;
    }

    .menu-item {
        display: flex;
        align-items: center;
        padding: 8px 12px;
        margin: 2px 0;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.2s;
        background: #f8f9fa;
    }

    .menu-item:hover {
        background: #e9ecef;
        transform: translateX(2px);
    }

    .menu-item:active {
        transform: translateX(1px);
        background: #dee2e6;
    }

    .menu-icon {
        color: #6c757d;
        font-size: 16px;
        margin-right: 12px;
        width: 20px;
        height: 20px;
        text-align: center;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .menu-icon svg {
        display: block;
        color: inherit;
    }

    .menu-text {
        color: #495057;
        font-size: 14px;
        font-weight: 500;
    }

    /* ================================ */
    /* Â∏ÆÂä©ÂØπËØùÊ°Ü */
    /* ================================ */
    .help-dialog {
        position: relative;
        background: var(--bg-primary);
        border-radius: 16px;
        box-shadow: 0 20px 40px var(--shadow-panel);
        width: 780px;
        height: 650px;
        margin: 20px;
        animation: dialogSlideIn 0.3s ease-out;
        transition: background 0.3s;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        user-select: none;
    }

    .help-dialog-content {
        flex: 1;
        overflow-y: auto;
        padding: 32px;
        scrollbar-width: thin;
        scrollbar-color: #999 transparent;
    }

    .help-dialog-content::-webkit-scrollbar {
        width: 8px;
    }

    .help-dialog-content::-webkit-scrollbar-track {
        background: transparent;
    }

    .help-dialog-content::-webkit-scrollbar-thumb {
        background-color: #999;
        border-radius: 4px;
        opacity: 0.6;
    }

    .help-dialog-content::-webkit-scrollbar-thumb:hover {
        background-color: #666;
        opacity: 0.8;
    }

    body.dark-mode .help-dialog-content::-webkit-scrollbar {
        width: 8px;
    }

    body.dark-mode .help-dialog-content::-webkit-scrollbar-track {
        background: transparent;
    }

    body.dark-mode .help-dialog-content::-webkit-scrollbar-thumb {
        background-color: #666;
        border-radius: 4px;
        opacity: 0.6;
    }

    body.dark-mode .help-dialog-content::-webkit-scrollbar-thumb:hover {
        background-color: #888;
        opacity: 0.8;
    }

    /* Ê∑±Ëâ≤Ê®°Âºè - Â±ûÊÄßÈù¢ÊùøÁâπÂæÅÂÄºÊ†∑Âºè */
    body.dark-mode .feature-value {
        color: #b0b0b0;
        background: #333;
        border-color: #4a4a4a;
    }

    body.dark-mode .feature-value-compact {
        color: #b0b0b0;
        background: #333;
        border-color: #4a4a4a;
    }

    body.dark-mode .feature-row:hover .feature-value-compact {
        border-color: #4a9eff;
        background: #383838;
        box-shadow: 0 1px 2px rgba(74, 158, 255, 0.15);
    }

    body.dark-mode .feature-point {
        color: #b0b0b0;
        background: #333;
        border-color: #4a4a4a;
    }

    body.dark-mode .feature-checkbox-inline {
        color: #888;
    }

    body.dark-mode .feature-checkbox-inline:hover {
        color: #b0b0b0;
    }

    body.dark-mode .feature-checkbox {
        color: #888;
    }

    body.dark-mode .feature-checkbox:hover {
        color: #b0b0b0;
    }

    /* Ê∑±Ëâ≤Ê®°Âºè - ÂÖÉÁ¥†ÂàóË°®È°πÊ†∑Âºè */
    body.dark-mode .element-item {
        background: #2a2a2a;
        border-color: #404040;
    }

    body.dark-mode .element-item:hover {
        background: #333;
        border-color: #505050;
    }

    body.dark-mode .element-item.selected {
        background: linear-gradient(135deg, #1e3a5f, #2a4a6f) !important;
        border-color: #4a9eff !important;
        box-shadow: 0 2px 8px rgba(74, 158, 255, 0.4) !important;
    }

    body.dark-mode .element-item.selected .element-type {
        color: #66b3ff !important;
    }

    .help-dialog::after {
        content: '';
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: 20px;
        background: linear-gradient(to top, var(--bg-primary), transparent);
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.3s;
    }

    .help-dialog.scrollable::after {
        opacity: 1;
    }

    /* Â∏ÆÂä©ÂØπËØùÊ°ÜÊ†áÁ≠æÈ°µ */
    .help-tabs {
        display: flex;
        gap: 24px;
        padding: 0 32px;
        margin-top: -8px;
        margin-bottom: 24px;
        padding-bottom: 16px;
    }

    .help-tab {
        padding: 6px 0 10px 0;
        font-size: 13px;
        color: var(--text-secondary);
        background: transparent;
        cursor: pointer;
        transition: all 0.2s;
        user-select: none;
        position: relative;
        border: none;
    }

    .help-tab::after {
        content: '';
        position: absolute;
        bottom: 0;
        left: 50%;
        transform: translateX(-50%);
        width: 32px;
        height: 1px;
        background: var(--accent-blue);
        opacity: 0;
        transition: opacity 0.2s;
    }

    .help-tab:hover {
        color: var(--text-primary);
    }

    .help-tab.active {
        color: var(--text-primary);
    }

    .help-tab.active::after {
        opacity: 0.3 !important;
    }

    .help-tab-content {
        display: none;
    }

    .help-tab-content.active {
        display: block;
    }

    .help-title {
        font-size: 24px;
        font-weight: bold;
        color: var(--text-primary);
        margin-bottom: 24px;
        text-align: center;
        transition: color 0.3s;
        user-select: none;
    }

    .help-section {
        margin-bottom: 24px;
        user-select: none;
    }

    .help-note + .help-section {
        margin-top: 32px;
    }

    .help-subtitle {
        font-weight: 600;
        color: var(--text-primary);
        font-size: 14px;
        margin-bottom: 12px;
        padding-bottom: 6px;
        border-bottom: 1px solid var(--border-secondary);
        transition: all 0.3s;
        user-select: none;
    }

    .help-item {
        display: grid;
        grid-template-columns: 200px 1fr;
        gap: 16px;
        margin-bottom: 8px;
        padding: 6px 0;
        user-select: none;
    }

    .help-key {
        background: var(--bg-input);
        border: 1px solid var(--border-input);
        border-radius: 4px;
        padding: 4px 8px;
        font-family: 'SF Mono', Monaco, Consolas, monospace;
        font-size: 12px;
        color: var(--text-secondary);
        text-align: center;
        transition: all 0.3s;
        justify-self: start;
        user-select: none;
    }

    .help-description {
        color: var(--text-secondary);
        font-size: 14px;
        line-height: 1.4;
        transition: color 0.3s;
        user-select: none;
    }

    .help-note {
        background: var(--input-focus-bg);
        border-left: 4px solid var(--accent-blue);
        padding: 12px 16px;
        margin-top: 12px;
        border-radius: 0 8px 8px 0;
        transition: all 0.3s;
        user-select: none;
    }

    .help-note + .help-note {
        margin-top: 8px;
    }

    .help-note-text {
        color: var(--accent-blue);
        font-size: 14px;
        margin: 0;
        transition: color 0.3s;
        user-select: none;
    }

    /* ‰∏ªÈ¢òÂíåËØ≠Ë®ÄÂàáÊç¢ÊåâÈíÆ */
    .lang-toggle-corner {
        position: absolute;
        top: 16px;
        right: 60px;
        min-width: 36px;
        height: 36px;
        padding: 0 12px;
        border: none;
        background: transparent;
        color: var(--text-secondary);
        border-radius: 18px;
        font-size: 13px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1;
        opacity: 0.5;
    }

    .lang-toggle-corner span {
        pointer-events: none;
    }

    .lang-toggle-corner:hover {
        color: var(--accent-blue);
        opacity: 1;
        text-shadow: 0 2px 4px rgba(52, 152, 219, 0.3);
        transform: translateY(-1px);
    }

    .lang-toggle-corner:active {
        text-shadow: none;
        transform: translateY(0);
        opacity: 0.8;
    }

    .theme-toggle-corner {
        position: absolute;
        top: 16px;
        right: 16px;
        width: 36px;
        height: 36px;
        border: none;
        background: var(--accent-blue);
        color: white;
        border-radius: 50%;
        font-size: 16px;
        cursor: pointer;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1;
        box-shadow: 0 2px 8px rgba(52, 152, 219, 0.3);
    }

    .theme-toggle-corner:hover {
        background: var(--bg-button-hover);
        transform: scale(1.1);
        box-shadow: 0 4px 12px rgba(52, 152, 219, 0.4);
    }

    .theme-toggle-corner:active {
        transform: scale(0.95);
    }

    .theme-toggle-icon {
        transition: transform 0.2s;
        pointer-events: none;
    }

    .theme-toggle-corner:hover .theme-toggle-icon {
        transform: rotate(15deg);
    }

    /* Êñá‰ª∂‰∏ä‰º†ËíôÁâà */
    .upload-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.6);
        display: none;
        justify-content: center;
        align-items: flex-end;
        z-index: 2000;
        backdrop-filter: blur(5px);
    }

    .upload-overlay.show {
        display: flex;
    }

    @keyframes slideUp {
        from {
            opacity: 0;
            transform: translateY(100%);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    .upload-dialog {
        background: var(--bg-panel);
        border: 1px solid var(--border-primary);
        border-radius: 16px 16px 0 0;
        box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.3);
        width: 100%;
        max-width: 600px;
        padding: 32px;
        animation: slideUp 0.3s ease-out;
        transition: background 0.3s, border-color 0.3s;
        margin-bottom: 0;
    }

    .upload-title {
        font-size: 20px;
        font-weight: 600;
        color: var(--text-primary);
        margin-bottom: 24px;
        text-align: center;
    }

    .upload-drop-zone {
        border: 2px dashed var(--border-secondary);
        border-radius: 12px;
        padding: 48px 32px;
        text-align: center;
        background: var(--bg-secondary);
        transition: all 0.3s;
        cursor: pointer;
    }

    .upload-drop-zone:hover {
        border-color: var(--accent-blue);
        background: var(--bg-hover);
    }

    .upload-drop-zone.dragover {
        border-color: var(--accent-blue);
        background: var(--bg-active);
        transform: scale(1.02);
    }

    .upload-icon {
        font-size: 48px;
        margin-bottom: 16px;
    }

    .upload-text {
        font-size: 16px;
        font-weight: 500;
        color: var(--text-primary);
        margin-bottom: 8px;
    }

    .upload-subtext {
        font-size: 13px;
        color: var(--text-secondary);
        margin-bottom: 16px;
    }

    .upload-browse-btn {
        padding: 10px 24px;
        background: var(--accent-blue);
        color: white;
        border: none;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
    }

    .upload-browse-btn:hover {
        background: var(--bg-button-hover);
        transform: translateY(-1px);
        box-shadow: 0 2px 8px rgba(52, 152, 219, 0.3);
    }

    .upload-browse-btn:active {
        transform: translateY(0);
    }

    .upload-footer {
        margin-top: 16px;
        text-align: center;
    }

    .upload-hint {
        font-size: 12px;
        color: var(--text-secondary);
    }

    .theme-toggle-container {
        display: flex;
        justify-content: center;
        margin: 16px 0;
    }

    .theme-toggle-btn {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 12px 24px;
        background: var(--accent-blue);
        color: white;
        border: none;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
        box-shadow: 0 2px 8px rgba(52, 152, 219, 0.3);
    }

    .theme-toggle-btn:hover {
        background: var(--bg-button-hover);
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(52, 152, 219, 0.4);
    }

    .theme-toggle-btn:active {
        transform: translateY(0);
    }

    .theme-icon {
        font-size: 16px;
    }

    .theme-text {
        font-weight: 500;
    }

    /* ================================ */
    /* Â±ûÊÄßÈù¢Êùø */
    /* ================================ */
    .property-tabs {
        display: flex;
        border-bottom: 1px solid var(--border-secondary);
        background: var(--bg-secondary);
        padding: 0 2px;
        transition: all 0.3s;
    }

    .property-tab {
        background: none;
        border: none;
        padding: 8px 4px;
        margin: 0;
        font-size: 10.5px;
        font-weight: 500;
        color: var(--text-secondary);
        cursor: pointer;
        transition: all 0.2s;
        border-bottom: 2px solid transparent;
        text-align: center;
        min-width: 50px;
        flex: 1;
        white-space: nowrap;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .property-tab.active {
        color: var(--accent-blue);
        border-bottom-color: var(--accent-blue);
        background: var(--bg-secondary);
    }

    .property-tab:hover:not(.active) {
        color: var(--text-muted);
        background: var(--bg-panel-header);
    }

    .property-content {
        flex: 1;
        padding: 20px 12px 12px;
        min-height: 120px;
        max-height: calc(100vh - 200px);
        display: flex;
        flex-direction: column;
        overflow-y: auto;
        overflow-x: hidden;
        background: var(--bg-secondary);
        transition: background 0.3s;
        scrollbar-width: thin;
        scrollbar-color: var(--text-muted) transparent;
    }

    /* Â±ûÊÄßÈù¢ÊùøÊªöÂä®Êù° */
    .property-content::-webkit-scrollbar {
        width: 6px;
    }

    .property-content::-webkit-scrollbar-track {
        background: transparent;
        border-radius: 3px;
    }

    .property-content::-webkit-scrollbar-thumb {
        background: var(--text-muted);
        border-radius: 3px;
        transition: all 0.2s;
        opacity: 0.5;
    }

    .property-content::-webkit-scrollbar-thumb:hover {
        background: var(--text-secondary);
        opacity: 1;
    }

    .property-content:not(:hover)::-webkit-scrollbar-thumb {
        opacity: 0.3;
    }

    .property-content::-webkit-scrollbar-thumb:active {
        background: var(--text-secondary);
        opacity: 1;
    }

    .property-section {
        display: none;
        flex: 1;
        min-height: 80px;
        padding-right: 4px;
    }

    .property-section.active {
        display: block;
    }

    .property-section h4 {
        margin: 0 0 12px 0;
        font-size: 14px;
        font-weight: 600;
        color: var(--text-primary);
        border-bottom: 1px solid var(--border-primary);
        padding-bottom: 8px;
        transition: color 0.3s, border-color 0.3s;
    }

    /* ËæìÂÖ•Ê°ÜÊ†∑Âºè */
    .property-panel input::placeholder {
        color: var(--text-muted);
        font-style: italic;
        font-size: 11px;
    }

    .property-panel input:focus {
        background-color: var(--input-focus-bg) !important;
        outline: 2px solid var(--accent-blue);
        outline-offset: -1px;
    }

    .transform-controls {
        display: flex;
        flex-direction: column;
        gap: 0;
        margin-bottom: 8px;
    }

    .transform-controls.grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
    }

    .transform-controls.single {
        grid-template-columns: 1fr;
    }

    .transform-controls.full-width {
        display: flex;
        width: 100%;
    }

    .transform-controls.full-width .transform-control {
        width: 100%;
    }

    .transform-control {
        display: flex;
        flex-direction: column;
        gap: 4px;
        min-width: 0;
    }

    .transform-control label {
        font-size: 12px;
        font-weight: 500;
        color: var(--text-muted);
        margin-bottom: 2px;
        line-height: 14px;
        height: 14px;
        transition: color 0.3s;
    }

    .transform-control input[type="number"],
    .transform-control input[type="range"] {
        width: 100%;
        padding: 4px 6px;
        border: 1px solid var(--border-input);
        border-radius: 4px;
        font-size: 12px;
        background: var(--bg-input);
        color: var(--text-primary);
        transition: all 0.15s;
        box-sizing: border-box;
    }

    .transform-control input:focus {
        outline: none;
        border-color: var(--accent-blue);
        box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.25);
    }

    .transform-control input:disabled {
        background-color: var(--bg-panel-header);
        color: var(--text-secondary);
        cursor: not-allowed;
    }

    .transform-control input[type="checkbox"] {
        flex: none;
        width: 12px;
        height: 12px;
        padding: 0;
        margin: 0 6px 0 0;
        border: 1px solid #ccc;
    }

    .transform-control label:has(input[type="checkbox"]) {
        display: flex;
        flex-direction: row;
        align-items: center;
        gap: 6px;
        height: 14px;
    }

    .transform-control label input[type="checkbox"] {
        margin: 0;
        width: 12px;
        height: 12px;
        flex-shrink: 0;
    }

    /* Feature Ë°åÊ†∑Âºè */
    .feature-row {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 6px 8px;
        margin-bottom: 4px;
        border-radius: 4px;
        transition: background-color 0.15s;
        min-height: 26px;
    }

    .feature-row:hover {
        background: var(--accent-light);
    }

    .feature-row:hover .feature-tag {
        background: var(--bg-primary);
        border-color: var(--border-secondary);
        color: var(--text-secondary);
    }

    .feature-row:hover .feature-tag:before {
        background: linear-gradient(to bottom, #0056b3, #004085);
    }

    .feature-row:hover .feature-value-compact {
        border-color: #3498db;
        background: #f0f8ff;
        box-shadow: 0 1px 2px rgba(52, 152, 219, 0.1);
    }

    .feature-row:last-child {
        margin-bottom: 0;
    }

    .feature-tag {
        font-size: 10px;
        font-weight: 500;
        color: var(--text-muted);
        background: var(--bg-secondary);
        border: 1px solid var(--border-secondary);
        padding: 3px 8px;
        border-radius: 4px;
        min-width: 50px;
        flex-shrink: 0;
        position: relative;
    }

    .feature-tag:before {
        content: '';
        position: absolute;
        left: 0;
        top: 0;
        bottom: 0;
        width: 3px;
        background: linear-gradient(to bottom, #3498db, #2980b9);
        border-radius: 2px 0 0 2px;
    }

    .feature-tag-sub {
        font-size: 9px;
        font-weight: 400;
        color: var(--text-muted);
        background: var(--bg-secondary);
        border: 1px solid var(--border-secondary);
        padding: 2px 6px;
        border-radius: 3px;
        min-width: 36px;
        text-align: center;
        margin-left: 12px;
        flex-shrink: 0;
        opacity: 0.8;
    }

    .feature-value-compact {
        font-family: 'JetBrains Mono', 'Fira Code', 'SF Mono', Monaco, Consolas, monospace;
        font-size: 10px;
        font-weight: 400;
        color: #374151;
        background: #fff;
        padding: 2px 6px;
        border-radius: 3px;
        border: 1px solid #e5e7eb;
        min-width: 70px;
        text-align: center;
        transition: all 0.15s;
        flex-shrink: 0;
    }

    .feature-checkbox-inline {
        display: flex;
        align-items: center;
        cursor: pointer;
        user-select: none;
        font-size: 9px;
        color: #6b7280;
        margin-left: auto;
        gap: 3px;
        padding: 2px 6px;
        transition: all 0.15s;
    }

    .feature-checkbox-inline:hover {
        color: #374151;
    }

    .feature-checkbox-inline input[type="checkbox"] {
        width: 10px;
        height: 10px;
        cursor: pointer;
        accent-color: #3498db;
        margin: 0;
    }

    .feature-row-with-checkbox {
        align-items: flex-start !important;
        padding: 6px 8px 8px;
    }

    .feature-value-group {
        display: flex;
        flex-direction: column;
        gap: 4px;
        flex: 1;
    }

    .feature-checkbox {
        display: flex;
        align-items: center;
        cursor: pointer;
        user-select: none;
        font-size: 9px;
        color: #6b7280;
        gap: 3px;
        padding: 2px 6px;
        transition: all 0.15s;
    }

    .feature-checkbox:hover {
        color: #374151;
    }

    .feature-checkbox input[type="checkbox"] {
        width: 10px;
        height: 10px;
        cursor: pointer;
        accent-color: #3498db;
        margin: 0;
    }

    .feature-separator {
        height: 1px;
        background: linear-gradient(90deg, transparent, #e5e7eb 20%, #e5e7eb 80%, transparent);
        margin: 6px 0;
    }

    /* Áªü‰∏ÄÊåâÈíÆÊ†∑Âºè */
    .btn-elegant {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 6px 12px;
        font-size: 11px;
        font-weight: 500;
        border-radius: 6px;
        border: 1px solid var(--border-input);
        background: var(--bg-secondary);
        color: var(--text-primary);
        cursor: pointer;
        transition: all 0.15s;
        user-select: none;
        position: relative;
        overflow: hidden;
    }

    .btn-elegant:before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
        transition: left 0.5s;
    }

    .btn-elegant:hover {
        background: #f9fafb;
        border-color: #9ca3af;
        color: #111827;
        transform: translateY(-1px);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .btn-elegant:hover:before {
        left: 100%;
    }

    .btn-elegant:active {
        transform: translateY(0);
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    }

    .btn-elegant.primary {
        background: var(--bg-button);
        border-color: var(--bg-button);
        color: var(--text-button);
    }

    .btn-elegant.primary:hover {
        background: var(--bg-button-hover);
        border-color: var(--bg-button-hover);
        color: var(--text-button);
    }

    .btn-elegant.danger {
        background: var(--bg-button-danger);
        border-color: var(--bg-button-danger);
        color: var(--text-button);
    }

    .btn-elegant.danger:hover {
        background: var(--bg-button-danger-hover);
        border-color: var(--bg-button-danger-hover);
        color: var(--text-button);
    }

    /* ÂèòÊç¢Êìç‰ΩúÊåâÈíÆ */
    .transform-actions {
        padding: 12px 16px;
        border-top: 1px solid var(--border-secondary);
        display: flex;
        justify-content: flex-end;
        gap: 8px;
        flex-shrink: 0;
        background: var(--bg-secondary);
        transition: all 0.3s;
    }

    .transform-action-btn {
        padding: 10px 16px;
        border: none;
        border-radius: 4px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
        min-width: 80px;
    }

    .transform-action-btn.primary {
        background: var(--bg-button);
        color: white;
        border: 1px solid var(--bg-button);
    }

    .transform-action-btn.primary:hover {
        background: var(--bg-button-hover);
        border-color: var(--bg-button-hover);
        box-shadow: var(--shadow-light);
    }

    .transform-action-btn.secondary {
        background: var(--text-muted);
        color: white;
        border: 1px solid var(--text-muted);
    }

    .transform-action-btn.secondary:hover {
        background: var(--text-secondary);
        border-color: var(--text-secondary);
        box-shadow: var(--shadow-light);
    }

    /* TransformÊéß‰ª∂ÁªÑ */
    .transform-control-group {
        display: flex;
        flex-direction: row;
        gap: 6px;
        margin-bottom: 0;
    }

    .feature-row .transform-control-group {
        flex: 1;
        justify-content: flex-end;
        min-width: 0;
    }

    .transform-control-group.vertical {
        flex-direction: column;
        gap: 8px;
    }

    .transform-control-group + .transform-control-group {
        margin-top: 16px;
        padding-top: 12px;
        position: relative;
    }

    .transform-control-group + .transform-control-group:before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 1px;
        background: linear-gradient(to right, transparent, #d1d5db 20%, #d1d5db 80%, transparent);
        opacity: 0.6;
    }

    .transform-control-row {
        display: flex;
        gap: 12px;
        align-items: flex-start;
    }

    /* Áü©ÈòµÊòæÁ§∫Ê†∑Âºè */
    .matrix-display {
        display: inline-flex;
        align-items: center;
        font-family: 'Computer Modern', 'Times New Roman', serif;
        font-size: 14px;
        color: var(--text-primary);
        margin: 4px 0;
    }

    .matrix-bracket {
        font-size: 32px;
        font-weight: 300;
        line-height: 0.9;
        margin: 0 4px;
        font-family: 'Computer Modern', 'Times New Roman', serif;
        color: var(--text-primary);
    }

    .matrix-grid {
        display: flex;
        flex-direction: column;
        gap: 6px;
        padding: 2px 0;
    }

    .matrix-row {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 8px;
    }

    .matrix-element {
        display: flex;
        justify-content: center;
        align-items: center;
        width: 60px;
        height: 20px;
        font-family: 'Computer Modern', 'Courier New', monospace;
        font-size: 14px;
        color: var(--text-primary);
        text-align: center;
        position: relative;
    }

    .matrix-input {
        border: none;
        border-bottom: 1px solid var(--text-muted);
        background: transparent;
        outline: none;
        padding: 0;
        margin: 0;
        font-family: 'Computer Modern', 'Courier New', monospace;
        font-size: 14px;
        color: var(--text-primary);
        text-align: center;
        width: 60px;
        height: 20px;
        box-sizing: border-box;
        transition: all 0.2s;
    }

    .matrix-input:focus {
        border-bottom-color: var(--accent-blue);
        background: var(--input-focus-bg);
    }

    /* FeatureÁªÑÊ†∑Âºè */
    .feature-group {
        margin-bottom: 16px;
    }

    .feature-group-header {
        font-weight: 600;
        font-size: 14px;
        color: var(--text-primary);
        margin-bottom: 8px;
        padding-bottom: 4px;
        border-bottom: 1px solid var(--border-secondary);
    }

    .feature-label {
        font-size: 12px;
        color: var(--text-secondary);
        min-width: 80px;
    }

    .feature-label-sub {
        font-size: 11px;
        color: var(--text-muted);
        min-width: 80px;
        padding-left: 12px;
    }

    .property-input {
        border: 1px solid var(--border-secondary);
        border-radius: 4px;
        padding: 2px 6px;
        font-size: 12px;
        width: 80px;
        text-align: center;
        background: var(--bg-input);
        color: var(--text-primary);
    }

    .transform-control-group .property-input {
        flex: 1;
        width: auto;
        min-width: 50px;
        max-width: 70px;
    }

    .property-input:focus {
        border-color: #0066cc;
        outline: none;
        box-shadow: 0 0 0 2px rgba(0, 102, 204, 0.1);
    }

    .feature-value {
        font-family: 'Courier New', monospace;
        font-size: 12px;
        color: #374151;
        background: #f9fafb;
        border: 1px solid #e5e7eb;
        border-radius: 3px;
        padding: 3px 6px;
        min-width: 80px;
        text-align: center;
        display: inline-block;
    }

    .feature-point {
        font-family: 'Courier New', monospace;
        font-size: 11px;
        color: #4b5563;
        background: #f3f4f6;
        border: 1px solid #d1d5db;
        border-radius: 3px;
        padding: 2px 5px;
        margin: 1px;
        display: inline-block;
    }

    .empty-message {
        color: #9ca3af;
        font-size: 13px;
        font-style: italic;
        padding: 12px;
        text-align: center;
        margin: 0;
    }

    body.dark-mode .empty-message {
        color: #6b7280;
    }
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<!-- ÁªòÂà∂ËèúÂçï -->
<div id="drawMenu" class="draw-menu" style="display: none;">
    <div class="menu-item" data-type="3">
        <span class="menu-icon">‚îÄ</span>
        <span class="menu-text"></span>
    </div>
    <div class="menu-item" data-type="2">
        <span class="menu-icon">‚ñ≠</span>
        <span class="menu-text"></span>
    </div>
    <div class="menu-item" data-type="1">
        <span class="menu-icon">‚óã</span>
        <span class="menu-text"></span>
    </div>
    <div class="menu-item" data-type="4">
        <span class="menu-icon">‚åí</span>
        <span class="menu-text"></span>
    </div>
    <div class="menu-item" data-type="6">
        <span class="menu-icon">‚àø</span>
        <span class="menu-text"></span>
    </div>
    <div class="menu-item" data-type="7">
        <span class="menu-icon">
            <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                <!-- Ë¥ùÂ°ûÂ∞îÊõ≤Á∫ø -->
                <path d="M2 12 C5 2, 11 2, 14 4" stroke="currentColor" stroke-width="1" fill="none"/>
                <!-- ÊéßÂà∂ÁÇπ -->
                <circle cx="5" cy="2" r="1.2" fill="currentColor" opacity="0.7"/>
                <circle cx="11" cy="2" r="1.2" fill="currentColor" opacity="0.7"/>
                <!-- Á´ØÁÇπ -->
                <circle cx="2" cy="12" r="1" fill="currentColor"/>
                <circle cx="14" cy="4" r="1" fill="currentColor"/>
                <!-- ÊéßÂà∂Á∫ø -->
                <line x1="2" y1="12" x2="5" y2="2" stroke="currentColor" stroke-width="2.5" opacity="0.8" stroke-dasharray="2,1"/>
                <line x1="14" y1="4" x2="11" y2="2" stroke="currentColor" stroke-width="2.5" opacity="0.8" stroke-dasharray="2,1"/>
            </svg>
        </span>
        <span class="menu-text"></span>
    </div>
</div>

<!-- Âè≥‰∏ãËßíÂáΩÊï∞ÊåâÈíÆ -->
<div class="function-button" id="functionButton" onclick="event.stopPropagation(); UIOpenFunctionDialog();" title="ÂáΩÊï∞ÁªòÂà∂">
    <span class="function-icon">f(x)</span>
</div>

<!-- ÂáΩÊï∞ÂÖ¨ÂºèÂØπËØùÊ°Ü -->
<div class="function-overlay" id="functionOverlay">
    <div class="function-dialog">
        <div class="function-header">
            <h3 class="function-title">FUNC_DRAW</h3>
            <button class="function-close" onclick="UICloseFunctionDialog()">√ó</button>
        </div>
        <div class="function-content">
            <div class="function-group">
                <label class="function-label">FUNC_EXPR</label>
                <div class="function-description">FUNC_EXPR_DESC</div>
                <div class="function-input-group">
                    <span class="function-prefix">y =</span>
                    <input type="text" class="function-input" id="functionInput" placeholder="FUNC_EXPR_PLACEHOLDER"
                           inputmode="latin" lang="en" autocomplete="off" data-chrome-autofill="false" />
                </div>
            </div>
            <div class="function-group">
                <label class="function-label">DOMAIN</label>
                <div class="function-description">DOMAIN_DESC</div>
                <div class="function-range-group">
                    <label class="range-label">X_FROM</label>
                    <input type="number" class="range-input" id="xMinInput" value="-10" step="0.1" placeholder="-‚àû" title="EMPTY_INFINITY"
                           inputmode="decimal" lang="en" autocomplete="off" />
                    <label class="range-label">X_TO</label>
                    <input type="number" class="range-input" id="xMaxInput" value="10" step="0.1" placeholder="+‚àû" title="EMPTY_INFINITY"
                           inputmode="decimal" lang="en" autocomplete="off" />
                </div>
            </div>
        </div>
        <div class="function-footer">
            <button class="function-btn cancel" onclick="event.stopPropagation(); UICloseFunctionDialog()">CANCEL</button>
            <button class="function-btn preview" onclick="event.stopPropagation(); uiPreviewFunction()">PREVIEW</button>
            <button class="function-btn apply" onclick="event.stopPropagation(); uiApplyFunction()">DRAW</button>
        </div>
    </div>
</div>

<!-- ÂÖÉÁ¥†ÈòüÂàóÈù¢Êùø -->
<div class="elements-panel" id="elementsPanel">
    <div class="panel-header">
        <span><span></span> (<span id="elementCount"></span>)</span>
        <button class="panel-toggle" onclick="UIToggleElementsPanel()">√ó</button>
    </div>
    <div class="elements-list" id="elementsList">
        <!-- ÂÖÉÁ¥†ÂàóË°®Â∞ÜÂú®ËøôÈáåÂä®ÊÄÅÁîüÊàê -->
    </div>
</div>

<!-- ÂÖÉÁ¥†‰ø°ÊÅØÁºñËæëÈù¢Êùø -->
<div class="property-panel" id="propertyPanel">
    <div class="panel-header">
        <span>PROPERTY_PANEL</span>
        <button class="panel-toggle" onclick="UIHidePropertyPanel()">√ó</button>
    </div>
    <div class="property-tabs">
        <button class="property-tab active" data-tab="props" onclick="uiSwitchPropertiesTab('props')">PROPS</button>
        <button class="property-tab" data-tab="flip" onclick="uiSwitchPropertiesTab('flip')">FLIP</button>
        <button class="property-tab" data-tab="shear" onclick="uiSwitchPropertiesTab('shear')">SHEAR</button>
        <button class="property-tab" data-tab="rotation" onclick="uiSwitchPropertiesTab('rotation')">ROTATION</button>
        <button class="property-tab" data-tab="scale" onclick="uiSwitchPropertiesTab('scale')">SCALE</button>
        <button class="property-tab" data-tab="translation" onclick="uiSwitchPropertiesTab('translation')">TRANSLATION</button>
    </div>
    <div class="property-content">
        <!-- ÁâπÊÄß -->
        <div class="property-section active" id="props-section">
            <!-- Á¨¨‰∏ÄÁ±ªÔºöÂèÇÊï∞ (Parameters) - ÂèØÁºñËæëÁöÑÂàõÂª∫ÂèÇÊï∞ -->
            <div class="feature-group">
                <div class="feature-group-header">PARAMETERS</div>
                <div id="elementParameters"></div>
            </div>

            <!-- Á¨¨‰∫åÁ±ªÔºöÂ±ûÊÄß (Properties) - ËÆ°ÁÆóÂæóÂá∫ÁöÑÈáèÂÄº -->
            <div class="feature-group" id="propertiesGroup">
                <div class="feature-group-header">PROPERTIES</div>

                <div class="feature-row feature-row-with-checkbox" id="geometricCenterRow">
                    <span class="feature-label">GEOMETRIC_CENTER</span>
                    <div class="feature-value-group">
                        <span class="feature-value" id="geometricCenter"></span>
                        <label class="feature-checkbox">
                            <input type="checkbox" id="showArea" onchange="uiActToggleAreaVisible(this)">
                            <span data-label="show">SHOW</span>
                        </label>
                    </div>
                </div>

                <div class="feature-row" id="areaDimensions" style="display: none;">
                    <span class="feature-label-sub">AREA</span>
                    <span class="feature-value" id="areaValue">0.00</span>
                </div>

                <div class="feature-row feature-row-with-checkbox" id="boundingCenterRow">
                    <span class="feature-label">BOUNDING_CENTER</span>
                    <div class="feature-value-group">
                        <span class="feature-value" id="boundingCenter"></span>
                        <label class="feature-checkbox">
                            <input type="checkbox" id="showBoundingRect" onchange="uiActToggleBoundingRectVisible(this)">
                            <span data-label="show">SHOW</span>
                        </label>
                    </div>
                </div>

                <div class="feature-row" id="boundingDimensions" style="display: none;">
                    <span class="feature-label-sub">BOUNDING_SIZE</span>
                    <span class="feature-value" id="boundingSize"></span>
                </div>

                <!-- Âä®ÊÄÅÂ±ûÊÄß -->
                <div id="dynamicProperties"></div>
            </div>

            <!-- Á¨¨‰∏âÁ±ªÔºöÁâπÂæÅÁÇπ (Feature Points) - ÂÖ≥ÈîÆÁÇπÂùêÊ†á -->
            <div class="feature-group" id="featurePointsGroup">
                <div class="feature-group-header">FEATURE_POINTS</div>
                <div id="featurePoints"></div>
            </div>
        </div>

        <!-- ÁøªËΩ¨ -->
        <div class="property-section" id="flip-section">
            <div class="transform-controls">
                <!-- ËßÇÊµãÁÇπÂùêÊ†áÁªÑ -->
                <div class="transform-control-group vertical">
                    <div class="transform-control-row" style="display: flex; gap: 12px;">
                        <div class="transform-control" style="flex: 1;">
                            <label data-label="observe-x">OBSERVE_X</label>
                            <input type="number" id="flipObserveX" value="0"
                                   onchange="uiActTransformModified(this, DATA_TYPES.F, 'flip.observePos[0]', true)"
                                   step="0.01">
                        </div>
                        <div class="transform-control" style="flex: 1;">
                            <label data-label="observe-y">OBSERVE_Y</label>
                            <input type="number" id="flipObserveY" value="0"
                                   onchange="uiActTransformModified(this, DATA_TYPES.F, 'flip.observePos[1]', true)"
                                   step="0.01">
                        </div>
                    </div>
                    <!-- ËßÇÊµãÁÇπÁõ∏ÂÖ≥ÁöÑÂ±ÄÂüüÂØπÁß∞ÊÄßÁ∫¶Êùü -->
                    <div class="transform-control" style="margin-top: 8px;">
                        <label>
                            <input type="checkbox" id="flipObservePosLSConstrain" onchange="uiActToggleLocalSymmetryConstrain(this, true)">
                            <span data-label="local-symmetry">LOCAL_SYMMETRY</span>
                        </label>
                        <p style="font-size: 11px; color: #666; margin: 4px 0 0 20px;" data-label="local-symmetry-desc">LOCAL_SYMMETRY_DESC</p>
                    </div>
                </div>

                <!-- ËßÇÊµãÊñπÂêëÁªÑ -->
                <div class="transform-control-group vertical">
                    <div class="transform-control">
                        <label data-label="observe-dir">OBSERVE_DIR</label>
                        <input type="number" id="flipObserveD" value="" placeholder="TOWARD_CENTROID" data-placeholder="toward-centroid"
                               onchange="uiActObserveDirModified(this, 'flip')"
                               step="0.1" min="-360" max="360">
                    </div>
                    <!-- ËßÇÊµãÊñπÂêëÁõ∏ÂÖ≥ÁöÑÂ±ÄÂüüÂØπÁß∞ÊÄßÁ∫¶ÊùüÔºàÂè™Âú®ËßÇÊµãÁÇπÂú®Â§ñÈÉ®Êó∂ÊòæÁ§∫Ôºâ -->
                    <div class="transform-control" id="flipObserveDirLSConstrainFrame" style="margin-top: 8px; display: none;">
                        <label>
                            <input type="checkbox" id="flipObserveDirLSConstrain" onchange="uiActToggleLocalSymmetryConstrain(this, false)">
                            <span data-label="local-symmetry">LOCAL_SYMMETRY</span>
                        </label>
                        <p style="font-size: 11px; color: #666; margin: 4px 0 0 20px;" data-label="observe-dir-ls-desc">OBSERVE_DIR_LS_DESC</p>
                    </div>
                </div>

                <!-- ÊúùÂêëÁøªËΩ¨ÁªÑ -->
                <div class="transform-control-group vertical">
                    <div class="transform-control">
                        <label>
                            <input type="checkbox" id="flipForwardY"
                                   onchange="uiActTransformModified(this, DATA_TYPES.B, 'flip.forwardY', true); uiUpdateFlipMatrix()">
                            <span data-label="forward-flip">FORWARD_FLIP</span>
                        </label>
                        <div class="matrix-display">
                            <span class="matrix-bracket">[</span>
                            <div class="matrix-grid">
                                <div class="matrix-row">
                                    <span class="matrix-element">1</span>
                                    <span class="matrix-element">0</span>
                                </div>
                                <div class="matrix-row">
                                    <span class="matrix-element">0</span>
                                    <span class="matrix-element" id="flipForwardYValue">1</span>
                                </div>
                            </div>
                            <span class="matrix-bracket">]</span>
                        </div>
                    </div>
                </div>

                <!-- ÂùêÂêëÁøªËΩ¨ÁªÑ -->
                <div class="transform-control-group vertical">
                    <div class="transform-control">
                        <label>
                            <input type="checkbox" id="flipSideX"
                                   onchange="uiActTransformModified(this, DATA_TYPES.B, 'flip.sideX', true); uiUpdateFlipMatrix()">
                            <span data-label="side-flip">SIDE_FLIP</span>
                        </label>
                        <div class="matrix-display">
                            <span class="matrix-bracket">[</span>
                            <div class="matrix-grid">
                                <div class="matrix-row">
                                    <span class="matrix-element" id="flipSideXValue">1</span>
                                    <span class="matrix-element">0</span>
                                </div>
                                <div class="matrix-row">
                                    <span class="matrix-element">0</span>
                                    <span class="matrix-element">1</span>
                                </div>
                            </div>
                            <span class="matrix-bracket">]</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Ââ™Âàá -->
        <div class="property-section" id="shear-section">
            <div class="transform-controls">
                <!-- ËßÇÊµãÁÇπÂùêÊ†áÁªÑ -->
                <div class="transform-control-group vertical">
                    <div class="transform-control-row" style="display: flex; gap: 12px;">
                        <div class="transform-control" style="flex: 1;">
                            <label data-label="observe-x">OBSERVE_X</label>
                            <input type="number" id="shearObserveX" value="0"
                                   onchange="uiActTransformModified(this, DATA_TYPES.F, 'shear.observePos[0]', true)"
                                   step="0.01">
                        </div>
                        <div class="transform-control" style="flex: 1;">
                            <label data-label="observe-y">OBSERVE_Y</label>
                            <input type="number" id="shearObserveY" value="0"
                                   onchange="uiActTransformModified(this, DATA_TYPES.F, 'shear.observePos[1]', true)"
                                   step="0.01">
                        </div>
                    </div>
                    <!-- ËßÇÊµãÁÇπÁõ∏ÂÖ≥ÁöÑÂ±ÄÂüüÂØπÁß∞ÊÄßÁ∫¶Êùü -->
                    <div class="transform-control" style="margin-top: 8px;">
                        <label>
                            <input type="checkbox" id="shearObservePosLSConstrain" onchange="uiActToggleLocalSymmetryConstrain(this, true)">
                            <span data-label="local-symmetry">LOCAL_SYMMETRY</span>
                        </label>
                        <p style="font-size: 11px; color: #666; margin: 4px 0 0 20px;" data-label="local-symmetry-desc">LOCAL_SYMMETRY_DESC</p>
                    </div>
                </div>

                <!-- ËßÇÊµãÊñπÂêëÁªÑ -->
                <div class="transform-control-group vertical">
                    <div class="transform-control">
                        <label data-label="observe-dir">OBSERVE_DIR</label>
                        <input type="number" id="shearObserveD" value="" placeholder="AUTO" data-placeholder="auto"
                               onchange="uiActObserveDirModified(this, 'shear')"
                               step="0.1" min="-360" max="360">
                    </div>
                    <!-- ËßÇÊµãÊñπÂêëÁõ∏ÂÖ≥ÁöÑÂ±ÄÂüüÂØπÁß∞ÊÄßÁ∫¶ÊùüÔºàÂè™Âú®ËßÇÊµãÁÇπÂú®Â§ñÈÉ®Êó∂ÊòæÁ§∫Ôºâ -->
                    <div class="transform-control" id="shearObserveDirLSConstrainFrame" style="margin-top: 8px; display: none;">
                        <label>
                            <input type="checkbox" id="shearObserveDirLSConstrain" onchange="uiActToggleLocalSymmetryConstrain(this, false)">
                            <span data-label="local-symmetry">LOCAL_SYMMETRY</span>
                        </label>
                        <p style="font-size: 11px; color: #666; margin: 4px 0 0 20px;" data-label="observe-dir-ls-desc">OBSERVE_DIR_LS_DESC</p>
                    </div>
                </div>

                <!-- ÊúùÂêëÂâ™ÂàáÁªÑ -->
                <div class="transform-control-group vertical">
                    <div class="transform-control">
                        <label data-label="forward-shear">FORWARD_SHEAR</label>
                        <div class="matrix-display">
                            <span class="matrix-bracket">[</span>
                            <div class="matrix-grid">
                                <div class="matrix-row">
                                    <span class="matrix-element">1</span>
                                    <span class="matrix-element">0</span>
                                </div>
                                <div class="matrix-row">
                                    <input type="text" class="matrix-element matrix-input" id="shearForwardY" value="0"
                                           onchange="uiActTransformModified(this, DATA_TYPES.F, 'shear.forwardY', true)">
                                    <span class="matrix-element">1</span>
                                </div>
                            </div>
                            <span class="matrix-bracket">]</span>
                        </div>
                    </div>
                </div>

                <!-- ÂùêÂêëÂâ™ÂàáÁªÑ -->
                <div class="transform-control-group vertical">
                    <div class="transform-control">
                        <label data-label="side-shear">SIDE_SHEAR</label>
                        <div class="matrix-display">
                            <span class="matrix-bracket">[</span>
                            <div class="matrix-grid">
                                <div class="matrix-row">
                                    <span class="matrix-element">1</span>
                                    <input type="text" class="matrix-element matrix-input" id="shearSideX" value="0"
                                           onchange="uiActTransformModified(this, DATA_TYPES.F, 'shear.sideX', true)">
                                </div>
                                <div class="matrix-row">
                                    <span class="matrix-element">0</span>
                                    <span class="matrix-element">1</span>
                                </div>
                            </div>
                            <span class="matrix-bracket">]</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ÊóãËΩ¨ -->
        <div class="property-section" id="rotation-section">
            <div class="transform-controls">
                <!-- ËßÇÊµãÁÇπÂùêÊ†áÁªÑ -->
                <div class="transform-control-group vertical">
                    <div class="transform-control-row" style="display: flex; gap: 12px;">
                        <div class="transform-control" style="flex: 1;">
                            <label data-label="observe-x">OBSERVE_X</label>
                            <input type="number" id="rotationObserveX" value="0"
                                   onchange="uiActTransformModified(this, DATA_TYPES.F, 'rotation.observePos[0]', true)"
                                   step="0.1">
                        </div>
                        <div class="transform-control" style="flex: 1;">
                            <label data-label="observe-y">OBSERVE_Y</label>
                            <input type="number" id="rotationObserveY" value="0"
                                   onchange="uiActTransformModified(this, DATA_TYPES.F, 'rotation.observePos[1]', true)"
                                   step="0.1">
                        </div>
                    </div>
                    <!-- ËßÇÊµãÁÇπÁõ∏ÂÖ≥ÁöÑÂ±ÄÂüüÂØπÁß∞ÊÄßÁ∫¶Êùü -->
                    <div class="transform-control" style="margin-top: 8px;">
                        <label>
                            <input type="checkbox" id="rotationObservePosLSConstrain" onchange="uiActToggleLocalSymmetryConstrain(this, true)">
                            <span data-label="local-symmetry">LOCAL_SYMMETRY</span>
                        </label>
                        <p style="font-size: 11px; color: #666; margin: 4px 0 0 20px;" data-label="local-symmetry-desc">LOCAL_SYMMETRY_DESC</p>
                    </div>
                </div>

                <!-- ÊóãËΩ¨Áü©ÈòµÁªÑ -->
                <div class="transform-control-group vertical">
                    <!-- Á¨¨‰∏ÄË°åÔºöÊóãËΩ¨ËßíÂ∫¶ËæìÂÖ•Ê°Ü -->
                    <div class="transform-control">
                        <label data-label="rotation-angle">ROTATION_ANGLE</label>
                        <input type="number" id="rotationAngle" value="0"
                               onchange="uiActTransformModified(this, DATA_TYPES.F+DECIMAL_PRECISION_ANGLE, 'rotation.angle', true); uiUpdateRotationMatrix()"
                               step="1" min="-360" max="360">
                    </div>

                    <!-- Âêë‰∏ãÁÆ≠Â§¥1 -->
                    <div style="margin: 6px 0; position: relative;">
                        <div style="display: inline-block; visibility: hidden; font-family: 'Computer Modern', 'Times New Roman', serif; font-size: 14px;">
                            [<span style="margin: 0 8px;">cos Œ∏</span>]
                        </div>
                        <span style="position: absolute; left: 50%; top: 0; transform: translateX(-50%); font-size: 14px; color: var(--text-muted);">‚áì</span>
                    </div>

                    <!-- Á¨¨‰∫åË°åÔºöÁü©ÈòµÂÖ¨ÂºèÈ°π -->
                    <div class="transform-control">
                        <label style="font-size: 12px; font-weight: 500; color: var(--text-muted);" data-label="matrix-formula">MATRIX_FORMULA</label>
                        <div class="matrix-display" style="margin-top: 4px;">
                            <span class="matrix-bracket">[</span>
                            <div class="matrix-grid">
                                <div class="matrix-row">
                                    <span class="matrix-element">cos Œ∏</span>
                                    <span class="matrix-element">-sin Œ∏</span>
                                </div>
                                <div class="matrix-row">
                                    <span class="matrix-element">sin Œ∏</span>
                                    <span class="matrix-element">cos Œ∏</span>
                                </div>
                            </div>
                            <span class="matrix-bracket">]</span>
                        </div>
                    </div>

                    <!-- Âêë‰∏ãÁÆ≠Â§¥2 -->
                    <div style="margin: 6px 0; position: relative;">
                        <div style="display: inline-block; visibility: hidden; font-family: 'Computer Modern', 'Times New Roman', serif; font-size: 14px;">
                            [<span style="margin: 0 8px;">1.00</span>]
                        </div>
                        <span style="position: absolute; left: 50%; top: 0; transform: translateX(-50%); font-size: 14px; color: var(--text-muted);">‚áì</span>
                    </div>

                    <!-- Á¨¨‰∏âË°åÔºöÊóãËΩ¨Áü©ÈòµÁªìÊûú -->
                    <div class="transform-control">
                        <label style="font-size: 12px; font-weight: 500; color: var(--text-muted);" data-label="rotation-matrix">ROTATION_MATRIX</label>
                        <div class="matrix-display" style="margin-top: 4px;">
                            <span class="matrix-bracket">[</span>
                            <div class="matrix-grid">
                                <div class="matrix-row">
                                    <span class="matrix-element" id="rotationCos">1</span>
                                    <span class="matrix-element" id="rotationNegSin">0</span>
                                </div>
                                <div class="matrix-row">
                                    <span class="matrix-element" id="rotationSin">0</span>
                                    <span class="matrix-element" id="rotationCos2">1</span>
                                </div>
                            </div>
                            <span class="matrix-bracket">]</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Áº©Êîæ -->
        <div class="property-section" id="scale-section">
            <div class="transform-controls">
                <!-- ËßÇÊµãÁÇπÂùêÊ†áÁªÑ -->
                <div class="transform-control-group vertical">
                    <div class="transform-control-row" style="display: flex; gap: 12px;">
                        <div class="transform-control" style="flex: 1;">
                            <label data-label="observe-x">OBSERVE_X</label>
                            <input type="number" id="scaleObserveX" value="0"
                                   onchange="uiActTransformModified(this, DATA_TYPES.F, 'scale.observePos[0]', true)"
                                   step="0.1">
                        </div>
                        <div class="transform-control" style="flex: 1;">
                            <label data-label="observe-y">OBSERVE_Y</label>
                            <input type="number" id="scaleObserveY" value="0"
                                   onchange="uiActTransformModified(this, DATA_TYPES.F, 'scale.observePos[1]', true)"
                                   step="0.1">
                        </div>
                    </div>
                    <!-- ËßÇÊµãÁÇπÁõ∏ÂÖ≥ÁöÑÂ±ÄÂüüÂØπÁß∞ÊÄßÁ∫¶Êùü -->
                    <div class="transform-control" style="margin-top: 8px;">
                        <label>
                            <input type="checkbox" id="scaleObservePosLSConstrain" onchange="uiActToggleLocalSymmetryConstrain(this, true)">
                            <span data-label="local-symmetry">LOCAL_SYMMETRY</span>
                        </label>
                        <p style="font-size: 11px; color: #666; margin: 4px 0 0 20px;" data-label="local-symmetry-desc">LOCAL_SYMMETRY_DESC</p>
                    </div>
                </div>

                <!-- Áº©ÊîæÁü©ÈòµÁªÑ -->
                <div class="transform-control-group vertical">
                    <div class="transform-control">
                        <label data-label="scale-matrix">SCALE_MATRIX</label>
                        <div class="matrix-display">
                            <span class="matrix-bracket">[</span>
                            <div class="matrix-grid">
                                <div class="matrix-row">
                                    <input type="text" class="matrix-element matrix-input" id="scaleX" value="1"
                                           onchange="uiActTransformModified(this, DATA_TYPES.F, 'scale.x', true)">
                                    <span class="matrix-element">0</span>
                                </div>
                                <div class="matrix-row">
                                    <span class="matrix-element">0</span>
                                    <input type="text" class="matrix-element matrix-input" id="scaleY" value="1"
                                           onchange="uiActTransformModified(this, DATA_TYPES.F, 'scale.y', true)">
                                </div>
                            </div>
                            <span class="matrix-bracket">]</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Âπ≥Áßª -->
        <div class="property-section" id="translation-section">
            <div class="transform-control-group vertical">
                <div class="transform-control-row" style="display: flex; gap: 12px;">
                    <div class="transform-control" style="flex: 1;">
                        <label data-label="x-displacement">X_DISPLACEMENT</label>
                        <input type="number" id="translationX" value="0"
                               onchange="uiActTransformModified(this, DATA_TYPES.F, 'translation[0]', true)"
                               step="0.5">
                    </div>
                    <div class="transform-control" style="flex: 1;">
                        <label data-label="y-displacement">Y_DISPLACEMENT</label>
                        <input type="number" id="translationY" value="0"
                               onchange="uiActTransformModified(this, DATA_TYPES.F, 'translation[1]', true)"
                               step="0.5">
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="transform-actions">
        <button class="btn-elegant danger" onclick="uiResetProperties()">RESET</button>
        <button class="btn-elegant primary" onclick="uiApplyProperties()">APPLY</button>
    </div>
</div>

<!-- ÂÖÉÁ¥†Â±ûÊÄßËÆæÁΩÆÂØπËØùÊ°Ü -->
<div class="attribute-overlay" id="attributesOverlay">
    <div class="settings-dialog">
        <div class="settings-header">
            <h3 class="settings-title">ELEMENT_ATTR</h3>
            <button class="settings-close" onclick="UICloseAttributes()">√ó</button>
        </div>
        <div class="settings-content">
            <div class="setting-group">
                <label class="setting-label">LINE_COLOR</label>
                <div class="setting-description">LINE_COLOR_DESC</div>
                <div class="color-picker-group" id="colorPickerGroup">
                    <!-- È¢úËâ≤ÈÄâÈ°πÂ∞ÜÂú®ËøôÈáåÂä®ÊÄÅÁîüÊàê -->
                </div>
            </div>
            <div class="setting-group">
                <label class="setting-label">LINE_WIDTH</label>
                <div class="setting-description">LINE_WIDTH_DESC</div>
                <div class="width-picker-group">
                    <input type="range" class="width-slider" id="widthSlider"
                           min="0.5" max="10" step="0.5" value="2"
                           oninput="uiUpdateWidthPreview(this.value)">
                    <div class="width-display">
                        <span class="width-value" id="widthValue">2.0</span>
                        <span class="width-unit">WIDTH_UNIT</span>
                    </div>
                    <div class="width-preview" id="widthPreview"></div>
                </div>
            </div>
        </div>
        <div class="settings-footer">
            <button class="settings-btn cancel" onclick="UICloseAttributes()">CANCEL</button>
            <button class="btn-elegant primary" onclick="uiApplyAttributes()">APPLY</button>
        </div>
    </div>
</div>

<!-- Êñá‰ª∂‰∏ä‰º†ËíôÁâà -->
<div class="upload-overlay" id="uploadOverlay">
    <div class="upload-dialog">
        <div class="upload-title">UPLOAD_TITLE</div>
        <div class="upload-drop-zone" id="uploadDropZone">
            <div class="upload-icon">üìÅ</div>
            <div class="upload-text">UPLOAD_DROP_TEXT</div>
            <div class="upload-subtext">UPLOAD_DROP_SUBTEXT</div>
            <button class="upload-browse-btn" id="uploadBrowseBtn">UPLOAD_BROWSE_BTN</button>
        </div>
        <div class="upload-footer">
            <span class="upload-hint">UPLOAD_HINT</span>
        </div>
    </div>
</div>

<!-- ‰ΩøÁî®ËØ¥ÊòéÂØπËØùÊ°Ü -->
<div class="help-overlay" id="helpOverlay">
    <div class="help-dialog">
        <div class="help-dialog-content">
            <div class="help-title">HELP_TITLE</div>

            <!-- Tab ÂàáÊç¢Âô® -->
            <div class="help-tabs">
                <div class="help-tab active" data-tab="basic">HELP_TAB_BASIC</div>
                <div class="help-tab" data-tab="coordinate">HELP_TAB_COORDINATE</div>
                <div class="help-tab" data-tab="element">HELP_TAB_ELEMENT</div>
                <div class="help-tab" data-tab="app">HELP_TAB_APP</div>
            </div>

            <!-- Âü∫Á°ÄÊìç‰Ωú Tab -->
            <div class="help-tab-content active" id="help-tab-basic">
                <div class="help-section">
                    <div class="help-item">
                        <span class="help-key">HELP_LEFT_DRAG</span>
                        <span class="help-description">HELP_LEFT_DRAG_DESC</span>
                    </div>
                    <div class="help-item">
                        <span class="help-key">HELP_LEFT_DOUBLE_CLICK</span>
                        <span class="help-description">HELP_LEFT_DOUBLE_CLICK_DESC</span>
                    </div>
                    <div class="help-item">
                        <span class="help-key">HELP_CMD_LEFT_CLICK</span>
                        <span class="help-description">HELP_CMD_LEFT_CLICK_DESC</span>
                    </div>
                    <div class="help-item">
                        <span class="help-key">HELP_ALT_KEY</span>
                        <span class="help-description">HELP_ALT_KEY_DESC</span>
                    </div>
                </div>
                <div class="help-section">
                    <div class="help-item">
                        <span class="help-key">HELP_RIGHT_CLICK</span>
                        <span class="help-description">HELP_RIGHT_CLICK_DESC</span>
                    </div>
                    <div class="help-item">
                        <span class="help-key">HELP_RIGHT_DOUBLE_CLICK</span>
                        <span class="help-description">HELP_RIGHT_DOUBLE_CLICK_DESC</span>
                    </div>
                    <div class="help-item">
                        <span class="help-key">HELP_CTRL_LEFT_DRAG</span>
                        <span class="help-description">HELP_CTRL_LEFT_DRAG_DESC</span>
                    </div>

                </div>

                <div class="help-note">
                    <p class="help-note-text">HELP_BASIC_TIP1</p>
                </div>
                <div class="help-note">
                    <p class="help-note-text">HELP_BASIC_TIP2</p>
                </div>
            </div>

            <!-- ÂùêÊ†áÁ≥ªÊìç‰Ωú Tab -->
            <div class="help-tab-content" id="help-tab-coordinate">
                <div class="help-section">
                    <div class="help-item">
                        <span class="help-key">HELP_Z_LEFT_DRAG</span>
                        <span class="help-description">HELP_Z_LEFT_DRAG_DESC</span>
                    </div>
                    <div class="help-item">
                        <span class="help-key">HELP_DOUBLE_Z</span>
                        <span class="help-description">HELP_DOUBLE_Z_DESC</span>
                    </div>
                    <div class="help-item">
                        <span class="help-key">HELP_WHEEL</span>
                        <span class="help-description">HELP_WHEEL_DESC</span>
                    </div>
                    <div class="help-item">
                        <span class="help-key">HELP_CMD_DOUBLE_CLICK_ITEM</span>
                        <span class="help-description">HELP_CMD_DOUBLE_CLICK_ITEM_DESC</span>
                    </div>
                </div>

                <div class="help-note">
                    <p class="help-note-text">HELP_COORDINATE_TIP</p>
                </div>
            </div>

            <!-- Ë∑üË∏™Ê®°Âºè Tab -->
            <div class="help-tab-content" id="help-tab-element">

                <div class="help-section">
                    <div class="help-item">
                        <span class="help-key">HELP_DOUBLE_ALT</span>
                        <span class="help-description">HELP_DOUBLE_ALT_DESC</span>
                    </div>
                </div>

                <div class="help-section">
                    <div class="help-item">
                        <span class="help-key">HELP_HOLD_CMD</span>
                        <span class="help-description">HELP_HOLD_CMD_DESC</span>
                    </div>
                    <div class="help-item">
                        <span class="help-key">HELP_CMD_A</span>
                        <span class="help-description">HELP_CMD_A_DESC</span>
                    </div>
                    <div class="help-item">
                        <span class="help-key">HELP_CMD_S</span>
                        <span class="help-description">HELP_CMD_S_DESC</span>
                    </div>
                </div>

                <div class="help-note">
                    <p class="help-note-text">HELP_ELEMENT_TIP1</p>
                </div>

                <div class="help-section">
                    <div class="help-item">
                        <span class="help-key">HELP_HOLD_CMD2</span>
                        <span class="help-description">HELP_HOLD_CMD2_DESC</span>
                    </div>
                    <div class="help-item">
                        <span class="help-key">HELP_CMD_CLICK</span>
                        <span class="help-description">HELP_CMD_CLICK_DESC</span>
                    </div>
                </div>

                <div class="help-note">
                    <p class="help-note-text">HELP_ELEMENT_TIP2</p>
                </div>
            </div>

            <!-- ‰∫§‰∫íÊìç‰Ωú Tab -->
            <div class="help-tab-content" id="help-tab-app">

                <div class="help-section">
                    <div class="help-item">
                        <span class="help-key">HELP_DOUBLE_SHIFT</span>
                        <span class="help-description">HELP_DOUBLE_SHIFT_DESC</span>
                    </div>
                    <div class="help-item">
                        <span class="help-key">HELP_SHIFT_THEN_CTRL</span>
                        <span class="help-description">HELP_SHIFT_THEN_CTRL_DESC</span>
                    </div>
                    <div class="help-item">
                        <span class="help-key">HELP_CTRL_THEN_SHIFT</span>
                        <span class="help-description">HELP_CTRL_THEN_SHIFT_DESC</span>
                    </div>
                    <div class="help-item">
                        <span class="help-key">HELP_ESC</span>
                        <span class="help-description">HELP_ESC_DESC</span>
                    </div>
                </div>
            </div>

        </div>

        <button class="lang-toggle-corner" id="langToggleBtn" title="LANG_TOGGLE_TITLE">
            <span id="langToggleText">EN</span>
        </button>
        <button class="theme-toggle-corner" id="themeToggleBtn" title="THEME_TOGGLE_TITLE">
            <span class="theme-toggle-icon">üåô</span>
        </button>
    </div>
</div>

<script>
    
    // Â§öËØ≠Ë®ÄÊñáÊú¨Êï∞ÊçÆ
    const LangText = {
        // Âü∫Á°ÄÊ†áÁ≠æ
        UNKNOWN: ['Êú™Áü•', 'Unknown'],
        ELEMENT: ['ÂÖÉÁ¥†', 'Element'],
        CENTER: ['ÂúÜÂøÉ', 'Center'],
        RADIUS: ['ÂçäÂæÑ', 'Radius'],
        RANGE: ['ËåÉÂõ¥', 'Range'],
        CENTROID: ['Ë¥®ÂøÉ', 'Centroid'],
        VERTEX: ['È°∂ÁÇπ', 'Vertex'],

        // ÂèÇÊï∞ÂíåÂ±ûÊÄßÊ†áÁ≠æ
        COORDINATE: ['ÂùêÊ†á', 'Coordinate'],
        START_POINT: ['Ëµ∑ÁÇπÂùêÊ†á', 'Start Point'],
        END_POINT: ['ÁªàÁÇπÂùêÊ†á', 'End Point'],
        LENGTH: ['ÈïøÂ∫¶', 'Length'],
        SLOPE: ['ÊñúÁéá', 'Slope'],
        LEFT_BORDER: ['Â∑¶ËæπÁïå', 'Left Border'],
        RIGHT_BORDER: ['Âè≥ËæπÁïå', 'Right Border'],
        TOP_BORDER: ['‰∏äËæπÁïå', 'Top Border'],
        BOTTOM_BORDER: ['‰∏ãËæπÁïå', 'Bottom Border'],
        DIAGONAL: ['ÂØπËßíÈïø', 'Diagonal'],
        CLOSED_SHAPE: ['Â∞ÅÈó≠ÂõæÂΩ¢', 'Closed Shape'],
        VERTEX_COORDS: ['È°∂ÁÇπÂùêÊ†á', 'Vertex Coordinates'],
        POINT_N: ['ÁÇπ', 'Point'],
        VERTEX_COUNT: ['È°∂ÁÇπÊï∞', 'Vertex Count'],
        CENTER_COORD: ['ÂúÜÂøÉÂùêÊ†á', 'Center Coordinate'],
        CIRCUMFERENCE: ['Âë®Èïø', 'Circumference'],
        START_ANGLE: ['Ëµ∑ÂßãËßíÂ∫¶(¬∞)', 'Start Angle(¬∞)'],
        END_ANGLE: ['ÁªìÊùüËßíÂ∫¶(¬∞)', 'End Angle(¬∞)'],
        ARC_LENGTH: ['ÂºßÈïø', 'Arc Length'],
        CONTROL_POINTS: ['ÊéßÂà∂ÁÇπ', 'Control Points'],

        // ËèúÂçïÊ†áÁ≠æ
        MENU_LINE: ['Áõ¥Á∫ø', 'Line'],
        MENU_RECT: ['Áü©ÂΩ¢', 'Rectangle'],
        MENU_CIRCLE: ['ÂúÜÂΩ¢', 'Circle'],
        MENU_ARC: ['ÂºßÁ∫ø', 'Arc'],
        MENU_POLY: ['Â§öËæπÂΩ¢', 'Polygon'],
        MENU_EASE: ['easeÊõ≤Á∫ø', 'Ease Curve'],
        MENU_BEZIER: ['Ë¥ùÂ°ûÂ∞îÊõ≤Á∫ø', 'Bezier Curve'],

        // ÂáΩÊï∞ÂØπËØùÊ°Ü
        FUNC_DRAW: ['ÂáΩÊï∞ÁªòÂà∂', 'Function Plot'],
        FUNC_EXPR: ['Ë°®ËææÂºè', 'Function Expression'],
        FUNC_EXPR_DESC: ['ËØ∑ËæìÂÖ•ÂáΩÊï∞Ë°®ËææÂºèÔºå‰æãÂ¶ÇÔºöy = 2*x + 1, y = x^2, y = sin(x)', 'Enter function expression, e.g.: y = 2*x + 1, y = x^2, y = sin(x)'],
        FUNC_EXPR_PLACEHOLDER: ['2*x + 1', '2*x + 1'],
        DOMAIN: ['ÂÆö‰πâÂüü', 'Domain'],
        DOMAIN_DESC: ['ÁïôÁ©∫Ë°®Á§∫Êó†Á©∑Â§ßËåÉÂõ¥ÔºåÂ¶Ç -‚àû Âà∞ +‚àû', 'Leave empty for infinite range, e.g., -‚àû to +‚àû'],
        X_FROM: ['x ‰ªé', 'x from'],
        X_TO: ['Âà∞', 'to'],
        EMPTY_INFINITY: ['ÁïôÁ©∫Ë°®Á§∫Êó†Á©∑', 'Leave empty for infinity'],
        PREVIEW: ['È¢ÑËßà', 'Preview'],
        DRAW: ['ÁªòÂà∂', 'Plot'],
        
        // Â±ûÊÄßÂØπËØùÊ°Ü
        ELEMENT_ATTR: ['ÂÖÉÁ¥†Â±ûÊÄß', 'Element Attributes'],
        LINE_COLOR: ['Á∫øÊù°È¢úËâ≤', 'Line Color'],
        LINE_COLOR_DESC: ['ËÆæÁΩÆÂÖÉÁ¥†ÁöÑÁ∫øÊù°È¢úËâ≤', 'Set the line color of the element'],
        LINE_WIDTH: ['Á∫øÊù°ÂÆΩÂ∫¶', 'Line Width'],
        LINE_WIDTH_DESC: ['ËÆæÁΩÆÂÖÉÁ¥†ÁöÑÁ∫øÊù°ÂÆΩÂ∫¶', 'Set the line width of the element'],
        WIDTH_UNIT: ['px', 'px'],
        CANCEL: ['ÂèñÊ∂à', 'Cancel'],
        APPLY: ['Â∫îÁî®', 'Apply'],
        
        // Áä∂ÊÄÅÊ†èÊ∂àÊÅØ
        STATUS_HELP: ['ÈïøÊåâ Ctrl+Alt Êü•ÁúãÂ∏ÆÂä©', 'Hold Ctrl+Alt to view help'],
        STATUS_POLYGON: ['Â§öËæπÂΩ¢ÁªòÂà∂‰∏≠...', 'Drawing polygon...'],
        STATUS_ARC_PERP: ['ÂºßÁ∫øÁªòÂà∂‰∏≠... Ôºà‰∏≠ÂûÇÁ∫øÈîÅÂÆöÊ®°ÂºèÔºâ', 'Drawing arc... (Perpendicular lock mode)'],
        STATUS_ARC_NORMAL: ['ÂºßÁ∫øÁªòÂà∂‰∏≠...', 'Drawing arc...'],
        STATUS_BEZIER: ['ÁªòÂà∂‰∏≠...', 'Drawing...'],
        POINTS: ['‰∏™ÁÇπ', 'points'],
        CLICK_ADD: ['ÁÇπÂáªÊ∑ªÂä†ÁÇπ', 'Click to add point'],
        RELEASE_COMPLETE: ['ÊùæÂºÄ Alt ÈîÆÂÆåÊàê', 'Release Alt to finish'],
        PERP_LOCK_MODE: ['‰∏≠ÂûÇÁ∫øÈîÅÂÆöÊ®°Âºè', 'Perpendicular lock mode'],
        MOVE_ON_NORMAL: ['Âú®Ê≥ïÁ∫ø‰∏äÁßªÂä®Èº†Ê†á', 'Move mouse on normal'],
        CLICK_COMPLETE: ['ÁÇπÂáªÂÆåÊàêÁªòÂà∂', 'Click to complete'],
        MOVE_ADJUST: ['ÁßªÂä®Èº†Ê†áË∞ÉÊï¥ÂúÜÂøÉ‰ΩçÁΩÆ', 'Move mouse to adjust center'],
        PRESS_ALT_PERP: ['ÊàñÊåâ Shift ÈîÆËøõÂÖ•‰∏≠ÂûÇÁ∫øÈîÅÂÆöÊ®°Âºè', 'or press Shift for perpendicular lock mode'],
        DRAWING: ['ÁªòÂà∂‰∏≠...', 'Drawing...'],
        PRESS_CMD_SWITCH_FUNC: ['Alt ÈîÆÂàáÊç¢ËΩ¨Êç¢ÂáΩÊï∞', 'Alt to switch function'],
        PRESS_ALT_SWITCH_PROC: ['Alt ÈîÆÂàáÊç¢ËøáÁ®ãÁ±ªÂûã', 'Alt to switch process type'],
        CLICK_CONFIRM: ['Èº†Ê†áÁÇπÂáªÁ°ÆËÆ§', 'Click to confirm'],
        CLICK_NEXT_CONTROL: ['Èº†Ê†áÁÇπÂáªÂàáÊç¢Âà∞‰∏ã‰∏Ä‰∏™ÊéßÂà∂ÁÇπ', 'Click to next control point'],
        PRESS_CMD_SWITCH_ORDER: ['Alt ÈîÆÂàáÊç¢Èò∂Êï∞', 'Alt to switch order'],
        
        // Ë∑üË∏™ÁÇπ‰ø°ÊÅØ
        TANGENT_SLOPE: ['ÂàáÁ∫øÊñúÁéá', 'Tangent slope'],
        NORMAL_SLOPE: ['Ê≥ïÁ∫øÊñúÁéá', 'Normal slope'],
        NON_DIFFERENTIABLE: ['‰∏çÂèØÂØºÁÇπ', 'Non-differentiable point'],
        INVALID_POINT: ['ÁÇπÊó†Êïà', 'Invalid point'],

        // ÂÖÉÁ¥†Èù¢Êùø
        HIDE: ['ÈöêËóè', 'Hide'],
        SHOW_BTN: ['ÊòæÁ§∫', 'Show'],
        TRANSFORM: ['ÂèòÊç¢', 'Transform'],
        ELEMENT_ATTR_SHORT: ['ÂÖÉÁ¥†Â±ûÊÄß', 'Attributes'],
        DELETE: ['Âà†Èô§ÂÖÉÁ¥†', 'Delete'],
        NO_FEATURE_DATA: ['ËØ•ÂÖÉÁ¥†Êó†ÁâπÂæÅÁÇπÊï∞ÊçÆ„ÄÇ', 'No feature point data for this element.'],
        NO_VALID_FEATURES: ['Êó†ÊúâÊïàÁâπÂæÅÁÇπ„ÄÇ', 'No valid feature points.'],
        
        // ÁâπÊÄßÈù¢ÊùøÁõ∏ÂÖ≥
        INFO: ['‰ø°ÊÅØ', 'Information'],
        PROPS: ['ÁâπÊÄß', 'Props'],
        FLIP: ['ÁøªËΩ¨', 'Flip'],
        SHEAR: ['Ââ™Âàá', 'Shear'],
        ROTATION: ['ÊóãËΩ¨', 'Rotate'],
        SCALE: ['Áº©Êîæ', 'Scale'],
        TRANSLATION: ['Âπ≥Áßª', 'Move'],
        PARAMETERS: ['ÂèÇÊï∞ (Parameters)', 'Parameters'],
        PROPERTIES: ['Â±ûÊÄß (Properties)', 'Properties'],
        FEATURE_POINTS: ['ÁâπÂæÅÁÇπ (Feature Points)', 'Feature Points'],
        SHOW: ['ÊòæÁ§∫', 'Show'],
        AREA: ['ÁßØ', 'Area'],
        PERIMETER: ['Âë®', 'Perimeter'],
        
        // ÂèòÊç¢Èù¢ÊùøÁõ∏ÂÖ≥
        OBSERVE_X: ['ËßÇÊµãÁÇπ X ÂùêÊ†á', 'Observe X Coordinate'],
        OBSERVE_Y: ['ËßÇÊµãÁÇπ Y ÂùêÊ†á', 'Observe Y Coordinate'],
        OBSERVE_DIR: ['ËßÇÊµãÊñπÂêë (Â∫¶)', 'Observation Direction (¬∞)'],
        LOCAL_SYMMETRY: ['Êª°Ë∂≥Â±ÄÂüüÂØπÁß∞ÊÄß', 'Local Symmetry Constraint'],
        LOCAL_SYMMETRY_DESC: ['ÂãæÈÄâÂêéÊãñÂä®ËßÇÊµãÁÇπÊó∂Â∞ÜÈôêÂà∂Âú®Âá†‰ΩïÂÜÖÈÉ®', 'When checked, dragging the observation point will be constrained within the geometry'],
        TOWARD_CENTROID: ['ÊúùÂêëË¥®ÂøÉ', 'Toward Centroid'],
        AUTO: ['Ëá™Âä®', 'Auto'],
        FORWARD_FLIP: ['ÊúùÂêëÁøªËΩ¨', 'Forward Flip'],
        SIDE_FLIP: ['ÂùêÂêëÁøªËΩ¨', 'Side Flip'],
        FORWARD_SHEAR: ['ÊúùÂêëÂâ™Âàá', 'Forward Shear'],
        SIDE_SHEAR: ['ÂùêÂêëÂâ™Âàá', 'Side Shear'],
        ROTATION_ANGLE: ['ÊóãËΩ¨ËßíÂ∫¶ (Â∫¶)', 'Rotation Angle (¬∞)'],
        MATRIX_FORMULA: ['Áü©ÈòµÂÖ¨Âºè', 'Matrix Formula'],
        ROTATION_MATRIX: ['ÊóãËΩ¨Áü©Èòµ', 'Rotation Matrix'],
        SCALE_MATRIX: ['Áº©ÊîæÁü©Èòµ', 'Scale Matrix'],
        X_DISPLACEMENT: ['XËΩ¥‰ΩçÁßª', 'X Displacement'],
        Y_DISPLACEMENT: ['YËΩ¥‰ΩçÁßª', 'Y Displacement'],
        RESET: ['ÈáçÁΩÆ', 'Reset'],
        OBSERVE_DIR_LS_DESC: ['ËßÇÊµãÊñπÂêëÈôêÂÆö‰∏∫ËæÖÂä©Á∫ø‰∏éÂÖÉÁ¥†Áõ∏‰∫§ÁöÑËßíÂ∫¶ËåÉÂõ¥', 'Observation direction is limited to the angle range where the auxiliary line intersects the element'],
        NOT_APPLICABLE: ['‰∏çÈÄÇÁî®', 'N/A'],
        LINEAR_DISTANCE: ['Áõ¥Á∫øË∑ùÁ¶ª', 'Linear Distance'],
        CURVE_TYPE: ['Êõ≤Á∫øÁ±ªÂûã', 'Curve Type'],
        BEZIER_MIN_POINTS: ['Ë¥ùÂ°ûÂ∞îÊõ≤Á∫øËá≥Â∞ëÈúÄË¶ÅËµ∑ÁÇπÂíåÁªàÁÇπ„ÄÇ', 'Bezier curve requires at least a start and end point.'],
        FUNCTION_EXPRESSION: ['Ë°®ËææÂºè', 'Expression'],
        DOMAIN_RANGE: ['ÂÆö‰πâÂüü', 'Domain'],
        SAMPLE_POINTS: ['ÈááÊ†∑ÁÇπÊï∞', 'Sample Points'],

        // Êñá‰ª∂‰∏ä‰º†
        UPLOAD_TITLE: ['Âä†ËΩΩÂÖÉÁ¥†Êï∞ÊçÆ', 'Load Elements Data'],
        UPLOAD_DROP_TEXT: ['ÊãñÊãΩ JSON Êñá‰ª∂Âà∞ËøôÈáå', 'Drag & Drop JSON File Here'],
        UPLOAD_DROP_SUBTEXT: ['ÊàñÁÇπÂáª‰∏ãÊñπÊåâÈíÆÈÄâÊã©Êñá‰ª∂', 'Or click the button below to browse'],
        UPLOAD_BROWSE_BTN: ['ÊµèËßàÊñá‰ª∂', 'Browse Files'],
        UPLOAD_HINT: ['Êåâ ESC ÈîÆÂèñÊ∂à', 'Press ESC to cancel'],

        // Â∏ÆÂä©ÂØπËØùÊ°Ü
        HELP_TITLE: ['Â∏ÆÂä©', 'Help'],
        HELP_TAB_BASIC: ['Âü∫Á°Ä', 'Basic'],
        HELP_TAB_COORDINATE: ['ÂùêÊ†áÁ≥ª', 'Coordinate'],
        HELP_TAB_ELEMENT: ['ÂÖÉÁ¥†', 'Element'],
        HELP_TAB_APP: ['‰∫§‰∫í', 'App'],

        // Â∏ÆÂä© - Âü∫Á°ÄÊìç‰Ωú
        HELP_LEFT_DRAG: ['Èº†Ê†áÂ∑¶ÈîÆÊãñÊãΩ', 'Left Mouse Drag'],
        HELP_LEFT_DRAG_DESC: ['ÁªòÂà∂ÂÖÉÁ¥†', 'Draw element'],
        HELP_LEFT_DOUBLE_CLICK: ['Èº†Ê†áÂ∑¶ÈîÆÂèåÂáª', 'Left Mouse Double Click'],
        HELP_LEFT_DOUBLE_CLICK_DESC: ['ÁªòÂà∂ÁÇπ', 'Draw point'],
        HELP_CMD_LEFT_CLICK: ['Alt + Èº†Ê†áÂ∑¶ÈîÆÁÇπÂáª', 'Alt + Left Mouse Click'],
        HELP_CMD_LEFT_CLICK_DESC: ['ÁªòÂà∂Â§öËæπÂΩ¢', 'Draw polygon'],
        HELP_ALT_KEY: ['Shift + ', 'Shift + '],
        HELP_ALT_KEY_DESC: ['ÁΩëÊ†ºÂØπÈΩêÊ®°ÂºèÔºàÂùêÊ†áËá™Âä®ÂØπÈΩêÂà∞Êï¥Êï∞Ôºâ', 'Grid snap mode (auto-align to integers)'],
        HELP_BASIC_TIP1: ['üí° ÊèêÁ§∫1ÔºöÈïøÊåâ Ctrl + Alt ÊòæÁ§∫Ê≠§Â∏ÆÂä©„ÄÇÊä¨Ëµ∑ Ctrl ÂÖ≥Èó≠Â∏ÆÂä©„ÄÇ', 'üí° Tip 1: Long press Ctrl + Alt to show this help. Release Ctrl to close.'],
        HELP_BASIC_TIP2: ['üí° ÊèêÁ§∫2ÔºöÊåâ‰Ωè Ctrl ÁöÑÂêåÊó∂ÔºåÁÇπÂáª Alt Êàñ ‚Üê ‚Üí ÊñπÂêëÈîÆÂàáÊç¢‰∏çÂêåÂ∏ÆÂä©ÂàÜÁ±ª„ÄÇ', 'üí° Tip 2: While holding Ctrl, press Alt or ‚Üê ‚Üí arrow keys to switch help categories.'],
        
        // Â∏ÆÂä© - ÂùêÊ†áÁ≥ªÊìç‰Ωú
        HELP_Z_LEFT_DRAG: ['Z + Èº†Ê†áÂ∑¶ÈîÆÊãñÊãΩ', 'Z + Left Mouse Drag'],
        HELP_Z_LEFT_DRAG_DESC: ['Âπ≥ÁßªÂùêÊ†áÁ≥ª', 'Pan coordinate system'],
        HELP_WHEEL: ['Èº†Ê†áÊªöËΩÆ', 'Mouse Wheel'],
        HELP_WHEEL_DESC: ['Áº©ÊîæÂùêÊ†áÁ≥ª', 'Zoom coordinate system'],
        HELP_DOUBLE_Z: ['ÂèåÂáª Z', 'Double Click Z'],
        HELP_DOUBLE_Z_DESC: ['ÂàáÊç¢ÂùêÊ†áÁ≥ªÊ®°ÂºèÔºàÂéüÁÇπÂ∑¶‰∏ã ‚Üî ÂéüÁÇπÂ±Ö‰∏≠Ôºâ', 'Toggle coordinate mode (origin bottom-left ‚Üî center)'],
        HELP_COORDINATE_TIP: ['üí° ÊèêÁ§∫ÔºöÁº©ÊîæÂùêÊ†áÁ≥ªÁöÑËøáÁ®ã‰∏≠Ôºå‰ºö‰ª•Èº†Ê†áÊåáÂêëÁöÑ‰ΩçÁΩÆ‰∏∫‰∏≠ÂøÉËøõË°åÁº©Êîæ„ÄÇ', 'üí° Tip: When zooming, the coordinate system will scale around the mouse position.'],
        
        // Â∏ÆÂä© - ÂÖÉÁ¥†Êìç‰Ωú
        HELP_CTRL_LEFT_CLICK: ['Ctrl + Èº†Ê†áÂ∑¶ÈîÆÁÇπÂáª', 'Ctrl + Left Mouse Click'],
        HELP_CTRL_LEFT_CLICK_DESC: ['ÈÄâÊã©ÂÖÉÁ¥†', 'Select element'],
        HELP_CTRL_LEFT_DOUBLE_CLICK: ['Ctrl + Èº†Ê†áÂ∑¶ÈîÆÂèåÂáª', 'Ctrl + Left Mouse Double Click'],
        HELP_CTRL_LEFT_DOUBLE_CLICK_DESC: ['ËΩÆËØ¢ÈÄâÊã©ÈáçÂè†ÂÖÉÁ¥†', 'Cycle through overlapping elements'],
        HELP_CTRL_LEFT_DRAG: ['Ctrl + Èº†Ê†áÂ∑¶ÈîÆÊãñÊãΩ', 'Ctrl + Left Mouse Drag'],
        HELP_CTRL_LEFT_DRAG_DESC: ['ÁßªÂä®ÂÖÉÁ¥†', 'Move element'],
        HELP_HOLD_CMD: ['Êåâ‰Ωè Alt', 'Hold Alt'],
        HELP_HOLD_CMD_DESC: ['ÊòæÁ§∫Ë∑üË∏™ÁÇπ', 'Show tracking point'],
        HELP_CMD_A: ['Êåâ‰Ωè Alt + ÁÇπÂáª A', 'Hold Alt + Click A'],
        HELP_CMD_A_DESC: ['ÊòæÁ§∫/ÈöêËóèÂàáÁ∫ø', 'Show/hide tangent'],
        HELP_CMD_S: ['Êåâ‰Ωè Alt + ÁÇπÂáª S', 'Hold Alt + Click S'],
        HELP_CMD_S_DESC: ['ÊòæÁ§∫/ÈöêËóèÊ≥ïÁ∫ø', 'Show/hide normal'],
        HELP_ELEMENT_TIP1: ['üí° ÊèêÁ§∫Ôºö‰ª•‰∏äÂè™ÂØπÈÄâÊã©ÁöÑÂÖÉÁ¥†ÊúâÊïà„ÄÇ', 'üí° Tip: The above only works for selected elements.'],
        HELP_HOLD_CMD2: ['Êåâ‰Ωè Alt', 'Hold Alt'],
        HELP_HOLD_CMD2_DESC: ['ÊòæÁ§∫Ë∑üË∏™ÁÇπËßÜÁ∫ø', 'Show tracking point sight line'],
        HELP_CMD_CLICK: ['Êåâ‰Ωè Alt + Èº†Ê†áÁÇπÂáª', 'Hold Alt + Mouse Click'],
        HELP_CMD_CLICK_DESC: ['ÈÄâÊã©ËÆæÁΩÆË∑üË∏™ÁÇπËßÜÁ∫øÊñπÂêëËßí', 'Set tracking point sight line direction'],
        HELP_CMD_DOUBLE_CLICK_ITEM: ['Ctrl + ÂèåÂáªÂÖÉÁ¥†ÂàóË°®È°π', 'Ctrl + Double Click Element Item'],
        HELP_CMD_DOUBLE_CLICK_ITEM_DESC: ['ÂÆö‰ΩçÂÖÉÁ¥†Âà∞Â±èÂπï‰∏≠ÂøÉ', 'Center element on screen'],
        HELP_ELEMENT_TIP2: ['üí° ÊèêÁ§∫Ôºö‰ª•‰∏äÂè™ÂØπÂÖÉÁ¥†ÂèòÊç¢ËÆæÁΩÆÊúâÊïà„ÄÇ', 'üí° Tip: The above only works for element transform settings.'],
        
        // Â∏ÆÂä© - ‰∫§‰∫íÊìç‰Ωú
        HELP_DOUBLE_ALT: ['ÂèåÂáª Alt', 'Double Click Alt'],
        HELP_DOUBLE_ALT_DESC: ['ËΩÆËØ¢ÈÄâÊã©ÂÖÉÁ¥†', 'Cycle through elements'],
        HELP_DOUBLE_SHIFT: ['ÂèåÂáª Shift', 'Double Click Shift'],
        HELP_DOUBLE_SHIFT_DESC: ['ÊòæÁ§∫/ÈöêËóèÂÖÉÁ¥†ÂàóË°®Èù¢Êùø', 'Show/hide element list panel'],
        HELP_SHIFT_THEN_CTRL: ['ÂÖàÊåâ Shift ÂÜçÊåâ Ctrl', 'Press Shift then Ctrl'],
        HELP_SHIFT_THEN_CTRL_DESC: ['‰øùÂ≠òÂÖÉÁ¥†‰∏∫ JSON Êñá‰ª∂', 'Save elements as JSON file'],
        HELP_CTRL_THEN_SHIFT: ['ÂÖàÊåâ Ctrl ÂÜçÊåâ Shift', 'Press Ctrl then Shift'],
        HELP_CTRL_THEN_SHIFT_DESC: ['Âä†ËΩΩ JSON Êñá‰ª∂', 'Load JSON file'],
        HELP_ESC: ['ESC', 'ESC'],
        HELP_ESC_DESC: ['ÈÄÄÂá∫ÂΩìÂâçÊ®°ÂºèÔºàÂèñÊ∂àÈÄâÊã©„ÄÅÂÅúÊ≠¢ÁªòÂà∂„ÄÅÂÖ≥Èó≠Èù¢ÊùøÁ≠âÔºâ', 'Exit current mode (deselect, stop drawing, close panel, etc.)'],
        
        // ËØ≠Ë®ÄÊ†áÁ≠æ
        LANG_TAG: ['‰∏≠', 'EN'],

        // ‰∏ªÈ¢òÂàáÊç¢
        THEME_TO_LIGHT: ['ÂàáÊç¢Âà∞ÊµÖËâ≤‰∏ªÈ¢ò', 'Switch to Light Theme'],
        THEME_TO_DARK: ['ÂàáÊç¢Âà∞Ê∑±Ëâ≤‰∏ªÈ¢ò', 'Switch to Dark Theme'],
    };

    //-------------

    function HTMLDrawMenuLabels(lang) {
        const drawMenu = document.getElementById('drawMenu');
        if (!drawMenu) return;
        drawMenu.querySelectorAll('.menu-item').forEach(item => {
            const type = parseInt(item.getAttribute('data-type'));
            const menuText = item.querySelector('.menu-text');
            if (!menuText) return;
            switch(type) {
                case ElementTypes.SEG: menuText.textContent = LangText.MENU_LINE[lang]; break;
                case ElementTypes.RECTANGLE: menuText.textContent = LangText.MENU_RECT[lang]; break;
                case ElementTypes.CIRCLE: menuText.textContent = LangText.MENU_CIRCLE[lang]; break;
                case ElementTypes.ARC: menuText.textContent = LangText.MENU_ARC[lang]; break;
                case ElementTypes.EASE: menuText.textContent = LangText.MENU_EASE[lang]; break;
                case ElementTypes.BEZIER: menuText.textContent = LangText.MENU_BEZIER[lang]; break;
            }
        });
    }
    function HTMLFuncButtonLabels(lang) {
        const btn = document.getElementById('functionButton');
        if (!btn) return;
        
        // ËÆæÁΩÆÊåâÈíÆÊ†áÈ¢òÂ±ûÊÄß
        btn.setAttribute('title', LangText.FUNC_DRAW[lang]);
    }
    function HTMLFuncOverlayLabels(lang) {
        const overlay = document.getElementById('functionOverlay');
        if (!overlay) return;
        
        // ËÆæÁΩÆÂØπËØùÊ°ÜÊ†áÈ¢ò
        const title = overlay.querySelector('.function-title');
        if (title) {
            title.textContent = LangText.FUNC_DRAW[lang];
        }
        
        // ËÆæÁΩÆÂáΩÊï∞ÁªÑÊ†áÁ≠æÂíåÊèèËø∞
        const functionLabels = overlay.querySelectorAll('.function-label');
        const functionDescs = overlay.querySelectorAll('.function-description');
        
        if (functionLabels.length >= 2) {
            functionLabels[0].textContent = LangText.FUNC_EXPR[lang];
            functionLabels[1].textContent = LangText.DOMAIN[lang];
        }
        
        if (functionDescs.length >= 2) {
            functionDescs[0].textContent = LangText.FUNC_EXPR_DESC[lang];
            functionDescs[1].textContent = LangText.DOMAIN_DESC[lang];
        }
        
        // ËÆæÁΩÆÂáΩÊï∞ËæìÂÖ•Ê°ÜÂç†‰ΩçÁ¨¶
        const funcInput = overlay.querySelector('#functionInput');
        if (funcInput) {
            funcInput.setAttribute('placeholder', LangText.FUNC_EXPR_PLACEHOLDER[lang]);
        }
        
        // ËÆæÁΩÆËåÉÂõ¥Ê†áÁ≠æ
        const rangeLabels = overlay.querySelectorAll('.range-label');
        if (rangeLabels.length >= 2) {
            rangeLabels[0].textContent = LangText.X_FROM[lang];
            rangeLabels[1].textContent = LangText.X_TO[lang];
        }
        
        // ËÆæÁΩÆËåÉÂõ¥ËæìÂÖ•Ê°ÜÁöÑÂç†‰ΩçÁ¨¶ÂíåÊ†áÈ¢ò
        const xMinInput = overlay.querySelector('#xMinInput');
        const xMaxInput = overlay.querySelector('#xMaxInput');
        if (xMinInput) {
            xMinInput.setAttribute('title', LangText.EMPTY_INFINITY[lang]);
        }
        if (xMaxInput) {
            xMaxInput.setAttribute('title', LangText.EMPTY_INFINITY[lang]);
        }
        
        // ËÆæÁΩÆÊåâÈíÆ
        const cancelBtn = overlay.querySelector('.function-btn.cancel');
        const previewBtn = overlay.querySelector('.function-btn.preview');
        const applyBtn = overlay.querySelector('.function-btn.apply');
        
        if (cancelBtn) cancelBtn.textContent = LangText.CANCEL[lang];
        if (previewBtn) previewBtn.textContent = LangText.PREVIEW[lang];
        if (applyBtn) applyBtn.textContent = LangText.DRAW[lang];
    }
    function HTMLElementPanelLabels(lang) {
        const panel = document.getElementById('elementsPanel');
        if (!panel) return;
        
        // ËÆæÁΩÆÈù¢ÊùøÊ†áÈ¢ò - ÈÄâÊã©Â§ñÂ±Ç span ÂÜÖÁöÑÁ¨¨‰∏Ä‰∏™ span
        const headerSpan = panel.querySelector('.panel-header > span > span:first-child');
        if (headerSpan) {
            headerSpan.textContent = LangText.ELEMENT[lang];
        }
    }
    function HTMLAttributeLabels(lang) {
        const overlay = document.getElementById('attributesOverlay');
        if (!overlay) return;
        
        // ËÆæÁΩÆÂØπËØùÊ°ÜÊ†áÈ¢ò
        const title = overlay.querySelector('.settings-title');
        if (title) {
            title.textContent = LangText.ELEMENT_ATTR[lang];
        }
        
        // ËÆæÁΩÆËÆæÁΩÆÁªÑÊ†áÁ≠æÂíåÊèèËø∞
        const settingLabels = overlay.querySelectorAll('.setting-label');
        const settingDescs = overlay.querySelectorAll('.setting-description');
        
        if (settingLabels.length >= 2) {
            settingLabels[0].textContent = LangText.LINE_COLOR[lang];
            settingLabels[1].textContent = LangText.LINE_WIDTH[lang];
        }
        
        if (settingDescs.length >= 2) {
            settingDescs[0].textContent = LangText.LINE_COLOR_DESC[lang];
            settingDescs[1].textContent = LangText.LINE_WIDTH_DESC[lang];
        }
        
        // ËÆæÁΩÆÂÆΩÂ∫¶Âçï‰Ωç
        const widthUnitSpan = overlay.querySelector('.width-unit');
        if (widthUnitSpan) {
            widthUnitSpan.textContent = LangText.WIDTH_UNIT[lang];
        }
        
        // ËÆæÁΩÆÊåâÈíÆ
        const cancelBtn = overlay.querySelector('.settings-btn.cancel');
        const applyBtn = overlay.querySelector('.btn-elegant.primary');
        if (cancelBtn) cancelBtn.textContent = LangText.CANCEL[lang];
        if (applyBtn) applyBtn.textContent = LangText.APPLY[lang];
    }
    function HTMLPropertyPanelLabels(lang) {
        const panel = document.getElementById('propertyPanel');
        if (!panel) return;
        
        // ËÆæÁΩÆÈù¢ÊùøÊ†áÈ¢ò
        const headerSpan = panel.querySelector('.panel-header > span');
        if (headerSpan) {
            headerSpan.textContent = LangText.INFO[lang];
        }
        
        // ËÆæÁΩÆÂ±ûÊÄßÊ†áÁ≠æÈ°µ
        const tabs = panel.querySelectorAll('.property-tab');
        if (tabs.length >= 6) {
            tabs[0].textContent = LangText.PROPS[lang];
            tabs[1].textContent = LangText.FLIP[lang];
            tabs[2].textContent = LangText.SHEAR[lang];
            tabs[3].textContent = LangText.ROTATION[lang];
            tabs[4].textContent = LangText.SCALE[lang];
            tabs[5].textContent = LangText.TRANSLATION[lang];
        }
        
        // ËÆæÁΩÆÁâπÊÄßÂàÜÁªÑÊ†áÈ¢ò
        const featureGroupHeaders = panel.querySelectorAll('.feature-group-header');
        if (featureGroupHeaders.length >= 3) {
            featureGroupHeaders[0].textContent = LangText.PARAMETERS[lang];
            featureGroupHeaders[1].textContent = LangText.PROPERTIES[lang];
            featureGroupHeaders[2].textContent = LangText.FEATURE_POINTS[lang];
        }
        
        // ËÆæÁΩÆ Common Intrinsics ‰ø°ÊÅØÁöÑÊ†áÁ≠æ

        const geometricCenterRow = document.getElementById('geometricCenterRow');
        if (geometricCenterRow) {
            const label = geometricCenterRow.querySelector('.feature-label');
            if (label) label.textContent = LangText.CENTROID[lang];
            const checkboxSpan = geometricCenterRow.querySelector('span[data-label="show"]');
            if (checkboxSpan) checkboxSpan.textContent = LangText.SHOW[lang];
        }
        const areaDimensions = document.getElementById('areaDimensions');
        if (areaDimensions) {
            const label = areaDimensions.querySelector('.feature-label-sub');
            if (label) label.textContent = LangText.AREA[lang];
        }
        const boundingCenterRow = document.getElementById('boundingCenterRow');
        if (boundingCenterRow) {
            const label = boundingCenterRow.querySelector('.feature-label');
            if (label) label.textContent = LangText.CENTER[lang];
            const checkboxSpan = boundingCenterRow.querySelector('span[data-label="show"]');
            if (checkboxSpan) checkboxSpan.textContent = LangText.SHOW[lang];
        }        
        const boundingDimensions = document.getElementById('boundingDimensions');
        if (boundingDimensions) {
            const label = boundingDimensions.querySelector('.feature-label-sub');
            if (label) label.textContent = LangText.PERIMETER[lang];
        }
        
        // Ëá™Âä®Ë∞ÉÊï¥Èù¢ÊùøÂÆΩÂ∫¶‰ª•ÈÄÇÈÖçÊ†áÁ≠æÈ°µ
        // --------------------

        // ÂàõÂª∫‰∏¥Êó∂ÊµãÈáèÂÖÉÁ¥†
        const measure = document.createElement('span');
        measure.style.cssText = `
            position: absolute;
            visibility: hidden;
            white-space: nowrap;
            font-size: 10.5px;
            font-weight: 500;
            font-family: inherit;
        `;
        document.body.appendChild(measure);

        // ËÆ°ÁÆóÊâÄÊúâ tab ÊñáÊú¨ÁöÑÂÆûÈôÖÂÆΩÂ∫¶
        let maxWidth = 0, totalWidth = 0;
        tabs.forEach(tab => {
            measure.textContent = tab.textContent;
            const textWidth = measure.offsetWidth;
            maxWidth = Math.max(maxWidth, textWidth);
            // tab ÂÆΩÂ∫¶ = ÊñáÊú¨ÂÆΩÂ∫¶ + padding(Â∑¶Âè≥ÂêÑ4px) + ‰ΩôÈáè(10px‰øùËØÅ‰∏çÊå§Âéã)
            const tabWidth = textWidth + 8 + 10;
            totalWidth += tabWidth;
        });

        // ÁßªÈô§ÊµãÈáèÂÖÉÁ¥†
        document.body.removeChild(measure);

        // ËÆ°ÁÆóÈúÄË¶ÅÁöÑÈù¢ÊùøÂÆΩÂ∫¶
        // tabs ÂÆπÂô®ÁöÑ padding(Â∑¶Âè≥ÂêÑ2px=4px) + Èù¢ÊùøËæπÊ°ÜÂíåÂÜÖËæπË∑ù(40pxÈ¢ùÂ§ñÁ©∫Èó¥Èò≤Ê≠¢Ê∫¢Âá∫)
        const minPanelWidth = totalWidth + 4 + 40;

        // ËÆæÁΩÆÊúÄÂ∞èÂíåÊúÄÂ§ßÂÆΩÂ∫¶ÈôêÂà∂
        const finalWidth = Math.max(310, Math.min(420, minPanelWidth));

        // Â∫îÁî®ÂÆΩÂ∫¶
        panel.style.width = `${finalWidth}px`;
    }
    function HTMLTransformPanelLabels(lang) {
        const panel = document.getElementById('propertyPanel');
        if (!panel) return;
        
        // Êõ¥Êñ∞ÊâÄÊúâÂ∏¶ data-label Â±ûÊÄßÁöÑÂÖÉÁ¥†
        panel.querySelectorAll('[data-label="observe-x"]').forEach(el => el.textContent = LangText.OBSERVE_X[lang]);
        panel.querySelectorAll('[data-label="observe-y"]').forEach(el => el.textContent = LangText.OBSERVE_Y[lang]);
        panel.querySelectorAll('[data-label="observe-dir"]').forEach(el => el.textContent = LangText.OBSERVE_DIR[lang]);
        panel.querySelectorAll('[data-label="local-symmetry"]').forEach(el => el.textContent = LangText.LOCAL_SYMMETRY[lang]);
        panel.querySelectorAll('[data-label="local-symmetry-desc"]').forEach(el => el.textContent = LangText.LOCAL_SYMMETRY_DESC[lang]);
        panel.querySelectorAll('[data-label="observe-dir-ls-desc"]').forEach(el => el.textContent = LangText.OBSERVE_DIR_LS_DESC[lang]);
        panel.querySelectorAll('[data-label="forward-flip"]').forEach(el => el.textContent = LangText.FORWARD_FLIP[lang]);
        panel.querySelectorAll('[data-label="side-flip"]').forEach(el => el.textContent = LangText.SIDE_FLIP[lang]);
        panel.querySelectorAll('[data-label="forward-shear"]').forEach(el => el.textContent = LangText.FORWARD_SHEAR[lang]);
        panel.querySelectorAll('[data-label="side-shear"]').forEach(el => el.textContent = LangText.SIDE_SHEAR[lang]);
        panel.querySelectorAll('[data-label="rotation-angle"]').forEach(el => el.textContent = LangText.ROTATION_ANGLE[lang]);
        panel.querySelectorAll('[data-label="matrix-formula"]').forEach(el => el.textContent = LangText.MATRIX_FORMULA[lang]);
        panel.querySelectorAll('[data-label="rotation-matrix"]').forEach(el => el.textContent = LangText.ROTATION_MATRIX[lang]);
        panel.querySelectorAll('[data-label="scale-matrix"]').forEach(el => el.textContent = LangText.SCALE_MATRIX[lang]);
        panel.querySelectorAll('[data-label="x-displacement"]').forEach(el => el.textContent = LangText.X_DISPLACEMENT[lang]);
        panel.querySelectorAll('[data-label="y-displacement"]').forEach(el => el.textContent = LangText.Y_DISPLACEMENT[lang]);
        
        // Êõ¥Êñ∞ placeholder
        panel.querySelectorAll('[data-placeholder="toward-centroid"]').forEach(el => el.setAttribute('placeholder', LangText.TOWARD_CENTROID[lang]));
        panel.querySelectorAll('[data-placeholder="auto"]').forEach(el => el.setAttribute('placeholder', LangText.AUTO[lang]));
        
        // Êõ¥Êñ∞ÊåâÈíÆ
        const resetBtn = panel.querySelector('.transform-actions .btn-elegant.danger');
        const applyBtn = panel.querySelector('.transform-actions .btn-elegant.primary');
        if (resetBtn) resetBtn.textContent = LangText.RESET[lang];
        if (applyBtn) applyBtn.textContent = LangText.APPLY[lang];
    }
    function HTMLHelpLanguage(lang) {

        // Ê†πÊçÆËØ≠Ë®ÄË∞ÉÊï¥ help-item ÁöÑÂàóÂÆΩ
        const helpItems = document.querySelectorAll('.help-item');
        const columnWidth = lang === 0 ? '200px' : '280px'; // Ëã±ÊñáÈúÄË¶ÅÊõ¥ÂÆΩ
        helpItems.forEach(item => {
            item.style.gridTemplateColumns = `${columnWidth} 1fr`;
        });
        
        // Êõ¥Êñ∞Ê†áÈ¢ò
        const helpTitle = document.querySelector('.help-title');
        if (helpTitle) helpTitle.textContent = LangText.HELP_TITLE[lang];
        
        // Êõ¥Êñ∞ tabs
        const tabs = document.querySelectorAll('.help-tab');
        if (tabs[0]) tabs[0].textContent = LangText.HELP_TAB_BASIC[lang];
        if (tabs[1]) tabs[1].textContent = LangText.HELP_TAB_COORDINATE[lang];
        if (tabs[2]) tabs[2].textContent = LangText.HELP_TAB_ELEMENT[lang];
        if (tabs[3]) tabs[3].textContent = LangText.HELP_TAB_APP[lang];
        
        // Êõ¥Êñ∞Âü∫Á°Ä tab
        const basicContent = document.getElementById('help-tab-basic');
        if (basicContent) {
            const items = basicContent.querySelectorAll('.help-item');
            if (items[0]) {
                items[0].querySelector('.help-key').textContent = LangText.HELP_LEFT_DRAG[lang];
                items[0].querySelector('.help-description').textContent = LangText.HELP_LEFT_DRAG_DESC[lang];
            }
            if (items[1]) {
                items[1].querySelector('.help-key').textContent = LangText.HELP_LEFT_DOUBLE_CLICK[lang];
                items[1].querySelector('.help-description').textContent = LangText.HELP_LEFT_DOUBLE_CLICK_DESC[lang];
            }
            if (items[2]) {
                items[2].querySelector('.help-key').textContent = LangText.HELP_CMD_LEFT_CLICK[lang];
                items[2].querySelector('.help-description').textContent = LangText.HELP_CMD_LEFT_CLICK_DESC[lang];
            }
            if (items[3]) {
                items[3].querySelector('.help-key').textContent = LangText.HELP_ALT_KEY[lang];
                items[3].querySelector('.help-description').textContent = LangText.HELP_ALT_KEY_DESC[lang];
            }
            if (items[4]) {
                items[4].querySelector('.help-key').textContent = LangText.HELP_CTRL_LEFT_CLICK[lang];
                items[4].querySelector('.help-description').textContent = LangText.HELP_CTRL_LEFT_CLICK_DESC[lang];
            }
            if (items[5]) {
                items[5].querySelector('.help-key').textContent = LangText.HELP_CTRL_LEFT_DOUBLE_CLICK[lang];
                items[5].querySelector('.help-description').textContent = LangText.HELP_CTRL_LEFT_DOUBLE_CLICK_DESC[lang];
            }
            if (items[6]) {
                items[6].querySelector('.help-key').textContent = LangText.HELP_CTRL_LEFT_DRAG[lang];
                items[6].querySelector('.help-description').textContent = LangText.HELP_CTRL_LEFT_DRAG_DESC[lang];
            }
            
            const notes = basicContent.querySelectorAll('.help-note-text');
            if (notes[0]) notes[0].textContent = LangText.HELP_BASIC_TIP1[lang];
            if (notes[1]) notes[1].textContent = LangText.HELP_BASIC_TIP2[lang];
        }
        
        // Êõ¥Êñ∞ÂùêÊ†áÁ≥ª tab
        const coordContent = document.getElementById('help-tab-coordinate');
        if (coordContent) {
            const items = coordContent.querySelectorAll('.help-item');
            if (items[0]) {
                items[0].querySelector('.help-key').textContent = LangText.HELP_Z_LEFT_DRAG[lang];
                items[0].querySelector('.help-description').textContent = LangText.HELP_Z_LEFT_DRAG_DESC[lang];
            }
            if (items[1]) {
                items[1].querySelector('.help-key').textContent = LangText.HELP_DOUBLE_Z[lang];
                items[1].querySelector('.help-description').textContent = LangText.HELP_DOUBLE_Z_DESC[lang];
            }
            if (items[2]) {
                items[2].querySelector('.help-key').textContent = LangText.HELP_WHEEL[lang];
                items[2].querySelector('.help-description').textContent = LangText.HELP_WHEEL_DESC[lang];
            }
            if (items[3]) {
                items[3].querySelector('.help-key').textContent = LangText.HELP_CMD_DOUBLE_CLICK_ITEM[lang];
                items[3].querySelector('.help-description').textContent = LangText.HELP_CMD_DOUBLE_CLICK_ITEM_DESC[lang];
            }
            
            const note = coordContent.querySelector('.help-note-text');
            if (note) note.textContent = LangText.HELP_COORDINATE_TIP[lang];
        }
        
        // Êõ¥Êñ∞ÂÖÉÁ¥† tab
        const elementContent = document.getElementById('help-tab-element');
        if (elementContent) {
            const sections = elementContent.querySelectorAll('.help-section');
            if (sections[0]) {
                const items = sections[0].querySelectorAll('.help-item');
                if (items[0]) {
                    items[0].querySelector('.help-key').textContent = LangText.HELP_DOUBLE_ALT[lang];
                    items[0].querySelector('.help-description').textContent = LangText.HELP_DOUBLE_ALT_DESC[lang];
                }
            }
            
            if (sections[1]) {
                const items = sections[1].querySelectorAll('.help-item');
                if (items[0]) {
                    items[0].querySelector('.help-key').textContent = LangText.HELP_HOLD_CMD[lang];
                    items[0].querySelector('.help-description').textContent = LangText.HELP_HOLD_CMD_DESC[lang];
                }
                if (items[1]) {
                    items[1].querySelector('.help-key').textContent = LangText.HELP_CMD_A[lang];
                    items[1].querySelector('.help-description').textContent = LangText.HELP_CMD_A_DESC[lang];
                }
                if (items[2]) {
                    items[2].querySelector('.help-key').textContent = LangText.HELP_CMD_S[lang];
                    items[2].querySelector('.help-description').textContent = LangText.HELP_CMD_S_DESC[lang];
                }
            }
            
            if (sections[2]) {
                const items = sections[2].querySelectorAll('.help-item');
                if (items[0]) {
                    items[0].querySelector('.help-key').textContent = LangText.HELP_HOLD_CMD2[lang];
                    items[0].querySelector('.help-description').textContent = LangText.HELP_HOLD_CMD2_DESC[lang];
                }
                if (items[1]) {
                    items[1].querySelector('.help-key').textContent = LangText.HELP_CMD_CLICK[lang];
                    items[1].querySelector('.help-description').textContent = LangText.HELP_CMD_CLICK_DESC[lang];
                }
            }
            
            const notes = elementContent.querySelectorAll('.help-note-text');
            if (notes[0]) notes[0].textContent = LangText.HELP_ELEMENT_TIP1[lang];
            if (notes[1]) notes[1].textContent = LangText.HELP_ELEMENT_TIP2[lang];
        }
        
        // Êõ¥Êñ∞‰∫§‰∫í tab
        const appContent = document.getElementById('help-tab-app');
        if (appContent) {
            const items = appContent.querySelectorAll('.help-item');
            if (items[0]) {
                items[0].querySelector('.help-key').textContent = LangText.HELP_DOUBLE_SHIFT[lang];
                items[0].querySelector('.help-description').textContent = LangText.HELP_DOUBLE_SHIFT_DESC[lang];
            }
            if (items[1]) {
                items[1].querySelector('.help-key').textContent = LangText.HELP_SHIFT_THEN_CTRL[lang];
                items[1].querySelector('.help-description').textContent = LangText.HELP_SHIFT_THEN_CTRL_DESC[lang];
            }
            if (items[2]) {
                items[2].querySelector('.help-key').textContent = LangText.HELP_CTRL_THEN_SHIFT[lang];
                items[2].querySelector('.help-description').textContent = LangText.HELP_CTRL_THEN_SHIFT_DESC[lang];
            }
            if (items[3]) {
                items[3].querySelector('.help-key').textContent = LangText.HELP_ESC[lang];
                items[3].querySelector('.help-description').textContent = LangText.HELP_ESC_DESC[lang];
            }
        }
    }

    //-------------

    function HTMLThemeMode(darkMode, lang) {

        if (darkMode) {
            document.body.classList.add('dark-mode');
        } else {
            document.body.classList.remove('dark-mode');
        }

        const themeIcon = document.querySelector('.theme-toggle-icon');
        if (themeIcon) {
            themeIcon.textContent = darkMode ? '‚òÄÔ∏è' : 'üåô';
            themeIcon.parentElement.title = darkMode ? LangText.THEME_TO_LIGHT[lang] : LangText.THEME_TO_DARK[lang];
        }
    }

    //-------------

    // ÁîüÊàêÂÖÉÁ¥†ÂàóË°®È°πÁöÑ HTML
    function HTMLElementListItem(element, container, lang) {
        container.innerHTML = `
            <div class="element-info">
                <div class="element-type">${getElementTypeText(element.type)}</div>
                <div class="element-props">${getElementPropsText(element)}</div>
            </div>
            <button class="element-btn transform" onclick="event.stopPropagation(); UIShowPropertyPanel(${element.id})" title="${LangText.TRANSFORM[lang]}">
                ‚áå
            </button>
            <div class="element-actions">
                <button class="element-btn toggle" onclick="event.stopPropagation(); uiToggleElementVisibility(${element.id})">
                    ${element.visible ? LangText.HIDE[lang] : LangText.SHOW_BTN[lang]}
                </button>
            </div>
            <button class="element-btn options" onclick="event.stopPropagation(); UIOpenAttributes(${element.id})" title="${LangText.ELEMENT_ATTR_SHORT[lang]}">
                ‚ãØ
            </button>
            <button class="element-btn delete" onclick="event.stopPropagation(); uiDeleteElement(${element.id})" title="${LangText.DELETE[lang]}">
                √ó
            </button>
        `;
    }

    //-------------

    // ÈÄöÁî®ÁâπÂæÅÁÇπÊòæÁ§∫ÂáΩÊï∞
    function HTMLUnifiedFeaturePoints(element, container, lang) {
        const props = element.props;
        if (!props.ft || !Array.isArray(props.ft)) {
            container.innerHTML = `<p>${LangText.NO_FEATURE_DATA[lang]}</p>`;
            return;
        }

        let html = '';
        props.ft.forEach((point) => {
            if (point && Array.isArray(point) && point.length >= 3) {
                html += `
                    <div class="feature-row">
                        <span class="feature-label">${FeatureTypesText[point[2]][lang]}</span>
                        <span class="feature-point">(${point[0].toFixed(2)}, ${point[1].toFixed(2)})</span>
                    </div>
                `;
            }
        });

        container.innerHTML = html || `<p class="empty-message">${LangText.NO_VALID_FEATURES[lang]}</p>`;
    }

    //-------------

    // ÁÇπÂèÇÊï∞ÔºàÂèØÁºñËæëÔºâ
    function HTMLPointParameters(element, container, lang) {
        const props = element.props;

        container.innerHTML = `
            <div class="feature-row">
                <span class="feature-label">${LangText.COORDINATE[lang]}</span>
                <div class="transform-control-group">
                    <input type="number" class="property-input" value="${props.coords[0].toFixed(2)}"
                           onchange="uiActParametersModified(this, DATA_TYPES.F, 'coords[0]', true)"
                           step="0.1" placeholder="X">
                    <input type="number" class="property-input" value="${props.coords[1].toFixed(2)}"
                           onchange="uiActParametersModified(this, DATA_TYPES.F, 'coords[1]', true)"
                           step="0.1" placeholder="Y">
                </div>
            </div>
        `;
    }

    //-------------

    // Áõ¥Á∫øÂèÇÊï∞ÔºàÂèØÁºñËæëÔºâ
    function HTMLLineParameters(element, container, lang) {
        const props = element.props;

        container.innerHTML = `
            <div class="feature-row">
                <span class="feature-label">${LangText.START_POINT[lang]}</span>
                <div class="transform-control-group">
                    <input type="number" class="property-input" value="${props.ft[0][0].toFixed(2)}"
                           onchange="uiActParametersModified(this, DATA_TYPES.F, 'ft[0][0]', true)"
                           step="0.1" placeholder="X">
                    <input type="number" class="property-input" value="${props.ft[0][1].toFixed(2)}"
                           onchange="uiActParametersModified(this, DATA_TYPES.F, 'ft[0][1]', true)"
                           step="0.1" placeholder="Y">
                </div>
            </div>
            <div class="feature-row">
                <span class="feature-label">${LangText.END_POINT[lang]}</span>
                <div class="transform-control-group">
                    <input type="number" class="property-input" value="${props.ft[1][0].toFixed(2)}"
                           onchange="uiActParametersModified(this, DATA_TYPES.F, 'ft[1][0]', true)"
                           step="0.1" placeholder="X">
                    <input type="number" class="property-input" value="${props.ft[1][1].toFixed(2)}"
                           onchange="uiActParametersModified(this, DATA_TYPES.F, 'ft[1][1]', true)"
                           step="0.1" placeholder="Y">
                </div>
            </div>
        `;

        container.querySelectorAll('input').forEach(input => { input.oninput = input.onchange; })
    }

    // Áõ¥Á∫øÂ±ûÊÄßÔºàÂè™ËØªËÆ°ÁÆóÂÄºÔºâ
    function HTMLLineProperties(element, container, lang) {
        const props = element.props;

        container.innerHTML = `
            <div class="feature-row">
                <span class="feature-label">${LangText.LENGTH[lang]}</span>
                <span class="feature-value">${props.aux.len.toFixed(2)}</span>
            </div>
            <div class="feature-row">
                <span class="feature-label">${LangText.SLOPE[lang]}</span>
                <span class="feature-value">${props.aux.slope.toFixed(1)}¬∞</span>
            </div>
        `;
    }

    //-------------

    // Áü©ÂΩ¢ÂèÇÊï∞ÔºàÂèØÁºñËæëÔºâ
    function HTMLRectangleParameters(element, container, lang) {
        const props = element.props;
        const left = props.box[2];
        const top = props.box[3];
        const right = props.box[4];
        const bottom = props.box[5];

        container.innerHTML = `
            <div class="feature-row">
                <span class="feature-label">${LangText.LEFT_BORDER[lang]}</span>
                <input type="number" class="property-input" value="${left.toFixed(2)}"
                       onchange="uiActParametersModified(this, DATA_TYPES.F, 'box[2]', true)"
                       step="0.1" placeholder="Left">
            </div>
            <div class="feature-row">
                <span class="feature-label">${LangText.RIGHT_BORDER[lang]}</span>
                <input type="number" class="property-input" value="${right.toFixed(2)}"
                       onchange="uiActParametersModified(this, DATA_TYPES.F, 'box[4]', true)"
                       step="0.1" placeholder="Right">
            </div>
            <div class="feature-row">
                <span class="feature-label">${LangText.TOP_BORDER[lang]}</span>
                <input type="number" class="property-input" value="${top.toFixed(2)}"
                       onchange="uiActParametersModified(this, DATA_TYPES.F, 'box[3]', true)"
                       step="0.1" placeholder="Top">
            </div>
            <div class="feature-row">
                <span class="feature-label">${LangText.BOTTOM_BORDER[lang]}</span>
                <input type="number" class="property-input" value="${bottom.toFixed(2)}"
                       onchange="uiActParametersModified(this, DATA_TYPES.F, 'box[5]', true)"
                       step="0.1" placeholder="Bottom">
            </div>
        `;

        container.querySelectorAll('input').forEach(input => { input.oninput = input.onchange; })
    }

    // Áü©ÂΩ¢Â±ûÊÄßÔºàÂè™ËØªËÆ°ÁÆóÂÄºÔºâ
    function HTMLRectangleProperties(element, container, lang) {
        const props = element.props;

        container.innerHTML = `
            <div class="feature-row">
                <span class="feature-label">${LangText.DIAGONAL[lang]}</span>
                <span class="feature-value">${props.aux.d.toFixed(2)}</span>
            </div>
        `;
    }

    //-------------

    // Â§öËæπÂΩ¢ÂèÇÊï∞ÔºàÂèØÁºñËæëÔºâ
    function HTMLPolygonParameters(element, container, lang) {
        let paramsHTML = `
            <div class="feature-row">
                <span class="feature-label">${LangText.CLOSED_SHAPE[lang]}</span>
                <input type="checkbox" class="property-input" ${element.props.closed ? 'checked' : ''}
                       onchange="uiActParametersModified(this, DATA_TYPES.B, 'closed')">
            </div>
        `;

        if (element.props.ft.length > 0) {
            paramsHTML += `<div class="feature-row"><span class="feature-label">${LangText.VERTEX_COORDS[lang]}</span></div>`;
            element.props.ft.forEach((point, index) => {
                paramsHTML += `
                    <div class="feature-row" style="margin-left: 20px;">
                        <span class="feature-label">${LangText.POINT_N[lang]}${index + 1}</span>
                        <div class="transform-control-group">
                            <input type="number" class="property-input" value="${(point[0] || 0).toFixed(2)}"
                                   onchange="uiActParametersModified(this, DATA_TYPES.F, 'points[${index}][0]', true)"
                                   step="0.1" placeholder="x">
                            <input type="number" class="property-input" value="${(point[1] || 0).toFixed(2)}"
                                   onchange="uiActParametersModified(this, DATA_TYPES.F, 'points[${index}][1]', true)"
                                   step="0.1" placeholder="y">
                        </div>
                    </div>
                `;
            });
        }

        container.innerHTML = paramsHTML;
        container.querySelectorAll('input').forEach(input => { input.oninput = input.onchange; })
    }

    // Â§öËæπÂΩ¢Â±ûÊÄßÔºàÂè™ËØªËÆ°ÁÆóÂÄºÔºâ
    function HTMLPolygonProperties(element, container, lang) {
        let points = [];
        if (element.type === ElementTypes.POINT && element.props.coords) {
            points = [element.props.coords];
        } else if (element.type === ElementTypes.CIRCLE && element.props.centroid) {
            points = [element.props.centroid];
        } else if (element.props.ft) {
            points = element.props.ft;
        }
        let perimeter = 0;

        // ËÆ°ÁÆóÂë®Èïø
        for (let i = 0; i < points.length; i++) {
            const j = (i + 1) % points.length;
            const dx = points[j][0] - points[i][0];
            const dy = points[j][1] - points[i][1];
            perimeter += Math.sqrt(dx * dx + dy * dy);
        }

        // ËÆ°ÁÆóÈù¢ÁßØÔºà‰ΩøÁî®ÈûãÂ∏¶ÂÖ¨ÂºèÔºâ
        let area = 0;
        for (let i = 0; i < points.length; i++) {
            const j = (i + 1) % points.length;
            area += points[i][0] * points[j][1] - points[j][0] * points[i][1];
        }
        area = Math.abs(area) / 2;

        container.innerHTML = `
            <div class="feature-row">
                <span class="feature-label">${LangText.VERTEX_COUNT[lang]}</span>
                <span class="feature-value">${points.length}</span>
            </div>
            <div class="feature-row">
                <span class="feature-label">${LangText.PERIMETER[lang]}</span>
                <span class="feature-value">${perimeter.toFixed(2)}</span>
            </div>
            <div class="feature-row">
                <span class="feature-label">${LangText.AREA[lang]}</span>
                <span class="feature-value">${area.toFixed(2)}</span>
            </div>
        `;
    }

    //-------------

    // ÂúÜÂΩ¢ÂèÇÊï∞ÔºàÂèØÁºñËæëÔºâ
    function HTMLCircleParameters(element, container, lang) {
        const cx = element.props.centroid[0];
        const cy = element.props.centroid[1];
        const radius = element.props.radius || 0;

        container.innerHTML = `
            <div class="feature-row">
                <span class="feature-label">${LangText.CENTER_COORD[lang]}</span>
                <div class="transform-control-group">
                    <input type="number" class="property-input" value="${cx.toFixed(2)}"
                           onchange="uiActParametersModified(this, DATA_TYPES.F, 'centroid[0]', true)"
                           step="0.1" placeholder="X">
                    <input type="number" class="property-input" value="${cy.toFixed(2)}"
                           onchange="uiActParametersModified(this, DATA_TYPES.F, 'centroid[1]', true)"
                           step="0.1" placeholder="Y">
                </div>
            </div>
            <div class="feature-row">
                <span class="feature-label">${LangText.RADIUS[lang]}</span>
                <input type="number" class="property-input" value="${radius.toFixed(2)}"
                       onchange="uiActParametersModified(this, DATA_TYPES.F, 'radius')"
                       step="0.1" min="0.1">
            </div>
        `;

        container.querySelectorAll('input').forEach(input => { input.oninput = input.onchange; })
    }

    // ÂúÜÂΩ¢Â±ûÊÄßÔºàÂè™ËØªËÆ°ÁÆóÂÄºÔºâ
    function HTMLCircleProperties(element, container, lang) {
        const props = element.props;
        container.innerHTML = `
            <div class="feature-row">
                <span class="feature-label">${LangText.CIRCUMFERENCE[lang]}</span>
                <span class="feature-value">${props.aux.C.toFixed(2)}</span>
            </div>
        `;
    }

    //-------------

    // ÂºßÂΩ¢ÂèÇÊï∞ÔºàÂèØÁºñËæëÔºâ
    function HTMLArcParameters(element, container, lang) {
        // Â∞ÜÂºßÂ∫¶ËΩ¨Êç¢‰∏∫ËßíÂ∫¶Áî®‰∫éÊòæÁ§∫
        const startAngleDeg = element.props.aux.deg0.toFixed(1);
        const endAngleDeg = element.props.aux.deg1.toFixed(1);

        container.innerHTML = `
            <div class="feature-row">
                <span class="feature-label">${LangText.CENTER_COORD[lang]}</span>
                <div class="transform-control-group">
                    <input type="number" class="property-input" value="${(element.props.ft[0][0] || 0).toFixed(2)}"
                           onchange="uiActParametersModified(this, DATA_TYPES.F, 'ft[0][0]', true)"
                           step="0.1" placeholder="X">
                    <input type="number" class="property-input" value="${(element.props.ft[0][1] || 0).toFixed(2)}"
                           onchange="uiActParametersModified(this, DATA_TYPES.F, 'ft[0][1]', true)"
                           step="0.1" placeholder="Y">
                </div>
            </div>
            <div class="feature-row">
                <span class="feature-label">${LangText.RADIUS[lang]}</span>
                <input type="number" class="property-input" value="${(element.props.radius || 1).toFixed(2)}"
                       onchange="uiActParametersModified(this, DATA_TYPES.F, 'radius')"
                       step="0.1" min="0.1">
            </div>
            <div class="feature-row">
                <span class="feature-label">${LangText.START_ANGLE[lang]}</span>
                <input type="number" class="property-input" value="${startAngleDeg}"
                       onchange="uiActParametersModified(this, DATA_TYPES.F, 'startAngle')"
                       step="1">
            </div>
            <div class="feature-row">
                <span class="feature-label">${LangText.END_ANGLE[lang]}</span>
                <input type="number" class="property-input" value="${endAngleDeg}"
                       onchange="uiActParametersModified(this, DATA_TYPES.F, 'endAngle')"
                       step="1">
            </div>
        `;

        container.querySelectorAll('input').forEach(input => { input.oninput = input.onchange; })
    }

    // ÂºßÂΩ¢Â±ûÊÄßÔºàÂè™ËØªËÆ°ÁÆóÂÄºÔºâ
    function HTMLArcProperties(element, container, lang) {
        const props = element.props;
        container.innerHTML = `
            <div class="feature-row">
                <span class="feature-label">${LangText.ARC_LENGTH[lang]}</span>
                <span class="feature-value">${(props.aux.range * props.radius).toFixed(2)}</span>
            </div>
            <div class="feature-row">
                <span class="feature-label">${LangText.RANGE[lang]}(¬∞)</span>
                <span class="feature-value">${(props.aux.range * R2D).toFixed(1)}</span>
            </div>
        `;
    }

    //-------------

    // EaseÊõ≤Á∫øÂèÇÊï∞ÔºàÂèØÁºñËæëÔºâ
    function HTMLEaseParameters(element, container, lang) {
        container.innerHTML = `
            <div class="feature-row">
                <span class="feature-label">${LangText.START_POINT[lang]}</span>
                <div class="transform-control-group">
                    <input type="number" class="property-input" value="${(element.props.ft[0][0] || 0).toFixed(2)}"
                           onchange="uiActParametersModified(this, DATA_TYPES.F, 'ft[0][0]', true)"
                           step="0.1" placeholder="X">
                    <input type="number" class="property-input" value="${(element.props.ft[0][1] || 0).toFixed(2)}"
                           onchange="uiActParametersModified(this, DATA_TYPES.F, 'ft[0][1]', true)"
                           step="0.1" placeholder="Y">
                </div>
            </div>
            <div class="feature-row">
                <span class="feature-label">${LangText.END_POINT[lang]}</span>
                <div class="transform-control-group">
                    <input type="number" class="property-input" value="${(element.props.ft[1][0] || 0).toFixed(2)}"
                           onchange="uiActParametersModified(this, DATA_TYPES.F, 'ft[1][0]', true)"
                           step="0.1" placeholder="X">
                    <input type="number" class="property-input" value="${(element.props.ft[1][1] || 0).toFixed(2)}"
                           onchange="uiActParametersModified(this, DATA_TYPES.F, 'ft[1][1]', true)"
                           step="0.1" placeholder="Y">
                </div>
            </div>
            <div class="feature-row">
                <span class="feature-label">ËΩ¨Êç¢Á±ªÂûã</span>
                <select class="property-input" onchange="uiActParametersModified(this, DATA_TYPES.S, 'easeGroup')">
                    <option value="sine" ${element.props.type === EASE_FUNC.SINE ? 'selected' : ''}>${EaseTypeTexts[0][lang]}</option>
                    <option value="quad" ${element.props.type === EASE_FUNC.QUAD ? 'selected' : ''}>${EaseTypeTexts[1][lang]}</option>
                    <option value="cubic" ${element.props.type === EASE_FUNC.CUBIC ? 'selected' : ''}>${EaseTypeTexts[2][lang]}</option>
                    <option value="quart" ${element.props.type === EASE_FUNC.QUART ? 'selected' : ''}>${EaseTypeTexts[3][lang]}</option>
                    <option value="quint" ${element.props.type === EASE_FUNC.QUINT ? 'selected' : ''}>${EaseTypeTexts[4][lang]}</option>
                    <option value="expo" ${element.props.type === EASE_FUNC.EXPO ? 'selected' : ''}>${EaseTypeTexts[5][lang]}</option>
                    <option value="circ" ${element.props.type === EASE_FUNC.CIRC ? 'selected' : ''}>${EaseTypeTexts[6][lang]}</option>
                    <option value="back" ${element.props.type === EASE_FUNC.BACK ? 'selected' : ''}>${EaseTypeTexts[7][lang]}</option>
                    <option value="elastic" ${element.props.type === EASE_FUNC.ELASTIC ? 'selected' : ''}>${EaseTypeTexts[8][lang]}</option>
                    <option value="bounce" ${element.props.type === EASE_FUNC.BOUNCE ? 'selected' : ''}>${EaseTypeTexts[9][lang]}</option>
                </select>
            </div>
            <div class="feature-row">
                <span class="feature-label">ËøõÁ®ãÁ±ªÂûã</span>
                <select class="property-input" onchange="uiActParametersModified(this, DATA_TYPES.S, 'easeType')">
                    <option value="in" ${element.props.proc === EASE_PROC.IN ? 'selected' : ''}>${EaseProcTexts[0][lang]}</option>
                    <option value="out" ${element.props.proc === EASE_PROC.OUT ? 'selected' : ''}>${EaseProcTexts[1][lang]}</option>
                    <option value="inOut" ${element.props.proc === EASE_PROC.INOUT ? 'selected' : ''}>${EaseProcTexts[2][lang]}</option>
                </select>
            </div>
        `;

        container.querySelectorAll('input').forEach(input => { input.oninput = input.onchange; })
    }

    // EaseÊõ≤Á∫øÂ±ûÊÄßÔºàÂè™ËØªËÆ°ÁÆóÂÄºÔºâ
    function HTMLEaseProperties(element, container, lang) {
        const props = element.props;
        container.innerHTML = `
            <div class="feature-row">
                <span class="feature-label">${LangText.LINEAR_DISTANCE[lang]}</span>
                <span class="feature-value">${props.aux.dist.toFixed(2)}</span>
            </div>
        `;
    }

    //-------------

    // Ë¥ùÂ°ûÂ∞îÊõ≤Á∫øÂèÇÊï∞ÔºàÂèØÁºñËæëÔºâ
    function HTMLBezierParameters(element, container, lang) {
        const controls = element.props.controls || [];

        if (controls.length < 2) {
            container.innerHTML = `<p>${LangText.BEZIER_MIN_POINTS[lang]}</p>`;
            return;
        }

        let html = '';

        // Ëµ∑ÁÇπÔºàÁ¨¨‰∏Ä‰∏™ÊéßÂà∂ÁÇπÔºâ
        const startPoint = controls[0];
        html += `
            <div class="feature-row">
                <span class="feature-label">${LangText.START_POINT[lang]}</span>
                <div class="transform-control-group">
                    <input type="number" class="property-input" value="${startPoint[0].toFixed(2)}"
                           onchange="uiActParametersModified(this, DATA_TYPES.F, 'controls[0][0]', true)"
                           step="0.1" placeholder="X">
                    <input type="number" class="property-input" value="${startPoint[1].toFixed(2)}"
                           onchange="uiActParametersModified(this, DATA_TYPES.F, 'controls[0][1]', true)"
                           step="0.1" placeholder="Y">
                </div>
            </div>
        `;

        // ‰∏≠Èó¥ÊéßÂà∂ÁÇπ
        for (let i = 1; i < controls.length - 1; i++) {
            const controlPoint = controls[i];
            html += `
                <div class="feature-row">
                    <span class="feature-label">${LangText.CONTROL_POINTS[lang]}${i}</span>
                    <div class="transform-control-group">
                        <input type="number" class="property-input" value="${controlPoint[0].toFixed(2)}"
                               onchange="uiActParametersModified(this, DATA_TYPES.F, 'controls[${i}][0]', true)"
                               step="0.1" placeholder="X">
                        <input type="number" class="property-input" value="${controlPoint[1].toFixed(2)}"
                               onchange="uiActParametersModified(this, DATA_TYPES.F, 'controls[${i}][1]', true)"
                               step="0.1" placeholder="Y">
                    </div>
                </div>
            `;
        }

        // ÁªàÁÇπÔºàÊúÄÂêé‰∏Ä‰∏™ÊéßÂà∂ÁÇπÔºâ
        const endPoint = controls[controls.length - 1];
        const endIndex = controls.length - 1;
        html += `
            <div class="feature-row">
                <span class="feature-label">${LangText.END_POINT[lang]}</span>
                <div class="transform-control-group">
                    <input type="number" class="property-input" value="${endPoint[0].toFixed(2)}"
                           onchange="uiActParametersModified(this, DATA_TYPES.F, 'controls[${endIndex}][0]', true)"
                           step="0.1" placeholder="X">
                    <input type="number" class="property-input" value="${endPoint[1].toFixed(2)}"
                           onchange="uiActParametersModified(this, DATA_TYPES.F, 'controls[${endIndex}][1]', true)"
                           step="0.1" placeholder="Y">
                </div>
            </div>
        `;

        container.innerHTML = html;
        container.querySelectorAll('input').forEach(input => { input.oninput = input.onchange; })
    }

    // Ë¥ùÂ°ûÂ∞îÊõ≤Á∫øÂ±ûÊÄßÔºàÂè™ËØªËÆ°ÁÆóÂÄºÔºâ
    function HTMLBezierProperties(element, container, lang) {
        const props = element.props;
        container.innerHTML = `
            <div class="feature-row">
                <span class="feature-label">${LangText.LINEAR_DISTANCE[lang]}</span>
                <span class="feature-value">${props.aux.dist.toFixed(2)}</span>
            </div>
            <div class="feature-row">
                <span class="feature-label">${LangText.CURVE_TYPE[lang]}</span>
                <span class="feature-value">${getBezierTypeText(props.controls.length)}</span>
            </div>
        `;
    }

    //-------------

    // ÂáΩÊï∞ÂèÇÊï∞ÔºàÂèØÁºñËæëÔºâ
    function HTMLFunctionParameters(element, container, lang) {
        container.innerHTML = `
            <div class="feature-row">
                <span class="feature-label">${LangText.FUNCTION_EXPRESSION[lang]}</span>
                <input type="text" class="property-input" value="${element.props.expr || 'x'}"
                       onchange="uiActParametersModified(this, DATA_TYPES.F, 'expr')"
                       style="flex: 1;">
            </div>
            <div class="feature-row">
                <span class="feature-label">${LangText.DOMAIN_RANGE[lang]}</span>
                <div class="transform-control-group" style="justify-content: flex-start; flex: 1;">
                    <input type="number" class="property-input" value="${element.props.range[0]}"
                           onchange="uiActParametersModified(this, DATA_TYPES.F, 'range[0]')"
                           step="0.1" placeholder="-‚àû">
                    <input type="number" class="property-input" value="${element.props.range[1] || ''}"
                           onchange="uiActParametersModified(this, DATA_TYPES.F, 'range[1]')"
                           step="0.1" placeholder="+‚àû">
                </div>
            </div>
        `;
    }

    // ÂáΩÊï∞ÂõæÂÉèÂ±ûÊÄßÔºàÂè™ËØªËÆ°ÁÆóÂÄºÔºâ
    function HTMLFunctionProperties(element, container, lang) {
        const props = element.props;

        const xMin = props.range[0];
        const xMax = props.range[1];
        const domain = xMax - xMin;

        container.innerHTML = `
            <div class="feature-row">
                <span class="feature-label">${LangText.SAMPLE_POINTS[lang]}</span>
                <span class="feature-value">${element.props.points.length}</span>
            </div>
        `;
    }

    //-------------------------------------------

</script>
<script>
    const canvas = document.getElementById('canvas');

    //--------------
    // ÊµèËßàÂô®ÂÖºÂÆπÊÄßÊ£ÄÊü•
    //--------------

    // ÊµèËßàÂô®ÂíåÂπ≥Âè∞Ê£ÄÊµã
    const BROWSER_INFO = {
        isMac: navigator.platform.toUpperCase().indexOf('MAC') >= 0,
        isWindows: navigator.platform.toUpperCase().indexOf('WIN') >= 0,
        isLinux: navigator.platform.toUpperCase().indexOf('LINUX') >= 0,
        isFirefox: navigator.userAgent.toLowerCase().indexOf('firefox') > -1,
        isChrome: navigator.userAgent.toLowerCase().indexOf('chrome') > -1 && navigator.userAgent.toLowerCase().indexOf('edg') === -1,
        isSafari: navigator.userAgent.toLowerCase().indexOf('safari') > -1 &&
            navigator.userAgent.toLowerCase().indexOf('chrome') === -1,
        isEdge: navigator.userAgent.toLowerCase().indexOf('edg') > -1 || navigator.userAgent.toLowerCase().indexOf('edge') > -1,
        isWebkit: navigator.userAgent.toLowerCase().indexOf('webkit') > -1
    };

    (function checkBrowserCompatibility() {
        const warnings = [];

        // Ê£ÄÊü•CanvasÊîØÊåÅ
        if (!canvas.getContext) {
            warnings.push('ÊÇ®ÁöÑÊµèËßàÂô®‰∏çÊîØÊåÅ HTML5 Canvas, ËØ∑ÂçáÁ∫ßÊµèËßàÂô®');
        }

        // Ê£ÄÊü•ES6ÊîØÊåÅÔºàconst/letÔºâ
        try {
            eval('const testVar = 1;');
        } catch (e) {
            warnings.push('ÊÇ®ÁöÑÊµèËßàÂô®‰∏çÊîØÊåÅÁé∞‰ª£ JavaScript ÁâπÊÄß, Âª∫ËÆÆ‰ΩøÁî® Chrome 51+ Êàñ Edge 14+');
        }

        // Ê£ÄÊü•addEventListenerÊîØÊåÅ
        if (!window.addEventListener) {
            warnings.push('ÊÇ®ÁöÑÊµèËßàÂô®‰∏çÊîØÊåÅÁé∞‰ª£‰∫ã‰ª∂Â§ÑÁêÜ, ËØ∑ÂçáÁ∫ßÊµèËßàÂô®');
        }

        // Â¶ÇÊûúÊúâË≠¶ÂëäÔºåÊòæÁ§∫ÊèêÁ§∫
        if (warnings.length > 0) {
            console.warn('ÊµèËßàÂô®ÂÖºÂÆπÊÄßË≠¶Âëä:', warnings);
            // ÂèØÈÄâÔºöÊòæÁ§∫Áî®Êà∑ÂèãÂ•ΩÁöÑÊèêÁ§∫
            if (warnings.length > 1) {
                alert('Ê£ÄÊµãÂà∞ÊµèËßàÂô®ÂÖºÂÆπÊÄßÈóÆÈ¢òÔºåÂª∫ËÆÆ‰ΩøÁî®ÊúÄÊñ∞Áâà Chrome Êàñ Edge ÊµèËßàÂô®‰ª•Ëé∑ÂæóÊúÄ‰Ω≥‰ΩìÈ™å„ÄÇ');
            }
        }

        return warnings.length === 0;
    })();

    const ctx = canvas.getContext('2d');

    //------------------
    // Canvas È¢ÑÁªòÂà∂ÁºìÂ≠òÁ≥ªÁªü
    //------------------

    // ÂàõÂª∫Á¶ªÂ±èCanvasÁî®‰∫éÁºìÂ≠òÂùêÊ†áÁ≥ªËÉåÊôØ
    let coordinateCache = document.createElement('canvas');
    let coordinateCacheCtx = coordinateCache.getContext('2d');
    let coordinateCacheDirty = true;  // Ê†áËÆ∞ÁºìÂ≠òÊòØÂê¶ÈúÄË¶ÅÊõ¥Êñ∞

    // ÂàùÂßãÂåñÁºìÂ≠òCanvasÂ∞∫ÂØ∏
    function initCoordinateCache() {
        coordinateCache.width = canvas.width;
        coordinateCache.height = canvas.height;
        coordinateCacheDirty = true;
    }

    // Ê†áËÆ∞ÁºìÂ≠òÈúÄË¶ÅÊõ¥Êñ∞ÁöÑÂáΩÊï∞ÔºàÂú®ÂùêÊ†áÁ≥ªÂèòÊç¢„ÄÅÁº©Êîæ„ÄÅ‰∏ªÈ¢òÂàáÊç¢Á≠âÊìç‰ΩúÂêéË∞ÉÁî®Ôºâ
    function invalidateCoordinateCache() {
        coordinateCacheDirty = true;
    }

    //------------------
    // ÊµèËßàÂô®ÂíåÊìç‰ΩúÁ≥ªÁªüÈÄÇÈÖç
    //------------------

    // ÊªöËΩÆÊñπÂêëÈÄÇÈÖç (trueË°®Á§∫deltaY>0Êó∂ÊîæÂ§ßÔºåfalseË°®Á§∫deltaY>0Êó∂Áº©Â∞è)
    const WHEEL_ZOOM_DIRECTION = (() => {
        // macOS ‰∏äÁöÑ Chrome: deltaY > 0 ÊòØÂêë‰∏äÊªöÂä®ÔºàËá™ÁÑ∂ÊªöÂä®ÔºâÔºåÂ∫îËØ•ÊîæÂ§ß
        if (BROWSER_INFO.isMac && BROWSER_INFO.isChrome) {
            return true; // deltaY > 0 Êó∂ÊîæÂ§ß
        }
        // Windows/Linux Chrome ÂíåÊâÄÊúâ Edge: deltaY > 0 ÊòØÂêë‰∏ãÊªöÂä®ÔºåÂ∫îËØ•Áº©Â∞è
        else if (BROWSER_INFO.isChrome || BROWSER_INFO.isEdge) {
            return false; // deltaY > 0 Êó∂Áº©Â∞è
        }
        // macOS Safari: deltaY > 0 ÊòØÂêë‰∏äÊªöÂä®ÔºåÂ∫îËØ•ÊîæÂ§ß
        else if (BROWSER_INFO.isMac && BROWSER_INFO.isSafari) {
            return true; // deltaY > 0 Êó∂ÊîæÂ§ß
        }
        // Firefox: deltaY > 0 ÊòØÂêë‰∏ãÊªöÂä®ÔºåÂ∫îËØ•Áº©Â∞è
        else if (BROWSER_INFO.isFirefox) {
            return false; // deltaY > 0 Êó∂Áº©Â∞è
        }
        // ÈªòËÆ§Ë°å‰∏∫ÔºàÂêë‰∏ãÊªöÂä®Áº©Â∞èÔºâ
        else {
            return false;
        }
    })();

    // click + Â∑¶ÈîÆÁöÑÂπ≥Âè∞ÈÄÇÈÖç
    // > Chrome Âíå Firefox: Âè™Ëß¶Âèë contextmenu
    // > Edge: Âè™Ëß¶Âèë click 
    // > Safari: ‰ºöÂêåÊó∂Ëß¶Âèë click + contextmenu
    const CTRL_CLICK_EVENT = BROWSER_INFO.isEdge ? 'click' : 'contextmenu';

    //------------------
    // Â§öËØ≠Ë®ÄÊîØÊåÅ
    //------------------

    let LANG = 0;                         // ËØ≠Ë®ÄËÆæÁΩÆÔºö0 - ‰∏≠ÊñáÔºå1 - English

    function UILang(lang = LANG) {

        // Êõ¥Êñ∞ËØ≠Ë®ÄÂàáÊç¢ÊåâÈíÆÊñáÂ≠ó
        const langToggleText = document.getElementById('langToggleText');
        if (langToggleText) {
            // ÊòæÁ§∫ÂΩìÂâçËØ≠Ë®ÄÔºö‰∏≠ÊñáÊòæÁ§∫"‰∏≠"ÔºåËã±ÊñáÊòæÁ§∫"EN"
            langToggleText.textContent = LangText.LANG_TAG[lang];
            // ËÆæÁΩÆ data Â±ûÊÄßÂ≠òÂÇ®ÁõÆÊ†áËØ≠Ë®ÄÔºàÁî®‰∫éÊÇ¨ÂÅúÊòæÁ§∫Ôºâ
            langToggleText.parentElement.setAttribute('data-target-lang', LangText.LANG_TAG[lang === 0 ? 1 : 0]);
        }

        HTMLHelpLanguage(lang);
        HTMLDrawMenuLabels(lang);    
        HTMLFuncButtonLabels(lang);
        HTMLFuncOverlayLabels(lang);        
        HTMLElementPanelLabels(lang);        
        HTMLAttributeLabels(lang);
        HTMLPropertyPanelLabels(lang);        
        HTMLTransformPanelLabels(lang);

        if (uiPropertyCurrentTab && uiPropertyCurrentTab === 'props') {
            uiBuildParameters();
            uiBuildIntrinsics();
            uiBuildFeaturePoints();
        }

        draw();
    }

    //------------------
    // ‰∏ªÈ¢òÂàáÊç¢ÊîØÊåÅ
    //------------------

    let THEME = 0;                       // ‰∏ªÈ¢òËÆæÁΩÆÔºö0 - ‰∫ÆËâ≤Ôºå1 - ÊöóËâ≤

    // Á≥ªÁªü crosshair ÂÖâÊ†á‰∏çÊîØÊåÅ‰∏ªÈ¢òÂàáÊç¢ÔºåÊâÄÊúâÊµèËßàÂô®ÈÉΩ‰ΩøÁî®Ëá™ÂÆö‰πâÂÖâÊ†á
    // ÁôΩÂ§©Ê®°ÂºèÔºöÈªëËâ≤ + ÁôΩËâ≤ÊèèËæπÔºà15x15ÔºåÈªëËâ≤Á∫øÁº©Áü≠ 1pxÔºâ
    const CROSSHAIR_LIGHT = "url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\"><line x1=\"7.5\" y1=\"0\" x2=\"7.5\" y2=\"15\" stroke=\"white\" stroke-width=\"3\" stroke-linecap=\"butt\"/><line x1=\"0\" y1=\"7.5\" x2=\"15\" y2=\"7.5\" stroke=\"white\" stroke-width=\"3\" stroke-linecap=\"butt\"/><line x1=\"7.5\" y1=\"1\" x2=\"7.5\" y2=\"14\" stroke=\"black\" stroke-width=\"1\" stroke-linecap=\"butt\"/><line x1=\"1\" y1=\"7.5\" x2=\"14\" y2=\"7.5\" stroke=\"black\" stroke-width=\"1\" stroke-linecap=\"butt\"/></svg>') 7.5 7.5, crosshair";
    
    // ÈªëÂ§úÊ®°ÂºèÔºöÁôΩËâ≤ + ÈªëËâ≤ÊèèËæπÔºà15x15ÔºåÁôΩËâ≤Á∫øÁº©Áü≠ 1pxÔºâ
    const CROSSHAIR_DARK = "url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"15\" height=\"15\"><line x1=\"7.5\" y1=\"0\" x2=\"7.5\" y2=\"15\" stroke=\"black\" stroke-width=\"3\" stroke-linecap=\"butt\"/><line x1=\"0\" y1=\"7.5\" x2=\"15\" y2=\"7.5\" stroke=\"black\" stroke-width=\"3\" stroke-linecap=\"butt\"/><line x1=\"7.5\" y1=\"1\" x2=\"7.5\" y2=\"14\" stroke=\"white\" stroke-width=\"1\" stroke-linecap=\"butt\"/><line x1=\"1\" y1=\"7.5\" x2=\"14\" y2=\"7.5\" stroke=\"white\" stroke-width=\"1\" stroke-linecap=\"butt\"/></svg>') 7.5 7.5, crosshair";
    
    // Ê†πÊçÆ‰∏ªÈ¢òËøîÂõûÂØπÂ∫îÁöÑÂÖâÊ†á
    function getCrosshair() { return THEME ? CROSSHAIR_DARK : CROSSHAIR_LIGHT; }
    
    // grab Âíå grabbing ‰ΩøÁî®Á≥ªÁªüÈªòËÆ§
    function getGrab() { return 'grab'; }
    function getGrabbing() { return 'grabbing'; }

    // ‰∏ªÈ¢òÂàáÊç¢ÂáΩÊï∞
    function UITheme(darkMode) {
        const body = document.body;

        if (darkMode) {
            body.classList.add('dark-mode');
            localStorage.setItem('theme', 'dark');
            THEME = 1;  // Êõ¥Êñ∞‰∏ªÈ¢òÂèòÈáè
        } else {
            body.classList.remove('dark-mode');
            localStorage.setItem('theme', 'light');
            THEME = 0;  // Êõ¥Êñ∞‰∏ªÈ¢òÂèòÈáè
        }

        HTMLThemeMode(darkMode, LANG);

        // Êõ¥Êñ∞ÂÖâÊ†áÊ†∑ÂºèÔºàEdge ÈúÄË¶ÅÊ†πÊçÆ‰∏ªÈ¢òÂàáÊç¢Ôºâ
        if (!selectedElement && !isCtrlPressed && !isShiftPressed && !uiDrawMenuShown) {
            canvas.style.cursor = getCrosshair();
        }

        // Âº∫Âà∂ÈáçÁªòÂ±ûÊÄßÈù¢Êùø‰ª•Ëß£ÂÜ≥ Chrome Ê∏≤ÊüìÁºìÂ≠òÈóÆÈ¢ò
        const propertyContent = document.querySelector('.property-content');
        if (propertyContent) {
            // ÈÄöËøá‰øÆÊîπ display Âº∫Âà∂ÈáçÁªò
            propertyContent.style.display = 'none';
            propertyContent.offsetHeight; // Ëß¶ÂèëÈáçÊéí
            propertyContent.style.display = '';
        }

        // Ê†áËÆ∞ÂùêÊ†áÁ≥ªÁºìÂ≠òÈúÄË¶ÅÊõ¥Êñ∞Ôºà‰∏ªÈ¢òÈ¢úËâ≤ÂèòÂåñÔºâ
        invalidateCoordinateCache();

        // ÈáçÁªòÁîªÂ∏É‰ª•Â∫îÁî®Êñ∞ÁöÑ‰∏ªÈ¢òÈ¢úËâ≤
        draw();
    }

    // ÂàùÂßãÂåñ‰∏ªÈ¢ò
    (function() {

        let darkMode = false;
        const savedTheme = localStorage.getItem('theme');
        if (savedTheme !== null)
            darkMode = savedTheme === 'dark';

        // Â¶ÇÊûúÊ≤°Êúâ‰øùÂ≠òÁöÑ‰∏ªÈ¢òÔºåÊ£ÄÊü•Á≥ªÁªüÂÅèÂ•Ω
        else darkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;

        // ÂàùÂßãÂåñ THEME ÂèòÈáè
        THEME = darkMode ? 1 : 0;

        HTMLThemeMode(darkMode, LANG);
    })();

</script>
<script> // Êï∞Â≠¶ÔºàÂá†‰ΩïÔºâÂ∫ì

    const EPSILON = 1e-9; // Áî®‰∫éÊµÆÁÇπÊï∞ÊØîËæÉÁöÑÂÆπÂ∑Æ
    const EPSILON2 = EPSILON * EPSILON;

    const DEGREE = '\u00B0';         // ¬∞
    const ANGLE = '\u2220';          // ‚à†
    const PRIME = '\u2032';          // ‚Ä≤
    const DOUBLE_PRIME = '\u2033';   // ‚Ä≥

    // ------------- Âá†‰ΩïÂü∫Á°Ä --------------

    const PI2 = Math.PI * 2;        // 2œÄ
    const PI_HALF = Math.PI * 0.5;  // œÄ/2
    const R2D = 180 / Math.PI;      // ËßíÂ∫¶ËΩ¨ÂºßÂ∫¶
    const D2R = Math.PI / 180;      // ÂºßÂ∫¶ËΩ¨ËßíÂ∫¶
    const PHI = 0.6180339887498949; // (Math.sqrt(5) - 1) / 2;

    // ÂêëÈáèÂáèÊ≥ï A - B
    function vSub(a, b) { return [a[0]-b[0],a[1]-b[1]]; }
    function v2Sub(ax, ay, bx, by) { return [ax - bx, ay - by]; }
    // ÂêëÈáèÁÇπÁßØ A ¬∑ B
    function vDot(a,b) {
    /* ÂÖ¨Âºè: A ¬∑ B
     |     = | Ax  Ay | ¬∑ | Bx  By |
     |     =   Ax * Bx + Ay * By
    */
        return a[0]*b[0]+a[1]*b[1];
    }
    function v2Dot(ax, ay, bx, by) {
        return ax * bx + ay * by;
    }
    // ÂêëÈáèÂèâÁßØ (A->B) x (A->P)
    function vCross(a, b, p) {
    /* ÂÖ¨Âºè: AB √ó AP
     |       = | Bx - Ax  By - Ay |
     |         | Px - Ax  Py - Ay |
     |       =   (Bx - Ax) * (Py - Ay) - (Px - Ax) * (By - Ay)
     |       =   (Bx - Ax) * (Py - Ay)
     |         - (By - Ay) * (Px - Ax)
     | Ê≠§Â§ñÔºåËøòÂèØËøõ‰∏ÄÊ≠•Êé®ÂØºÂá∫‰∏Ä‰∏™Âèò‰ΩìÔºåÂç≥
     |       =   (Bx - Ax) * Py - (Bx - Ax) * Ay
     |         - (By - Ay) * Px + (By - Ay) * Ax
     |       = Êú´Â∞æ Ax * Ay È°πÊäµÊ∂àÂêéÂæóÂà∞
     |         (Bx - Ax) * Py - Bx * Ay  - (By - Ay) * Px + By * Ax
     | ÊúâË∂£ÁöÑÊòØÔºåÊ∂àÊéâ‰∏ÄÈ°πÔºå‰ΩÜËÆ°ÁÆóÊÄßËÉΩÂèçËÄå‰ºöÂèòÂ∑ÆÔºåÂç≥‰πãÂâçÁöÑ‰∏ÄÊ¨°‰πòÊ≥ïÂèòÊàê‰∫Ü‰∏§Ê¨°‰πòÊ≥ï
     | ÂÖ≥‰∫é‰∫åÁª¥Âπ≥Èù¢Êù•ËØ¥ÔºåÂèâÁßØÊòØÂà§ÂÆö‰∏âÁÇπÁõ∏ÂØπ‰ΩçÁΩÆÁöÑÊúÄÂø´ÁöÑÊñπÊ≥ïÔºö
     | > ÂèâÁßØ‰∏∫ 0: ‰∏âÁÇπÂÖ±Á∫ø
     | > ÂèâÁßØ‰∏∫Ê≠£: P Âú® AB ÁöÑÂ∑¶‰æß
     | > ÂèâÁßØ‰∏∫Ë¥ü: P Âú® AB ÁöÑÂè≥‰æß
     | Êõ¥Ëøõ‰∏ÄÊ≠•
     | > ÂèâÁßØÂèØ‰ª•Áî®Êù•Âà§Êñ≠‰∏§‰∏™ÁÇπÔºåÊòØÂê¶Âú®ÊüêÊù°Á∫øÊÆµÔºàÂè¶Â§ñ‰∏§‰∏™ÁÇπÔºâÁöÑÂêå‰æßÊàñÂºÇ‰æß
     | > ÂØπ‰∫éËøûÁª≠Â§ö‰∏™ÁÇπÔºåÂèØ‰ª•Áî®Êù•Âà§Êñ≠Ëøô‰∫õÁÇπÊûÑÊàêÁöÑÂ§öËæπÂΩ¢/Êõ≤Á∫øÁöÑÂá∏ÂáπÊÄß
    */
        const ax = a[0], ay = a[1];
        return (b[0] - ax) * (p[1] - ay) - (b[1] - ay) * (p[0] - ax);
    }
    function v2Cross(ax, ay, bx, by, px, py) {
        return (bx - ax) * (py - ay) - (by - ay) * (px - ax);
    }
    function vCrossAux(a, abx, aby, p) {
        return abx * (p[1] - a[1]) - aby * (p[0] - a[0]);
    }
    function v2CrossAux(ax, ay, abx, aby, px, py) {
        return abx * (py - ay) - aby * (px - ax);
    }
    // ÂêëÈáèÊ®°Èïø |V|
    function vLen(v) {
        // Ê≥®ÊÑè ES6 Êâ©Â±ï‰∫Ü hypot ÊñπÊ≥ïÔºåÂç≥ Math.hypot(dx, dy); Ê≠§Â§ñÔºå‰πüÊâ©Â±ï‰∫Ü ** ËøêÁÆóÁ¨¶Ôºådx ** 2 Áõ∏ÂΩì‰∫é dx * dx; v ** 0.5 Áõ∏ÂΩì‰∫é Math.sqrt(v);
        // + ‰ΩÜÊòØÈíàÂØπËØ•Âú∫ÊôØÁöÑÂÆûÈôÖËÆ°ÁÆóÊÄßËÉΩÔºåËøôÈáåÁöÑÁõ¥Êé•ËÆ°ÁÆóÊõ¥Âø´‰∏Ä‰∫õ„ÄÇ‰º∞ËÆ°ÊòØ hypot ÊñπÊ≥ïÈúÄË¶ÅÂ§ÑÁêÜÊõ¥Â§öÁöÑÂèÇÊï∞„ÄÅËæπÁïåÊÉÖÂÜµÔºàÂ¶ÇÊó†Á©∑Â§ß„ÄÅNaNÁ≠âÔºâ
        return Math.sqrt(vDot(v, v));
    }
    function v2Len(x, y) {
        return Math.sqrt(x * x + y * y);
    }
    // ÂêëÈáèÊñπÂêë [-œÄ, œÄ]
    function vDir(v) {
        //  ËøôÈáå atan2 Áî®‰∫éËÆ°ÁÆóÁ¨õÂç°Â∞îÂπ≥Èù¢‰∏äÁÇπ (x, y) ‰∏é x ËΩ¥Ê≠£ÊñπÂêë‰πãÈó¥ÁöÑÂ§πËßíÔºà‰ª•ÂºßÂ∫¶‰∏∫Âçï‰ΩçÔºâÔºåËøîÂõûÂÄºËåÉÂõ¥ [-œÄ, œÄ]
        return Math.atan2(v[1], v[0]);
    }
    function v2Dir(x, y) {
        return Math.atan2(y, x);
    }

    // ËÆ°ÁÆó‰ªé p1 ÊåáÂêë p2 ÁöÑÂêëÈáè
    const diffOfPoints = vSub;
    // ËÆ°ÁÆó‰∏§ÁÇπÈó¥ÁöÑË∑ùÁ¶ª
    function distOfPoints(p1, p2) { return vLen(vSub(p2, p1)); }
    // ËÆ°ÁÆó‰∏§ÁÇπÈó¥ÁöÑÊñπÂêëËßíÔºàp1 ÊåáÂêë p2 ÁöÑÊñπÂêëËßíÔºåÂçï‰ΩçÔºöÂ∫¶ÔºåËåÉÂõ¥Ôºö[-180, 180]Ôºå‰πüÂ∞±ÊòØ p2 - p1Ôºâ
    function dirOfPoints(p1, p2) {
        console.assert(!sameOfPoints(p1, p2));  // ‰∏çÊîØÊåÅÈÄÄÂåñ‰∏∫ÁÇπÁöÑÊÉÖÂÜµ
        return vDir(vSub(p2, p1)) * R2D;
    }
    // Âà§Êñ≠‰∏§ÁÇπÊòØÂê¶ÈáçÂêà
    function sameOfPoints(p1, p2, eps = EPSILON) {
        // ‰πüÂèØ‰ª•Áî®Ë∑ùÁ¶ªÂà§Êñ≠ distOfPoints(p1, p2) < eps
        // + Áõ∏ÊØî‰∫éË∑ùÁ¶ªËÆ°ÁÆóÔºåÈÄªËæëÂà§Êñ≠ÊÄßËÉΩÊõ¥Â•Ω‰∏Ä‰∫õÔºå‰ΩÜÂú®Â§ßÈáèÂπ∂Ë°åËÆ°ÁÆóÊó∂ÔºåÈÄªËæëÂà§Êñ≠ÂèØËÉΩ‰ºöÊúâÂàÜÊîØÈ¢ÑÊµãÂ§±Ë¥•ÁöÑÊÄßËÉΩÊçüÂ§±
        return Math.abs(p1[0] - p2[0]) < eps && Math.abs(p1[1] - p2[1]) < eps;
    }

    // ËÆ°ÁÆó‰∏§ÁÇπÈó¥ÁöÑÊñúÁéá
    // + ËøôÈáåÁõÆÂâçÂè™ÂÖ≥Ê≥® y Áõ∏ÂØπ‰∫é x ÁöÑÊñúÁéáÔºàÊØî‰æãÂÖ≥Á≥ªÔºâÔºåÂç≥ k = Œîy/Œîx„ÄÇËÄå x Áõ∏ÂØπ‰∫é y ÁöÑÊñúÁéáÔºàÊØî‰æãÂÖ≥Á≥ªÔºâÂàôÊòØÂÄíÊï∞ÂÖ≥Á≥ªÔºåÂç≥ k' = Œîx/Œîy = 1/k
    function slopeOfPoints(p1, p2) {
        if (Math.abs(p1[0] - p2[0]) < 1e-10) return null;       // Â¶ÇÊûúÊòØÂûÇÁõ¥Á∫øÔºåÂç≥ÊñúÁéáÊó†Á©∑Â§ß
        return (p2[1] - p1[1]) / (p2[0] - p1[0]);
    }
    // ËÆ°ÁÆóÁî±‰∏§ÁÇπÂÆö‰πâÁöÑÁõ¥Á∫øÁöÑ y Êà™Ë∑ùÔºàÂûÇÁõ¥Á∫øÊ≤°Êúâ y Êà™Ë∑ùÔºåËøîÂõû nullÔºâ
    // + ËøôÈáåÁõÆÂâçÂè™ÂÖ≥Ê≥® y Êà™Ë∑ù„ÄÇ ËÄå x Êà™Ë∑ùÂíå y Êà™Ë∑ùÁöÑÂÖ≥Á≥ªÊòØÔºöx Êà™Ë∑ù = -y Êà™Ë∑ù / k (k != 0)
    function interceptOfPoints(p1, p2) {
        const slope = slopeOfPoints(p1, p2);
        if (slope === null) return null; // ÂûÇÁõ¥Á∫øÊ≤°ÊúâyÊà™Ë∑ù
        return p1[1] - slope * p1[0];
    }

    // ËÆ°ÁÆóÁÇπ p Âà∞ÔºàÁî± p1-p2 ‰∏§ÁÇπÂÆö‰πâÁöÑÔºâÁõ¥Á∫øÁöÑË∑ùÁ¶ª
    function distanceFromPointToLine(p, p1, p2) {
        /* ËÆ°ÁÆóÊñπÊ≥ïÔºöÁÇπ (x0,y0) Âà∞Áõ¥Á∫ø (Ax+By+C=0) ÁöÑË∑ùÁ¶ªÂÖ¨ÂºèÔºö|A*x0 + B*y0 + C| / sqrt(A^2 + B^2)
         | + LaTeX: $$d = \frac{|A x_0 + B y_0 + C|}{\sqrt{A^2 + B^2}}$$
         |   ËøôÈáå Ax+By+C=0 (A != 0 Êàñ B != 0) ÊòØÁõ¥Á∫øÁöÑ‰∏ÄËà¨ÂºèÊñπÁ®ãÔºåÂΩìËØ•ÊñπÁ®ãÁî±‰∏§ÁÇπ (x1,y1) Âíå (x2,y2) ÂÆö‰πâÊó∂ÔºåÂàô
         |   > A = y2 - y1
         |   > B = x1 - x2
         |   > C = x2*y1 - x1*y2
         |   Âõ†‰∏∫ Ax+By+C=0 => y = -A/B * x - C/B (B != 0) ÊâÄ‰ª•ÊñúÁéá k = -A/B (B != 0)ÔºåÊà™Ë∑ù b = -C/B (B != 0)
         |   ÂØπÂ∫îÁöÑÔºå‰∏§ÁÇπ (x1,y1) Âíå (x2,y2) ÂÆö‰πâÁöÑÁõ¥Á∫øÊñúÁéá k = (y2-y1)/(x2-x1) (x2 != x1)ÔºåÊà™Ë∑ù b = y1 - k*x1 (x2 != x1)
         |   ÊâÄ‰ª•Ôºå A = y2 - y1, B = x1 - x2
         |   ËÄå C = -B*b = (y1 - x1 * (y2-y1)/(x2-x1)) * (x2-x1) = y1*(x2-x1) - x1*(y2-y1) = x2*y1 - x1*y2
         | + ÂÖ≥‰∫é (x0,y0) Âà∞Áõ¥Á∫ø (Ax+By+C=0) ÁöÑË∑ùÁ¶ªÂÖ¨ÂºèÁöÑËØÅÊòéÔºåÊñπÊ≥ïÂæàÂ§ö„ÄÇÁõ¥ËßÇÁöÑÂá†ÁÇπÔºö
         |   1. ÁÇπÂà∞Áõ¥Á∫øÁöÑË∑ùÁ¶ªÔºåÁ≠â‰∫éÁªèËøáËØ•ÁÇπ„ÄÅ‰∏éÁõ¥Á∫øÂπ≥Ë°åÁöÑ‰∏§‰∏™Âπ≥Ë°åÁ∫ø‰πãÈó¥ÁöÑË∑ùÁ¶ª
         |      ËÄåÂπ≥Ë°åÁ∫øÈó¥ÁöÑÊñúÁéáÁõ∏ÂêåÔºåÂ∑ÆÂºÇÂú®‰∫éÊà™Ë∑ù‰∏çÂêå„ÄÇ
         |      ËÆæÂπ≥Ë°åÁ∫øÊñπÁ®ã‰∏∫ Ax+By+Cp=0 Âíå Ax+By+C=0ÔºåÂ∞ÜÁÇπ (x0,y0) ‰ª£ÂÖ•ÂâçËÄÖÔºåËß£Âá∫ Cp = -(A*x0 + B*y0)
         |      Âàô‰∏§Âπ≥Ë°åÁ∫øÁöÑÊà™Ë∑ùÂ∑ÆÂºÇ‰∏∫ |C - Cp| = |C + A*x0 + B*y0| = |A*x0 + B*y0 + C|
         |      ËÄåÂπ≥Ë°åÁ∫øÈó¥ÁöÑË∑ùÁ¶ªÂÖ¨Âºè‰∏∫ |C1 - C2| / sqrt(A^2 + B^2) (A != 0 Êàñ B != 0)
         |      ‰ª£ÂÖ•‰∏äÂºèÂç≥ÂæóÁÇπÂà∞Áõ¥Á∫øÁöÑË∑ùÁ¶ªÂÖ¨Âºè
         |   2. ÁÇπÂà∞Áõ¥Á∫øÁöÑË∑ùÁ¶ªÔºåÁ≠â‰∫éÁÇπÂà∞Áõ¥Á∫øÁöÑÂûÇÁ∫øÊÆµÁöÑÈïøÂ∫¶ÔºåÂç≥Áõ¥Á∫øÁªèËøáËØ•ÁÇπÁöÑÊ≥ïÁ∫ø‰∏éËØ•Áõ¥Á∫øÁöÑ‰∫§ÁÇπÂà∞ËØ•ÁÇπÁöÑË∑ùÁ¶ª
         |      Á≠â‰ª∑‰∫éÁõ¥Á∫ø‰∏äÁöÑÁÇπÂà∞ËØ•Ê≥ïÁ∫øÁöÑÊäïÂΩ±ÈïøÂ∫¶
         |      ËÆæÁÇπ (x0,y0) ‰∏∫ PÔºåÁõ¥Á∫ø‰∏äÁöÑ‰ªªÊÑèÁÇπ Q(x,y)ÔºåÂàô QP ÂêëÈáè‰∏∫ (x0-x, y0-y)
         |      ËÄåÁõ¥Á∫øÁöÑÊ≥ïÁ∫øÂêëÈáè‰∏∫ (A, B)ÔºåÂàô QP Âú®Ê≥ïÁ∫øÂêëÈáè‰∏äÁöÑÊäïÂΩ±ÈïøÂ∫¶‰∏∫ |(x0-x)*A + (y0-y)*B| / sqrt(A^2 + B^2)
         |      ÂåñÁÆÄÂèØÂæó |A*x0 + B*y0 + C| / sqrt(A^2 + B^2)
         |   3. Êõ¥Êú¨Ë¥®ÔºåÁÇπÊòØÂúÜÂøÉÔºåË∑ùÁ¶ªÊòØÂçäÂæÑÔºåÁõ¥Á∫øÊòØÂàáÁ∫ø
         |      ‰∏Ä‰∏™ÂúÜÁöÑÊâÄÊúâÂàáÁ∫øÔºåÊò†Â∞Ñ‰∫Ü‰∏Ä‰∏™ÂÆåÊï¥ÁöÑÊñúÁéáÈõÜÂêà„ÄÇÂúÜÂ∞±ÊòØÁî±Êª°Ë∂≥Ëøô‰∫õÊñúÁéáÁöÑÁõ¥Á∫øÁöÑÂàáÁÇπÊûÑÊàê„ÄÇËÄåËøô‰∫õÁõ¥Á∫øÈÉΩÂØπÂ∫î‰∫Ü‰∏Ä‰∏™ÁâπÂÆöÁöÑÊà™Ë∑ù
         |      ‰∏çÂêåÂçäÂæÑÁöÑÂúÜÔºåÊò†Â∞ÑÁöÑÊñúÁéáÈõÜÂêàÊòØÁõ∏ÂêåÁöÑ„ÄÇÊâÄ‰ª•ÂçäÂæÑÂ∞±ÂíåÊà™Ë∑ùÊàêÊ≠£ÊØî
         |      ÂúÜÂèØ‰ª•ÁúãÊàêÊòØÂú®ÊâÄÊúâÊñúÁéáÁöÑÁõ¥Á∫ø‰∏äÔºåÂêÑÂèñ‰∏Ä‰∏™ÁÇπÔºàÂàáÁÇπÔºâÊûÑÊàêÁöÑÁÇπÈõÜ
         |      ÂêåÊ†∑ÔºåÂçäÂæÑ‰πüÂèØ‰ª•ÁúãÊàêÊòØÊ≥ïÁ∫øÔºåÂêåÊ†∑‰πüÂØπÂ∫î‰∫Ü‰∏Ä‰∏™ÂÆåÊï¥ÁöÑÊñúÁéáÈõÜÂêàÔºå‰ΩÜËøô‰∫õÊ≥ïÁ∫øÁöÑÊà™Ë∑ù‰∏∫ 0ÔºåÊ≥ïÁ∫ø‰πüÂèØ‰ª•ÁúãÊàêÊòØÂçäÂæÑ‰∏∫ 0 ÁöÑÂàáÁ∫ø
         | + ‰ª£Á†ÅÂÆûÁé∞: {
         |       const x1 = p1[0], y1 = p1[1],
         |             x2 = p2[0], y2 = p2[1];
         |       const A = y2 - y1;
         |       const B = x1 - x2;
         |       const C = x2 * y1 - x1 * y2;
         |       return Math.abs(A * p[0] + B * p[1] + C) / Math.sqrt(A*A+B*B);
         |   }
         | + Êõ¥Ëøõ‰∏ÄÊ≠•ÔºåËøôÈáåÁöÑ A*x0 + B*y0 + C == cross(p1, p2, p) (ÂèâÁßØ)
         |   ÊâÄ‰ª•ÔºåË∑ùÁ¶ªÁÆóÊ≥ïÂèØ‰ª•Áõ¥Êé•ÂÜôÊàê‰∏ãÈù¢ÁöÑÂΩ¢Âºè
         |   (b[0] - ax) * (p[1] - ay) - (b[1] - ay) * (p[0] - ax)

         */
        console.assert(!sameOfPoints(p1, p2));  // ‰∏çÊîØÊåÅÈÄÄÂåñ‰∏∫ÁÇπÁöÑÊÉÖÂÜµ
        const dx = p2[0] - p1[0], dy = p2[1] - p1[1];
        return Math.abs(vCrossAux(p1, dx, dy, p)) / Math.sqrt(dx*dx + dy*dy);
    }
    // ËÆ°ÁÆó‰∏§Êù°Âπ≥Ë°åÁ∫øÁöÑË∑ùÁ¶ª
    function distanceOfParallelLines(A, B, C1, C2) {
        // Áõ¥Á∫ø Ax+By+C1=0 Âíå Ax+By+C2=0 (A != 0 Êàñ B != 0) ÁöÑË∑ùÁ¶ªÂÖ¨ÂºèÔºö|C1 - C2| / sqrt(A^2 + B^2)
        // + LaTeX: $$d = \frac{|C_1 - C_2|}{\sqrt{A^2 + B^2}}$$
        return Math.abs(C1 - C2) / Math.sqrt(A * A + B * B);
    }

    // ËßÑËåÉÂåñÂºßÂ∫¶(radians)Âà∞ [0, 2œÄ] ËåÉÂõ¥
    function normRad(r) {
        r %= PI2; return r < 0 ? r + PI2 : r;
    }
    // ËßÑËåÉÂåñÂºßÂ∫¶(radians)Âà∞ [-œÄ, œÄ] ËåÉÂõ¥ÔºåÂç≥Êª°Ë∂≥‰ª• 0 ‰∏∫‰∏≠ÂøÉÁöÑÂØπÁß∞ÊÄß
    function normRadS(r) {
        r = (r + Math.PI) % PI2; return r < 0 ? r + Math.PI : r - Math.PI;
    }
    // ÈáçÊñ∞Â∞Ü‰∏§‰∏™ÂΩí‰∏ÄÂåñÁöÑÂºßÂ∫¶ÁöÑ‰∏ÄÊ¨° +/- ËøêÁÆóÁªìÊûúÔºåÂΩí‰∏ÄÂåñÂà∞ [-œÄ, œÄ] ËåÉÂõ¥
    function normRadS2(r) {
        // ÊâßË°å‰∏ÄÊ¨° +/- ËøêÁÆóÂêéÔºåÂÆö‰πâÂüü‰ºöÊâ©Â§ß‰∏ÄÂÄç
        if (r > Math.PI) return r - PI2; else if (r < -Math.PI) return r + PI2;
        return r;
    }

    // Âà§Êñ≠ËßíÂ∫¶ a ÊòØÂê¶Âú®Âºß a0 Âà∞ a1 ‰πãÈó¥
    // + ËøôÈáå a0 Âà∞ a1 ÈªòËÆ§‰∏∫ ccw„ÄÇÂØπ‰∫é cw ÊñπÂêëÁöÑÂà§Êñ≠ÔºåÂèØ‰ª•Â∞Ü a0 Âíå a1 ‰∫§Êç¢‰ª£ÂÖ•
    function inArc(a, a0, a1) {
    // + ËøôÈáåÁöÑ a, a0, a1 ÈúÄË¶ÅÂ∑≤ÁªèÂÆåÊàêÁõ∏ÂêåÁöÑÂΩí‰∏ÄÂåñ
    //   ‰ΩÜÂΩí‰∏ÄÂåñÂèØ‰ª•ÊòØ [0, 2œÄ]Ôºå‰πüÂèØ‰ª•ÊòØ [-œÄ, œÄ]„ÄÅÂç≥ÂØπÂΩí‰∏ÄÂåñÁöÑÂÆö‰πâËåÉÂõ¥Âπ∂Ê≤°ÊúâË¶ÅÊ±Ç
        return a0 <= a1 ? (a >= a0 && a <= a1) : (a >= a0 || a <= a1);
    }
    // Âà§Êñ≠Âºß a0 Âà∞ a1 ÊòØÂê¶‰∏∫Â§ßÂºßÔºàa0 Âà∞ a1 ‰∏∫ÈÄÜÊó∂ÈíàÈ°∫Â∫èÔºâ
    // + ËøôÈáå a0 Âà∞ a1 ÈªòËÆ§‰∏∫ ccw„ÄÇÂØπ‰∫é cw ÊñπÂêëÁöÑÂà§Êñ≠ÔºåÂèØ‰ª•Â∞Ü a0 Âíå a1 ‰∫§Êç¢‰ª£ÂÖ•
    function isMinorArc(a0, a1) { return normRadS(a1 - a0) >= 0; }
    function isMajorArc(a0, a1) { return normRadS(a1 - a0) < 0; }

    // ËßÑËåÉÂåñËßíÂ∫¶(degrees)Âà∞ [0, 360] ËåÉÂõ¥
    function normDeg(d) {
        d %= 360; return d < 0 ? d + 360 : d;
    }
    // ËßÑËåÉÂåñËßíÂ∫¶(degrees)Âà∞ [-180, 180] ËåÉÂõ¥ÔºåÂç≥Êª°Ë∂≥‰ª• 0 ‰∏∫‰∏≠ÂøÉÁöÑÂØπÁß∞ÊÄß
    function normDegS(d) {
        d = (d + 180) % 360; return d < 0 ? d + 360 : d - 180;
    }
    function normDegS2(r) {
        if (r > 180) return r - 360; else if (r < -180) return r + 360;
        return r;
    }

    // Â∞ÜÁÇπÂΩíÂπ∂Âà∞ÂåÖÂõ¥Áõí‰∏≠
    function boxCombinePoint(box, p) {
        if (p[0] < box[0]) box[0] = p[0];   // left
        if (p[0] > box[2]) box[2] = p[0];   // right
        if (p[1] > box[1]) box[1] = p[1];   // top
        if (p[1] < box[3]) box[3] = p[1];   // bottom
    }
    // ËÆ°ÁÆóÂåÖÂõ¥Áõí‰∏≠ÂøÉÁÇπ
    function boxCenter(box) {
        return [(box[0] + box[2]) * 0.5, (box[1] + box[3]) * 0.5];
    }

    // ËÆ°ÁÆó‰∫åÈ°πÂºèÁ≥ªÊï∞ C(n, k)ÔºåÂç≥‰ªé n ‰∏™ÂÖÉÁ¥†‰∏≠Âèñ k ‰∏™ÂÖÉÁ¥†ÁöÑÁªÑÂêàÊï∞
    // + LaTeX: $$C(n, k) = \frac{n!}{k!(n-k)!}$$
    function binomialCoefficient(n, k) {
        console.assert(k <= n);
        if (k === 0 || k === n) return 1;           // Â¶ÇÊûúÂè™ÈÄâ‰∏Ä‰∏™„ÄÅÊàñÂÖ®ÈÄâÔºåÂàôÂè™Êúâ‰∏ÄÁßçÈÄâÊ≥ï
        k = Math.min(k, n - k);                     // ÂØπÁß∞ÊÄß: C(n, k) === C(n, n-k)
        let r = 1, i = 1;
        while (i <= k) { r *= (n - i + 1) / i; ++i; }
        return r;
    }

    // Êï∞ÂÄºÂæÆÂàÜÔºàÊï∞ÂÄºÂØºÊï∞Ôºâ- ËøîÂõûÂàáÂêëÈáè [dx/dt, dy/dt]
    function numericalDerivative(evalFn, t, delta=1e-4) {
        const p1 = evalFn(t - delta), p2 = evalFn(t + delta);
        if (!p1 || !p2) return null;
        return [(p2[0] - p1[0]) / (2 * delta), (p2[1] - p1[1]) / (2 * delta)];
    }
    // Êï∞ÂÄº‰∫åÈò∂ÂæÆÂàÜÔºà‰∫åÈò∂ÂØºÊï∞Ôºâ
    function numericalSecondDerivative(evalFn, t, delta=1e-4) {
        const p0 = evalFn(t - delta);
        const p1 = evalFn(t);
        const p2 = evalFn(t + delta);
        return [
            (p2[0] - 2*p1[0] + p0[0]) / (delta * delta),
            (p2[1] - 2*p1[1] + p0[1]) / (delta * delta)
        ];
    }

    // ÁâõÈ°øËø≠‰ª£Ê≥ïÁî®‰∫é‰ªé t0 ÂºÄÂßãÂØªÊâæÂèÇÊï∞ tÔºå‰ΩøÂæó evalFn(t) ÊúÄÊé•ËøëÁõÆÊ†áÁÇπ PÔºàÁõÆÊ†áÁÇπ P ‰∏ç‰∏ÄÂÆöÂú®Êõ≤Á∫ø‰∏äÔºâ
    function newtonRefine(P, t0, evalFn, deriveFn, derive2Fn, steps=5) {
        let t = t0;
        for (let i=0; i<steps; i++) {
            const p = evalFn(t), D1 = deriveFn(t), D2 = derive2Fn(t);
            const diff = vSub(p, P);                        // ËÆ°ÁÆóÂΩìÂâçÁÇπ p Âà∞ÁõÆÊ†áÁÇπ P ÁöÑÂêëÈáèÂ∑ÆÔºåÂç≥Â∑ÆÂºÇ
            const f = vDot(diff, D1);                       // ËÆ°ÁÆóÂÆûÈôÖÂ∑ÆÂºÇÂíå‰∏ÄÈò∂Â∑ÆÂºÇÁöÑ‰∫§ÈõÜÔºàÊú¨Ë¥®‰∏äÔºåÂÆûÈôÖÂ∑ÆÂºÇÂ∞±ÊòØÂíåÂ§öÈò∂Â∑ÆÂàÜÂüüÁöÑ‰∫§ÈõÜÂíåÔºâ
            const fPrime = vDot(D1, D1) + vDot(diff, D2);   // dot(D1, D1) ‰∏ÄÈò∂Â∑ÆÂàÜÂüüÁöÑÊÄªÈáèÔºå dot(diff, D2) ÊòØÂÆûÈôÖÂ∑ÆÂºÇ‰∏é‰∫åÈò∂Â∑ÆÂàÜÂüüÁöÑ‰∫§ÈõÜ
            // ÁâõÈ°øÊ≥ïÂÖ¨Âºè t = t - f / f'ÔºåÂÖ∂‰∏≠ f ÊòØË∑ùÁ¶ªÂú®ÂàáÁ∫øÊñπÂêë‰∏äÁöÑÊäïÂΩ±Ôºåf' ÊòØÂÖ∂ÂØπ t ÁöÑÂØºÊï∞
            t -= f / (fPrime + 1e-12);
            t = Math.max(0, Math.min(t, 1));
        }
        return t;
    }

    // Â§ÑÁêÜÂáΩÊï∞Âú®Êó†Á©∑ÂÄºÁöÑËæπÁïå
    function infiniteRefine(expr, xInf, x, y, t, b, re = 50, tol = 1e-9, eps = EPSILON) {
        console.assert(y >= b && y <= t);

        // ‰∏≠ÂÄºÊûÅÈôêÊ≥ïÈÄºËøë ROI ÂÜÖËæπÁïå
        while (re--) {

            // ËÆ°ÁÆó‰∏≠ÂÄº
            const m = 0.5 * (xInf + x); let ry;
            try { ry = expr(m); } catch { ry = NaN; }

            // Â¶ÇÊûúÊòØÊúâÈôêÂÄº
            if (isFinite(ry) && ry >= b && ry <= t) {

                // Â∑≤ÁªèÈùûÂ∏∏Êé•ËøëËæπÁïåÔºåÁõ¥Êé•ËøîÂõû
                if (ry - b <= eps || t - ry <= eps) return [m, ry];

                y = ry;     // ËÆ∞ÂΩïÊúÄÂêé‰∏Ä‰∏™ÊúâÈôêÂÄº
                x = m;      // ÂæÄÊó†Á©∑ÊñπÂêëÈÄºËøë
            }
            // Â¶ÇÊûúÊòØÊó†Á©∑ÊàñË∂ÖÂá∫ ROI ÁöÑÂÄºÔºåÈáçÁΩÆÊó†Á©∑Âü∫Á∫ø
            else xInf = m;

            // Â¶ÇÊûúÈÄºËøëÂà∞‰∫ÜÈòàÂÄºÔºåÊúÄÂêéÂÜçÁî®‰∏ÄÊ¨°‰∏≠ÂÄºÊ≥ï
            if (Math.abs(x - xInf) < tol) {
                const m = 0.5 * (xInf + x);
                try { ry = expr(m); } catch { ry = NaN; }
                if (isFinite(ry) && ry >= b && ry <= t)
                    return [m, ry];
                break;
            }
        }
        return [x, y];
    }

    // Ëá™ÈÄÇÂ∫îÈÄíÂΩíÁªÜÂàÜ
    function adaptiveRecurse(t0, t1, p0, p1, evalFn, selectFn, maxDepth = 10, tol2 = EPSILON2, depth) {
        const tm = 0.5 * (t0 + t1), pm = evalFn(tm);

        const dx = p1[0] - p0[0], dy = p1[1] - p0[1];
        const d2 = dx*dx + dy*dy;
        if (d2 === 0) { selectFn(p0, pm, p1); return; }

        // ÊÄßËÉΩ‰ºòÂåñ: ËøôÈáå‰∏çÁõ¥Êé•ÊØîÂØπË∑ùÁ¶ªÔºåËÄåÊòØÊØîÂØπÂπ≥ÊñπÔºöÂç≥ abs(cross)/sqrt(d2) < tol  <==>  cross*cross < tol*tol * d2
        const cross = vCrossAux(p0, dx, dy, pm);
        if ((cross * cross) <= tol2 * d2) { selectFn(p0, pm, p1); return; }

        // Â¶ÇÊûúËææÂà∞ÊúÄÂ§ßÈÄíÂΩíÊ∑±Â∫¶ÔºåÁõ¥Êé•ËæìÂá∫ÁªìÊûú
        if (!depth) depth = 0; else if (depth >= maxDepth) { selectFn(p0, pm, p1); return; }

        adaptiveRecurse(t0, tm, p0, pm, evalFn, selectFn, maxDepth, tol2, depth + 1);
        adaptiveRecurse(tm, t1, pm, p1, evalFn, selectFn, maxDepth, tol2, depth + 1);
    }

    // Âá∏ÂåÖÁÆóÊ≥ï (Andrew's monotone chain algorithm)ÔºåËøîÂõûÂåÖÂê´ÊâÄÊúâÁÇπÁöÑÊúÄÂ∞èÂá∏Â§öËæπÂΩ¢ÔºåÊåâÈÄÜÊó∂ÈíàÔºàCCWÔºâÈ°∫Â∫èÊéíÂàó
    // + Â¶ÇÊûúÊåáÂÆö‰∫Ü centroid ÂèÇÊï∞ÔºåÂàô‰∏∫ÊØè‰∏™Âá∏ÂåÖÈ°∂ÁÇπËÆ°ÁÆóÁõ∏ÂØπ‰∫éË¥®ÂøÉÁöÑÊûÅËßí„ÄÇ
    //   Âè¶Â§ñÔºåËøîÂõûÁöÑÈ°∂ÁÇπÊéíÂàóÁöÑÁ¨¨‰∏ÄÈ°π‰∏∫‰∏ãÂçäÈÉ®ÂàÜÂá∏ÂåÖÁöÑËµ∑ÁÇπÔºàÊúÄÂ∑¶‰∏ãËßíÁÇπÔºâÔºåËøôÂèØ‰ª•‰øùËØÅÊûÅËßíÊéíÂ∫èÁöÑÂçïË∞ÉÊÄßÔºåÂç≥ [-œÄ, œÄ] ËåÉÂõ¥ÂÜÖÂçïË∞ÉÈÄíÂ¢û
    function convexHull(ps, centroid) {
    /* + Ê≥®ÊÑèÔºåÂ¶ÇÊûúÊåáÂÆö‰∫Ü centroid ÂèÇÊï∞ÔºåÂàôËøîÂõûÁöÑÈ°∂ÁÇπÂØπË±°ÊòØ‰∏Ä‰∏™Êñ∞ÂàõÂª∫ÁöÑ‰∏âÂÖÉÁªÑÂØπË±°ÔºåÂê¶ÂàôÁõ¥Êé•ËøîÂõûÂéüÂßãÁÇπÂØπË±°ÁöÑÂºïÁî®
     |   Ê≠§Â§ñÔºåËøôÈáåÁîüÊàêÁöÑÈ°∂ÁÇπÂè™ËÉΩ‰øùËØÅ CCW ‰∏îÂçïË∞ÉÔºå‰ΩÜÊó†Ê≥ï‰øùËØÅÈ°∂ÁÇπÊûÅËßíÁöÑËåÉÂõ¥‰∏∫ [-œÄ, œÄ]ÔºåÂõ†‰∏∫ÊûÅËßíÁöÑËåÉÂõ¥ËøòÂèñÂÜ≥‰∫é‰∏≠ÂøÉ‰ΩçÁΩÆÁöÑÈÄâÂèñ„ÄÇ
     |   ‰ΩÜÂ§ß‰ΩìËÄåË®ÄÔºåÊòØÊåâ -œÄ -> œÄ ÁöÑÈ°∫Â∫èÊéíÂàóÁöÑ
    */
        console.assert(ps.length >= 3);

        // ÂÖàÊåâ x, ÁÑ∂Âêé y ÊéíÂ∫è
        ps = ps.slice().sort((a, b) => a[0] === b[0] ? a[1] - b[1] : a[0] - b[0]);

        const lower = [], upper = [];
        // lowerÈìæÔºö‰ªéÊúÄÂ∑¶‰∏ãÁöÑÁÇπÂºÄÂßãÔºåÂêëÂè≥‰∏äÊñπÂêëÊûÑÂª∫‰∏ãÂçäÈÉ®ÂàÜÂá∏ÂåÖÔºåÂç≥‰ªéÂ∑¶ÂêëÂè≥ÁöÑ‰∏ãÂá∏ÂåÖ
        for (const p of ps) {
            while (lower.length >= 2 && vCross(lower[lower.length-2], lower[lower.length-1], p) <= 0) lower.pop();
            lower.push(p);
        }
        // upperÈìæÔºö‰ªéÊúÄÂè≥‰∏äÁöÑÁÇπÂºÄÂßãÔºåÂêëÂ∑¶‰∏ãÊñπÂêëÊûÑÂª∫‰∏äÂçäÈÉ®ÂàÜÂá∏ÂåÖÔºåÂç≥‰ªéÂè≥ÂêëÂ∑¶ÁöÑ‰∏äÂá∏ÂåÖ
        for (let i = ps.length - 1; i >= 0; i--) { const p = ps[i];
            while (upper.length >= 2 && vCross(upper[upper.length-2], upper[upper.length-1], p) <= 0) upper.pop();
            upper.push(p);
        }

        // ÂéªÊéâÈ¶ñÂ∞æÈáçÂ§çÁÇπÔºåÂπ∂ÂêàÂπ∂
        upper.pop(); lower.pop();
        const hull = lower.concat(upper);

        // Â¶ÇÊûúÊèê‰æõ‰∫ÜË¥®ÂøÉÔºå‰∏∫ÊØè‰∏™Âá∏ÂåÖÈ°∂ÁÇπËÆ°ÁÆóÁõ∏ÂØπ‰∫éË¥®ÂøÉÁöÑÊûÅËßíÂíåÂèåÂêë invisible Á¥¢Âºï
        if (centroid) {
            return poleAngles(hull, centroid, false);  // ‰ΩøÁî® append=false ÂàõÂª∫Êñ∞Êï∞ÁªÑÊ®°Âºè
        }

        return hull;
    }

    // ËÆ°ÁÆóÂá∏ÂåÖÈ°∂ÁÇπÁõ∏ÂØπ‰∫éË¥®ÂøÉÁöÑÊûÅËßíÔºå‰ª•ÂèäÂèåÂêë invisible Á¥¢Âºï
    // + append = true: Âú®ÂéüÂßãÁÇπÊï∞ÁªÑ‰∏äÂ¢ûÈáèÊ∑ªÂä†ÊûÅËßíÂíå invisible Á¥¢ÂºïÔºàÂ¢ûÈáèÊ®°ÂºèÔºâ
    //   append = false: ÂàõÂª∫Êñ∞ÁöÑÈ°∂ÁÇπÊï∞ÁªÑ [x, y, poleAngle, invisible+, invisible-]ÔºàÂàõÂª∫Ê®°ÂºèÔºâ
    function poleAngles(convexHull, centroid, append = true) {
        const norm = (a) => {
            if (a <= -Math.PI) a += PI2;
            else if (a > Math.PI) a -= PI2;
            return a;
        };
        const cx = centroid[0], cy = centroid[1];
        const n = convexHull.length;

        // Ê†πÊçÆ append Ê®°ÂºèÂÜ≥ÂÆö A ÁöÑÁ¥¢Âºï‰ΩçÁΩÆ
        // append = true: A = ÂéüÂßãÊï∞ÁªÑÈïøÂ∫¶ÔºàÂ¢ûÈáèÊ®°ÂºèÔºâ
        // append = false: A = 2ÔºàÂàõÂª∫Êñ∞Êï∞ÁªÑÊ®°ÂºèÔºåÁªìÊûÑ‰∏∫ [x, y, poleAngle, invisible+, invisible-]Ôºâ
        const A = append ? convexHull[0].length : 2;
        const F = A + 1, B = A + 2;

        // ÂΩìÂâçÈ°∂ÁÇπ‰∏é‰∏ä‰∏Ä‰∏™È°∂ÁÇπÂΩ¢ÊàêÁöÑËæπÁöÑÊñπÂêëËßíÁºìÂ≠ò
        // + ËøôÈáåËæπÂêëÈáèÈááÁî® cw ÁöÑÊñπÂºèÔºåÂç≥ÂΩìÂâçËäÇÁÇπÊåáÂêë‰∏ä‰∏Ä‰∏™ËäÇÁÇπ
        const edges = [];

        // ÂæÖÔºàÊú™ÔºâÊûÑÂª∫ invisible ÂÖ≥Á≥ªÁöÑÈ°∂ÁÇπÁöÑÁ¥¢Âºï
        let last_cw = -1, last_ccw = 0;   // invisible-/invisible+

        // ËÆ∞ÂΩïÊûÅËßíÊúÄÂ∞èÁöÑÈ°∂ÁÇπÁ¥¢ÂºïÔºàÁî®‰∫éÂêéÁª≠ÈáçÊéíÊï∞ÁªÑ‰ΩøÊûÅËßíÂçïË∞ÉÔºâ
        let minIdx = 0, minAngle = Infinity;

        // ÂàùÂßãÂåñÁ¨¨‰∏Ä‰∏™È°∂ÁÇπÁöÑÊûÅËßí„ÄÅÂíåÁ¨¨1„ÄÅ2Êù°ËæπÁöÑÊñπÂêëËßí
        let np = convexHull[n-1], p = convexHull[0], i = 1, eNext, aPole;

        // Ê†πÊçÆ append Ê®°ÂºèÂ§ÑÁêÜÁ¨¨‰∏Ä‰∏™È°∂ÁÇπ
        aPole = Math.atan2(p[1] - cy, p[0] - cx);
        if (aPole < minAngle) { minAngle = aPole; minIdx = 0; }

        if (append) {
            p.push(aPole, 0/* invisible+ Âç†‰Ωç */);    // Â¢ûÈáèÊ®°ÂºèÔºöÊ∑ªÂä†Âà∞ÂéüÊï∞ÁªÑ
        } else {
            convexHull[0] = [p[0], p[1], aPole, 0];   // ÂàõÂª∫Ê®°ÂºèÔºöÂàõÂª∫Êñ∞Êï∞ÁªÑ
        }

        edges.push(Math.atan2(np[1] - p[1], np[0] - p[0]));                 // Á¨¨‰∏ÄÊù°ËæπÁöÑÊñπÂêëËßí, p[0]->p[n]
        np = convexHull[1]; eNext = Math.atan2(p[1] - np[1], p[0] - np[0]); // Á¨¨‰∫åÊù°ËæπÁöÑÊñπÂêëËßí, p[1]->p[0]

        // ‰ªéÁ¨¨‰∫å‰∏™È°∂ÁÇπÂºÄÂßã
        // + ‰∏¥Ëøë‰∏§‰∏™È°∂ÁÇπ‰∫íÁõ∏ÂøÖÁÑ∂ÂèØËßÅÔºåÂç≥
        //   Á¨¨ 0 ‰∏™È°∂ÁÇπÁöÑ invisible+ ËÇØÂÆöÊòØ‰ªéÁ¨¨ 1 ‰∏™‰∏éÁ¨¨ 2 ‰∏™È°∂ÁÇπÂΩ¢ÊàêÁöÑËæπÂºÄÂßãËÆ°ÁÆó
        //   Á¨¨ 1 ‰∏™È°∂ÁÇπÁöÑ invisible- ËÇØÂÆöÊòØ‰ªéÁ¨¨ 0 ‰∏™‰∏éÊúÄÂêé‰∏Ä‰∏™È°∂ÁÇπÂΩ¢ÊàêÁöÑËæπÂºÄÂßãËÆ°ÁÆó
        for (let j; ;i=j) {
            if ((j = i+1) === n) j = 0;
            p = np; np = convexHull[j];

            // ËÆ°ÁÆóÂΩìÂâçÈ°∂ÁÇπÁöÑÊûÅËßí c->p[i]
            aPole = Math.atan2(p[1] - cy, p[0] - cx);

            // ËÆ∞ÂΩïÊúÄÂ∞èÊûÅËßí
            if (aPole < minAngle) { minAngle = aPole; minIdx = i; }

            // Ê†πÊçÆ append Ê®°ÂºèÂ§ÑÁêÜÂΩìÂâçÈ°∂ÁÇπ
            if (append) {
                p.push(aPole, 0/* invisible+ Âç†‰Ωç */);                          // Â¢ûÈáèÊ®°ÂºèÔºöÊ∑ªÂä†Âà∞ÂéüÊï∞ÁªÑ
            } else {
                convexHull[i] = [p[0], p[1], aPole, 0];                         // ÂàõÂª∫Ê®°ÂºèÔºöÂàõÂª∫Êñ∞Êï∞ÁªÑ
            }

            // ËÆ∞ÂΩïÂΩìÂâçËæπÁöÑÊñπÂêëËßí p[i]->p[i-1]
            edges.push(eNext);

            // ËÆ°ÁÆó invisible+ (ÈÄÜÊó∂ÈíàÊñπÂêëÔºåÂç≥ i ÊòØÂê¶ÂØπ last_ccw ÂèØËßÜ)
            /* + ÂçïË∞ÉÊÄßÊÑèÂë≥ÁùÄÔºåÂ¶ÇÊûú i ÂØπ last_ccw ÂèØËßÜÔºåÂàô i ÂØπ last_ccw+ Â∞±ÈÉΩÂèØËßÜ
             |   ËøôÈáå last_ccw <- i ÈÉΩÊòØÂèØËßÅÁöÑÔºå‰ΩÜ i+1 -> i ÁöÑËæπÂá∫Áé∞ÔºåÂç≥ i+1 ÂèØËÉΩÊàê‰∏∫ last_ccw ‰ª•ÂèäÂêéÁª≠ËøûÁª≠Â§ö‰∏™È°∂ÁÇπÁöÑÈ¶ñ‰∏™‰∏çÂèØËßÅÈ°∂ÁÇπ
             |   Âõ†Ê≠§ÔºåËøôÈáåÁöÑÈÅçÂéÜÁõÆÊ†áÊòØÁ°Æ‰øùÊàñÈáçÊñ∞ËææÊàê last_ccw <- i ÂèØËßÅÁöÑÁä∂ÊÄÅÔºåÂç≥È¶ñÊ¨°Âá∫Áé∞ ++last_ccw <- i ÂèØËßÅÊó∂ÁªìÊùüÈÅçÂéÜ
             | + Ê≠§Â§ñÔºåÁî±‰∫é‰∏¥ËøëÈ°∂ÁÇπ‰∫íÁõ∏ÂøÖÁÑ∂ÂèØËßÅÔºåÊâÄ‰ª• last_ccw ËÇØÂÆöÂ∞è‰∫é i
            */

            // ËÆ°ÁÆó‰∏ã‰∏ÄËæπÁöÑÊñπÂêëËßí p[i+1]->p[i]
            eNext = Math.atan2(p[1] - np[1], p[0] - np[0]);
            do { console.assert(last_ccw < i);
                if (norm(eNext - convexHull[last_ccw][A]) < 0) break;               // ËæπÂú®ÊûÅËßíÂè≥‰æßÔºàÈ°∫Êó∂ÈíàÔºâÔºålast_ccw ‰æùÁÑ∂ÊàñÂèòÂæóÂèØËßÜ
                convexHull[last_ccw][F] = j;
            } while (++last_ccw < i);

            // ËÆ°ÁÆó invisible- (È°∫Êó∂ÈíàÊñπÂêëÔºåÂç≥ last_cw ÊòØÂê¶ÂØπ i ÂèØËßÜ)
            /* + ÂçïË∞ÉÊÄßÊÑèÂë≥ÁùÄÔºöÂ¶ÇÊûú last_cw ÂØπ i ‰∏çÂèØËßÜÔºåÂàôÂØπ i+ ‰πüÈÉΩ‰∏çÂèØËßÜ
             |   ‰ΩÜÊ≥®ÊÑèÔºålast_cw ÂØπ iÔºàÈ¶ñÊ¨°Ôºâ‰∏çÂèØËßÜÔºåÂπ∂‰∏çÊÑèÂë≥ÁùÄ last_cw+1 ÂØπ i+1 ‰πü‰∏çÂèØËßÜ
             |   ËÄåÂ¶ÇÊûú last_cw+1 ÂØπ i+1 ÂèØËßÜÔºåÈÇ£‰πà last_cw Â∞±ÂèØËÉΩÊàê‰∏∫ i+1 ÁöÑÈ¶ñ‰∏™‰∏çÂèØËßÜÈ°∂ÁÇπ
             |   ‰πüÂ∞±ÊòØËØ¥ last_cw ÂèØËÉΩ‰ºöÊàê‰∏∫ i ÂèäÂÖ∂ÂêéÈù¢Â§ö‰∏™ËøûÁª≠È°∂ÁÇπÁöÑÈ¶ñ‰∏™‰∏çÂèØËßÅÈ°∂ÁÇπ
             |   Âõ†Ê≠§ÔºåËøôÈáåÁöÑÈÅçÂéÜÁ≠ñÁï•ÊòØ: ÂÖàËææÊàê last_cw -> i ‰∏çÂèØËßÜÁöÑÁä∂ÊÄÅÔºåÂπ∂‰∏ÄÁõ¥‰øùÊåÅ last_cw -> i+ ÁöÑ‰∏çÂèØËßÜÁä∂ÊÄÅ
             |   ÁÑ∂ÂêéÂ¶ÇÊûú last_cw+n -> i ÂèØËßÜ‰∫ÜÔºåÂàô last_cw+n-1 -> i Â∞±ÊòØ i ÁöÑÈ¶ñ‰∏™‰∏çÂèØËßÜÈ°∂ÁÇπÔºåÂêåÊó∂ last_cw+n-1 -> i+ ‰πüËÇØÂÆö‰∏çÂèØËßÜÔºå
             |   ÊâÄ‰ª•Êé®Ëøõ last_cw = last_cw+n-1 ÂèØÁªßÁª≠‰øùÊåÅ last_cw -> i+ ÁöÑ‰∏çÂèØËßÜÁä∂ÊÄÅÔºåÁªìÊùüÈÅçÂéÜ
             | + Ê≠§Â§ñÔºåÁî±‰∫é‰∏¥ËøëÈ°∂ÁÇπ‰∫íÁõ∏ÂøÖÁÑ∂ÂèØËßÅÔºåÊâÄ‰ª•Âíå i ÊØîÂØπÁöÑÊúÄËøëÁöÑËæπÊòØ i-1 -> i-2 ÁöÑËæπÔºåÂç≥ edges[i-1]ÔºàËøôÈáå‰øùÂ≠ò‰∏∫ aPrevÔºâ
            */

            // Â¶ÇÊûúÂ∑≤ËææÊàê last_cw -> i+ ÁöÑ‰∏çÂèØËßÜÁä∂ÊÄÅ
            if (last_cw >= 0) {

                // ‰ªé last_cw+1 ÂºÄÂßãÊ£ÄÊü•ÔºåÊâæÂà∞Á¨¨‰∏Ä‰∏™ÂØπ i ÂèØËßÜÁöÑÈ°∂ÁÇπ
                // + Ê≥®ÊÑèÔºåËøôÈáå last_cw(k) ‰ª£Ë°®ÁöÑÊòØ p[k] ÂØπÂ∫îÁöÑËæπÔºåËÄå p[k] ÂØπÂ∫îÁöÑËæπÂàôÊòØ p[k]->p[k-1]
                for (let k = last_cw + 1 ; ; last_cw = k++) {
                    // ËøôÈáå k ‰∏çÂèØËÉΩË∂ÖËøá iÔºå‰ΩÜÂèØËÉΩÁ≠â‰∫é iÔºåÊ≠§Êó∂ last_cw == k-1
                    // ËÄåÂΩì k==i Êó∂ÔºåË°®Á§∫ edges[last_cw == i-1] ‰∏çÂèØËßÅÔºåÂç≥ p[i-2] ÂØπ p[i] ‰∏çÂèØËßÅ
                    // ÂêåÊó∂ k==i ‰πüÊÑèÂë≥ÁùÄ p[i] Âíå edges[i] ‰πãÈó¥ÔºåÂç≥ p[i] Âíå p[i-1] ‰πãÈó¥ÂøÖÁÑ∂ÂèØËßÅÔºà‰∏¥ËøëÈ°∂ÁÇπÂøÖÁÑ∂ÂèØËßÅÔºâ
                    console.assert(k <= i);
                    // Â¶ÇÊûú k Âèò‰∏∫ÂèØËßÜÔºåÂàô k ÁöÑÂâç‰∏Ä‰∏™È°∂ÁÇπÂ∞±ÊòØ i ÁöÑÈ¶ñ‰∏™‰∏çÂèØËßÜÈ°∂ÁÇπ
                    if (k === i || norm(edges[k] - aPole) < 0) break;  // ËæπÂú®ÊûÅËßíÂè≥‰æßÔºàÈ°∫Êó∂ÈíàÔºâÔºåk ÂØπ i ÂèØËßÜ
                }
                convexHull[i].push(last_cw ? last_cw - 1 : n - 1);  // ËÆæÁΩÆ invisible- ‰∏∫ last_cw-1ÔºàÊ≥®ÊÑèÁéØÂõûÔºâ
            }
            // Âê¶ÂàôÁõ¥Êé•ÊØîÂØπÁ¨¨‰∏Ä‰∏™Ëæπ edges[0] Âç≥ p[0]->p[n-1]
            else if (norm(edges[0] - aPole) >= 0) {
                convexHull[i].push(n-1);     // ËæπÂú®ÊûÅËßíÂ∑¶‰æßÔºàÈÄÜÊó∂ÈíàÔºâÔºå0 ÂØπ i ‰∏çÂèØËßÜ
                last_cw = 0;                 // Êõ¥Êñ∞ last_cwÔºåË°®Á§∫Ëæπ 0 ÂØπÂêéÁª≠È°∂ÁÇπ‰∏çÂèØËßÅ
            }

            if (!j) break;
        }

        // Ë°•ÈΩêÊú™ËÆæÁΩÆÁöÑ invisible+ÔºàÁéØÂõûÔºâ
        // + Ê≠§Êó∂ last_ccw Âà∞ n-1 ÁöÑÈ°∂ÁÇπËøòÊ≤°ÊúâËÆæÁΩÆ invisible+
        for(i = 0; last_ccw < n;) { console.assert(i < n, `invisible+ ÁéØÂõû: i=${i} Ë∂ÖÂá∫ËåÉÂõ¥ n=${n}, last_ccw=${last_ccw}`);

            // ‰ΩøÁî®ÁéØÂõûÁöÑËæπ edges[i]: p[i]->p[i-1]
            eNext = edges[i];

            // ËæπÂú®ÊûÅËßíÂè≥‰æßÔºålast_ccw ÂèØËßÅÔºåÈúÄË¶ÅÊõ¥Â§öÁöÑËæπ
            if (norm(eNext - convexHull[last_ccw][A]) < 0) i++;

            // ËæπÂú®ÊûÅËßíÂ∑¶‰æßÊàñÂπ≥Ë°åÔºålast_ccw ‰∏çÂèØËßÅÔºåËÆæÁΩÆ invisible+ ‰∏∫ i
            else convexHull[last_ccw++][F] = i;
        }

        // Ë°•ÈΩêÊú™ËÆæÁΩÆÁöÑ invisible-ÔºàÁéØÂõûÔºâ
        console.assert(last_cw >= 0, `last_cw should be set when using correct centroid: last_cw=${last_cw}, n=${n}`);
        for (i = 0; convexHull[i].length <= B; ++i) {

            aPole = convexHull[i][A];

            let k = (last_cw + 1); if (k === n) k = 0;
            for (;;) {
                // Ê≥®ÊÑèÔºåËøôÈáå k Â≠òÂú®ÁéØÂõûÁöÑÂèØËÉΩÔºåÊâÄ‰ª•‰∏çËÉΩÂÉèÂâçÈù¢ÈÇ£Ê†∑ÔºåÊñ≠Ë®Ä k < i
                if (k === i || norm(edges[k] - aPole) < 0) break; // k ÁéØÂõûÂà∞Ëá™Ë∫´Êàñ k ÂØπ i ÂèØËßÜ
                last_cw = k++; if (k === n) k = 0;
            }
            convexHull[i].push(last_cw ? last_cw - 1 : n - 1);  // ËÆæÁΩÆ invisible- ‰∏∫ last_cw-1ÔºàÊ≥®ÊÑèÁéØÂõûÔºâ
        }

        // Ë∞ÉÊï¥È°∫Â∫è‰ΩøÊûÅËßí‰∏•Ê†ºÂçïË∞ÉÈÄíÂ¢û
        // minIdx Â∑≤ÁªèÂú®‰∏ªÂæ™ÁéØ‰∏≠ËÆ°ÁÆóÂ•Ω‰∫Ü
        if (minIdx > 0) {
            // ÈáçÊéíÊï∞ÁªÑ
            convexHull = convexHull.slice(minIdx).concat(convexHull.slice(0, minIdx));

            // Ë∞ÉÊï¥ÊâÄÊúâÈ°∂ÁÇπÁöÑ invisible Á¥¢ÂºïÔºàICCW Âíå ICWÔºâ
            // ÂéüÁ¥¢Âºï i Êò†Â∞ÑÂà∞Êñ∞Á¥¢Âºï (i - minIdx + n) % n
            for (let i = 0; i < n; i++) {
                const oldICCW = convexHull[i][F];
                const oldICW = convexHull[i][B];

                // ÈáçÊñ∞Êò†Â∞ÑÁ¥¢Âºï
                convexHull[i][F] = (oldICCW - minIdx + n) % n;
                convexHull[i][B] = (oldICW - minIdx + n) % n;
            }
        }

        return convexHull;
    }

    // Âú®Â∏¶ÊúâÊûÅËßíÁöÑÂá∏ÂåÖÈ°∂ÁÇπÊï∞ÁªÑ‰∏≠Ôºå‰∫åÂàÜÊü•ÊâæÊåáÂÆöÊûÅËßíÁöÑ‰ΩçÁΩÆÁ¥¢Âºï
    // + ËøîÂõûÔºöÊª°Ë∂≥ convexHull[i][PA] <= angle ÁöÑÊúÄÂ§ßÁ¥¢Âºï iÔºåÂç≥Â∞ÑÁ∫øËßíÂ∫¶ angle Á©øËøáÁöÑËæπ (i, i+1) ÁöÑËµ∑ÁÇπÁ¥¢Âºï
    // + Ê≥®ÊÑèÔºöconvexHull ÁöÑÊûÅËßíÂøÖÈ°ªÊòØ‰∏•Ê†ºÂçïË∞ÉÈÄíÂ¢ûÁöÑÔºàÂèØÁî± poleAngles ‰øùËØÅÔºâ
    function binarySearchPoleAngle(convexHull, angle, PA = 3) {

        // Ê≥®ÊÑèÔºåangle ÁöÑËåÉÂõ¥ÂøÖÈ°ªÊòØ [-œÄ, œÄ]
        console.assert(angle >= -Math.PI && angle <= Math.PI);

        const n = convexHull.length;
        if (n === 1) return 0;

        const first = convexHull[0][PA];
        const last = convexHull[n-1][PA];

        // angle Âú®ËåÉÂõ¥ [first, last] ÂÜÖÔºåÊ†áÂáÜ‰∫åÂàÜÊü•Êâæ
        if (angle >= first && angle <= last) {
            let lo = 0, hi = n - 1;
            while (lo < hi) {
                const m = (lo + hi + 1) >> 1;
                if (convexHull[m][PA] <= angle) lo = m;
                else hi = m - 1;
            }
            return lo;
        }

        // angle ‰∏çÂú®ËåÉÂõ¥ÂÜÖ
        // Â¶ÇÊûú angle > lastÔºåËØ¥ÊòéÂú® (last, first+2œÄ) Âå∫Èó¥ÔºåËøîÂõû n-1
        // Â¶ÇÊûú angle < firstÔºåËØ¥ÊòéÂú® (last-2œÄ, first) Âå∫Èó¥ÔºåËøîÂõû n-1ÔºàÁéØÂõûÔºâ
        return n - 1;
    }

    // Ëá™ÈÄÇÂ∫îÈÄíÂΩíÁîüÊàêÂá∏ÂåÖ
    function adaptiveConvexHull(evalFn, maxDepth = 10, tol2 = EPSILON2) {

        let hull = [];

        // Â¢ûÈáèÊõ¥Êñ∞Âá∏ÂåÖ
        function updateConvexHull(hull, p) {
            hull.push(p);
            if (hull.length <= 3) return hull.slice();

            const ps = hull.slice().sort((a, b) =>
                a[0] === b[0] ? a[1] - b[1] : a[0] - b[0]);
            const lower = [], upper = [];

            for (const q of ps) {
                while (lower.length >= 2 && vCross(lower[lower.length-2], lower[lower.length-1], q) <= 0)
                    lower.pop();
                lower.push(q);
            }
            for (let i = ps.length - 1; i >= 0; i--) {
                const q = ps[i];
                while (upper.length >= 2 && vCross(upper[upper.length-2], upper[upper.length-1], q) <= 0)
                    upper.pop();
                upper.push(q);
            }
            upper.pop();
            lower.pop();
            return lower.concat(upper);
        }

        adaptiveRecurse(0, 1, evalFn(0), evalFn(1), evalFn,
            (p0/*, pm, p1*/)=> { hull = updateConvexHull(hull, p0); },
            maxDepth, tol2);
        return updateConvexHull(hull, evalFn(1));
    }

    // ÂÉèÁ¥†ÔºàÁ¶ªÊï£ÔºâÂåñÁöÑÂä®ÊÄÅÊèíÂÄºÁîüÊàêÂáΩÊï∞ÁÇπÊï∞ÁªÑ
    function pixelEval(evalFunc, range, pixelStep = 1 / (UNIT_SIZE * scale)) {
    /* + ÂèÇÊï∞ËØ¥ÊòéÔºö
     |   evalFunc: ÂáΩÊï∞Ë°®ËææÂºè
     |   range: ÂÆö‰πâÂüüËåÉÂõ¥ÊéßÂà∂ÔºåÂêåÊó∂‰Ωú‰∏∫ÊòØÂê¶ÊòØÂ±ÄÂüüÂáΩÊï∞ÁöÑÊ†áÂøó
     |     - false:
     |       ËØ¥ÊòéÊòØÂ±ÄÂüüÂáΩÊï∞ÔºåÊ≠§Êó∂ÂÆö‰πâÂüüÂõ∫ÂÆö‰∏∫ t‚àà[0,1]ÔºåÂç≥ evalFunc(t) ÂÖ∂‰∏≠ t‚àà[0,1]ÔºåËøîÂõû [x,y]
     |     - null || [minX, maxX]:
     |       ËØ¥ÊòéÊòØÂÖ®Â±ÄÂáΩÊï∞ÔºåÂÆö‰πâÂüüÂèóÈôê‰∫é range Âíå ROIÔºàÂ±èÂπïÔºâËæπÁïåÔºå
     |       Ê≠§Êó∂ evalFunc(x) ËøîÂõû y ÂÄºÔºåÂèØËÉΩÂåÖÂê´Êó†Á©∑ÂÄº
     |       > null: ÂÆö‰πâÂüüÊó†ÈôêÂà∂ x‚àà(-‚àû,+‚àû)Ôºå‰ΩøÁî® ROIÔºàÂ±èÂπïÔºâËæπÁïå
     |       > [a, b]: ÈôêÂà∂Âú® [a, b] ËåÉÂõ¥ÂÜÖÔºå‰∏éÂ±èÂπïËæπÁïåÂèñ‰∫§ÈõÜ
     |       > [a, null]: Â∑¶ËæπÁïåÈôêÂà∂‰∏∫ aÔºåÂè≥ËæπÁïå‰ΩøÁî®Â±èÂπïËæπÁïå
     |       > [null, b]: Âè≥ËæπÁïåÈôêÂà∂‰∏∫ bÔºåÂ∑¶ËæπÁïå‰ΩøÁî®Â±èÂπïËæπÁïå
    */
        const points = [];

        // ÂØπ‰∫éÂ±ÄÂüüÂáΩÊï∞Â§ÑÁêÜÔºå‰∏çËÄÉËôëÊó†Á©∑ÂÄºÂíå ROI
        // evalFunc ÁöÑÂèÇÊï∞ÊòØ tÔºåÂÆö‰πâÂüü‰∏∫ [0, 1]
        if (range === false) {

            // Â±ÄÂüüÂáΩÊï∞Ëá™ÈÄÇÂ∫îÊ≠•ÈïøÈááÊ†∑Ôºå‰ªé t=0 ÂºÄÂßãÂà∞ t=1 ÁªìÊùü
            const minStepT = 0.0001;                    // t ÁöÑÊúÄÂ∞èÊ≠•Èïø
            const maxStepT = 0.1;                       // t ÁöÑÊúÄÂ§ßÊ≠•Èïø
            let currentT = 0, nextStepT;

            while (currentT <= 1) {

                const p = evalFunc(currentT);
                points.push(p);

                const deltaT = pixelStep * 0.5;    // Âçä‰∏™ÔºàÂÉèÁ¥†ÔºâÂü∫Á°ÄÊ≠•Èïø
                const p1 = evalFunc(Math.max(0, currentT - deltaT));
                const p2 = evalFunc(Math.min(1, currentT + deltaT));

                // ‰∏ÄÈò∂ÂØºÊï∞ÔºàÂèòÂåñÁéáÔºâ
                const dx = p2[0] - p1[0];
                const dy = p2[1] - p1[1];
                const firstDerivative = Math.sqrt(dx * dx + dy * dy) / (2 * deltaT);

                // ÈªòËÆ§Âü∫‰∫é‰∏ÄÈò∂ÂØºÊï∞ËÆ°ÁÆóÊ≠•Èïø
                if (firstDerivative > 0) {

                    // Âü∫‰∫é‰∏ÄÈò∂ÂØºÊï∞ÁöÑÂü∫Á°ÄÊ≠•Èïø
                    nextStepT = Math.max(minStepT, Math.min(maxStepT, pixelStep / firstDerivative));

                    // ÊÄßËÉΩÁ≠ñÁï•ÔºöÂè™Âú®È´òÂèòÂåñÁéáÊó∂ÊâçÂêØÁî®‰∫åÈò∂ÂØºÊï∞ËÆ°ÁÆó
                    if (firstDerivative > 10) {

                        // ‰∫åÈò∂ÂØºÊï∞ÔºàÊõ≤ÁéáÔºâ- ‰ΩøÁî®Â∑≤ËÆ°ÁÆóÁöÑ‰∏≠ÂøÉÁÇπpÔºåÈÅøÂÖçÈáçÂ§çËÆ°ÁÆó
                        const d2x = (p2[0] - 2 * p[0] + p1[0]) / (deltaT * deltaT);
                        const d2y = (p2[1] - 2 * p[1] + p1[1]) / (deltaT * deltaT);
                        const secondDerivativeMagnitude = Math.sqrt(d2x * d2x + d2y * d2y);

                        // ËÆ°ÁÆóÊõ≤Áéá Œ∫ = |f''| / (1 + |f'|¬≤)^(3/2)
                        const curvature = secondDerivativeMagnitude / Math.pow(1 + firstDerivative * firstDerivative, 1.5);

                        // Âü∫‰∫é‰∫åÈò∂ÂØºÊï∞ÔºàÊõ≤ÁéáÔºâÁöÑÊ≠•ÈïøË°•Ê≠£
                        if (curvature > 0) {
                            const curvatureBasedStep = pixelStep * 0.1 / (curvature * 100 + 0.001);

                            // Âèñ‰∏ÄÈò∂Âíå‰∫åÈò∂ÂØºÊï∞Ê≠•ÈïøÁöÑÊúÄÂ∞èÂÄº
                            nextStepT = Math.min(nextStepT, curvatureBasedStep);

                            // ÊûÅÈ´òÊõ≤ÁéáÂå∫ÂüüËøõ‰∏ÄÊ≠•ÁªÜÂåñ
                            if (curvature > 0.01)
                                nextStepT = Math.min(nextStepT, pixelStep * 0.05);
                        }
                    }
                }
                else nextStepT = maxStepT;

                currentT += nextStepT;

                if (points.length > 100000) {
                    console.warn('Â±ÄÂüüÂáΩÊï∞ÁÇπÊï∞ÁªÑËøáÂ§ßÔºåÂÅúÊ≠¢ÈááÊ†∑');
                    break;
                }
            }

            return points;
        }

        // ÂØπ‰∫éÂèØËÉΩÊúâÊó†Á©∑ÂÄºÁöÑÂáΩÊï∞Â§ÑÁêÜÔºöËÄÉËôë ROI ÂíåËæπÁïåÁ≤æÂåñ
        // + Ê≠§Êó∂‰ºöËøîÂõû 2 Áª¥Êï∞ÁªÑÔºöÊØè‰∏™ËøûÁª≠ÊÆµÂΩ¢Êàê‰∏Ä‰∏™Â≠êÊï∞ÁªÑ

        // Ëé∑ÂèñÂ±èÂπïÂèØËßÜÂå∫Âüü‰Ωú‰∏∫Âü∫Á°ÄROI
        let roiL = (-offsetX) / (UNIT_SIZE * scale);                    // Â±èÂπïÂ∑¶ËæπÁïå
        let roiR = (canvas.width - offsetX) / (UNIT_SIZE * scale);      // Â±èÂπïÂè≥ËæπÁïå
        const roiT = (canvas.height + offsetY) / (UNIT_SIZE * scale);   // Â±èÂπï‰∏äËæπÁïå
        const roiB = (offsetY) / (UNIT_SIZE * scale);                   // Â±èÂπï‰∏ãËæπÁïå

        // ËÆ°ÁÆóÂÆûÈôÖÈááÊ†∑ËåÉÂõ¥ÔºöROI ‰∏é range ÁöÑ‰∫§ÈõÜ
        if (range) {
            if (range[0] !== null)
                roiL = Math.max(roiL, range[0]);
            if (range[1] !== null)
                roiR = Math.min(roiR, range[1]);
        }

        // Â±èÂπïÂÉèÁ¥†Á≤æÂ∫¶Áõ∏ÂÖ≥ËÆ°ÁÆó
        const minStep = Math.max(pixelStep * 0.1, 0.0001);
        const maxStep = pixelStep * 10;

        let currentX = roiL;
        let lastValidPoint = null;
        let lastInfiniteX = null;
        let currentSegment = []; // ÂΩìÂâçËøûÁª≠ÊÆµ
        let currentStep = pixelStep; // Âä®ÊÄÅÊ≠•Èïø

        while (currentX <= roiR) {
            try {
                let y = evalFunc(currentX);
                let shouldAddPoint = false;

                if (isFinite(y) && !isNaN(y)) {
                    // Â¶ÇÊûú‰πãÂâçÊúâÊó†Á©∑ÁÇπÔºåÂ∞ùËØïÁ≤æÂåñËæπÁïåÂπ∂ÂºÄÂßãÊñ∞ÊÆµ
                    if (lastInfiniteX !== null && lastValidPoint && y >= roiB && y <= roiT) {
                        const refinedPoint = infiniteRefine(evalFunc, lastInfiniteX, currentX, y, roiT, roiB);
                        if (refinedPoint) {
                            // ÁªìÊùü‰∏ä‰∏ÄÊÆµÔºàÂ¶ÇÊûúÊúâÔºâ
                            if (currentSegment.length > 0) {
                                points.push(currentSegment);
                                currentSegment = [];
                            }
                            // ÂºÄÂßãÊñ∞ÊÆµÔºåÊ∑ªÂä†Á≤æÂåñÁöÑËæπÁïåÁÇπ
                            currentSegment.push(refinedPoint);
                            lastValidPoint = refinedPoint;
                            lastInfiniteX = null;
                        }
                    }

                    // Ê£ÄÊü•ÂΩìÂâçÁÇπÊòØÂê¶Âú®ROIÂÜÖ
                    if (y >= roiB && y <= roiT) {
                        shouldAddPoint = true;
                        lastValidPoint = [currentX, y];
                        lastInfiniteX = null;
                    } else {
                        // ÁÇπÂú®ROIÂ§ñÔºåÁªìÊùüÂΩìÂâçÊÆµ
                        if (currentSegment.length > 0) {
                            points.push(currentSegment);
                            currentSegment = [];
                        }
                        lastInfiniteX = currentX;
                    }
                } else {
                    // ÈÅáÂà∞Êó†Á©∑ÂÄºÊàñNaNÔºåÂ∞ùËØïÁ≤æÂåñËæπÁïåÂπ∂ÁªìÊùüÂΩìÂâçÊÆµ
                    if (lastValidPoint && currentSegment.length > 0) {
                        try {
                            const refinedPoint = infiniteRefine(evalFunc, currentX, lastValidPoint[0], lastValidPoint[1], roiT, roiB);
                            if (refinedPoint && (refinedPoint[0] !== lastValidPoint[0] || refinedPoint[1] !== lastValidPoint[1])) {
                                currentSegment.push(refinedPoint);
                            }
                        } catch (e) {
                            // Á≤æÂåñÂ§±Ë¥•ÔºåÂøΩÁï•
                        }
                        // ÁªìÊùüÂΩìÂâçÊÆµ
                        points.push(currentSegment);
                        currentSegment = [];
                    }
                    lastInfiniteX = currentX;
                }

                if (shouldAddPoint) {
                    currentSegment.push([currentX, y]);
                }

                // Âä®ÊÄÅËÆ°ÁÆóÊ≠•ÈïøÔºàÂ∫îÁî®‰∫éÊâÄÊúâÊÉÖÂÜµÔºåÂåÖÊã¨ROIÂ§ñÁöÑÁÇπÔºâ
                let nextStep = pixelStep * 5;  // ÈªòËÆ§‰∏∫ËæÉÂ§ßÊ≠•ÈïøÔºàÁî®‰∫éÂ§±Ë¥•ÊÉÖÂÜµÔºâ
                try {
                    const deltaX = currentStep * 0.1;
                    const leftY = evalFunc(currentX - deltaX);
                    const rightY = evalFunc(currentX + deltaX);

                    if (isFinite(leftY) && isFinite(rightY)) {

                        // ËÆ°ÁÆó‰∏ÄÈò∂ÂØºÊï∞
                        const firstDerivative = Math.abs((rightY - leftY) / (2 * deltaX));

                        // È´òÊõ≤ÁéáÂå∫ÂüüÔºöËÆ°ÁÆó‰∫åÈò∂ÂØºÊï∞
                        if (firstDerivative > 10) {
                            const centerY = evalFunc(currentX);
                            if (isFinite(centerY)) {
                                const secondDerivative = Math.abs((leftY - 2 * centerY + rightY) / (deltaX * deltaX));
                                const curvatureStep = Math.sqrt(8 * pixelStep / Math.max(secondDerivative, 0.001));
                                const derivativeStep = pixelStep / firstDerivative;
                                nextStep = Math.min(curvatureStep, derivativeStep);
                            }
                            else nextStep = pixelStep / firstDerivative;
                        }
                        // ‰∏≠‰ΩéÊõ≤ÁéáÂå∫ÂüüÔºàÂ∞è‰∫é 10 ‰ΩÜÂ§ß‰∫é 0ÔºâÔºö‰ªÖ‰ΩøÁî®‰∏ÄÈò∂ÂØºÊï∞
                        else if (firstDerivative > 0)
                            nextStep = pixelStep / firstDerivative;
                        // Âπ≥Âù¶Âå∫ÂüüÔºö‰ΩøÁî®ËæÉÂ§ßÊ≠•Èïø (firstDerivative == 0)
                        else
                            nextStep = maxStep;

                        nextStep = Math.max(minStep, Math.min(maxStep, nextStep));
                    }
                } catch (e) {}

                currentStep = nextStep;
                currentX += nextStep;

            } catch (e) {
                // ÂºÇÂ∏∏Êó∂ÁªìÊùüÂΩìÂâçÊÆµ
                if (currentSegment.length > 0) {
                    points.push(currentSegment);
                    currentSegment = [];
                }
                lastInfiniteX = currentX;
                currentX += pixelStep * 5;
            }

            // Ê£ÄÊü•ÊÆµÊï∞ÈôêÂà∂ÔºåÈò≤Ê≠¢ÂÜÖÂ≠òËøáËΩΩ
            if (points.length > 1000) {
                console.warn('Êó†Á©∑ÂáΩÊï∞ÊÆµÊï∞ËøáÂ§öÔºåÂÅúÊ≠¢ÈááÊ†∑');
                break;
            }

            // Ê£ÄÊü•ÊÄªÁÇπÊï∞ÈôêÂà∂
            let totalPoints = points.reduce((sum, segment) => sum + segment.length, 0) + currentSegment.length;
            if (totalPoints > 100000) {
                console.warn('Êó†Á©∑ÂáΩÊï∞ÁÇπÊï∞ËøáÂ§öÔºåÂÅúÊ≠¢ÈááÊ†∑');
                break;
            }
        }

        // Ê∑ªÂä†ÊúÄÂêéÂâ©‰ΩôÁöÑÊÆµ
        if (currentSegment.length > 0) {
            points.push(currentSegment);
        }

        return points;
    }

    // ------------- ÂõæÂΩ¢ÂáΩÊï∞/ÂáΩÊï∞ÂõæÂΩ¢ --------------
    /* ÂõæÂΩ¢ÂáΩÊï∞ÊèèËø∞‰∏ÄÁªÑËøûÁª≠„ÄÅ‰∏îÂÖ∑ÊúâÁõ∏ÂêåËßÑÂæãÁöÑÂùêÊ†áÁÇπÈõÜÂêà
     | 1. ÂõæÂΩ¢ÊòØÁî±‰∏Ä‰∏™Êàñ‰∏ÄÁªÑÂõæÂΩ¢ÂáΩÊï∞ÊãºÊé•ÂΩ¢ÊàêÁöÑÂå∫ÂüüÔºåËøô‰∏™ÂõæÂΩ¢ÂáΩÊï∞Â∞±ÊûÑÊàêËøô‰∏™Âå∫ÂüüÁöÑËæπÁïå
     | 2. ÂÖ∂ÂÆûÈô§‰∫ÜÁõ¥Á∫øÔºåÂü∫Êú¨‰∏äÊâÄÊúâÂõæÂΩ¢ÈÉΩÊòØÂ±ÄÂüüÊÄßÁöÑÔºåËøôÂ∞±ÊÑèÂë≥ÁùÄÂÆÉ‰ª¨Êú¨Ë¥®‰∏äÈÉΩÊòØ‰ª•Ëá™ÂèòÈáè t ‰∏∫ÂÆö‰πâÂüüÔºåËÄå‰∏çÊòØ‰ª• x Êàñ y ‰∏∫ÂÆö‰πâÂüü
     |    t ÂèØ‰ª•ÁêÜËß£‰∏∫Êó∂Èó¥Áª¥Â∫¶Ôºå‰∏îÂÆÉÂèØ‰ª•Ë¢´ÂΩí‰∏ÄÂåñÂà∞ [0, 1] ËåÉÂõ¥ÂÜÖÔºåË°®Á§∫‰ªéËµ∑ÁÇπÂà∞ÁªàÁÇπÁöÑÊèíÂÄºÔºåÊàñÂÆåÊàêÂ∫¶„ÄÇ
     | 3. Â±ÄÂüüÊÄßÊÑèÂë≥ÁùÄÂõæÂΩ¢‰∏äÁöÑ‰∏Ä‰∏™ÁÇπÔºå‰ªÖÂíåÂÆÉÁöÑÂâçÂêéÁÇπÁöÑÁä∂ÊÄÅÊúâÂÖ≥ÔºåËÄåÂíå x, y ÂùêÊ†áÊó†ÂÖ≥„ÄÇ
     |    Êõ¥Êú¨Ë¥®ÁöÑÁúãÔºåËøôÂ∞±ÊòØÁõ∏ÂØπÊÄßÁöÑË°®Áé∞„ÄÇÂêåÊó∂‰πü‰ΩìÁ≥ª‰∫ÜÁ©∫Èó¥ÔºàÂùêÊ†áÔºâ‰ªÖ‰ªÖÊòØÂ≠òÂú®ÁöÑÂ±ûÊÄßÔºåËÄåÈùûÂÆ¢ËßÇÂ≠òÂú®„ÄÇ
     | 4. Ëá™ÂèòÈáè t ÊÑèÂë≥ÁùÄÔºåÂõæÂΩ¢Âú®ÂùêÊ†áÁ≥ª‰∏≠ÂèØ‰ª•ÊòØ‰ªªÊÑèÂΩ¢ÊÄÅÔºåÊÉ≥Ë±°‰∏Ä‰∏™ÈöèÊÑèÁöÑ"‰∏ÄÁ¨îÁîª"„ÄÇ
     |    Â∏∏ËßÅÁöÑÁÆÄÂçïÂáΩÊï∞ÂõæÂÉèÔºåÂç≥‰ª• x ‰∏∫Ëá™ÂèòÈáèÁöÑÂõæÂΩ¢ÔºåÂæÄÂæÄÊ≤ø x ËΩ¥ÂçïË∞ÉÂèòÂåñ„ÄÇÂÖ∂ÂÆû‰ªÖ‰ªÖÊòØ‰∏Ä‰∏™Áâπ‰æãÔºåÂç≥ t Âíå x ‰πãÈó¥Â≠òÂú®Á∫øÊÄßÂÖ≥Á≥ª„ÄÇ
     |    ‰∫ãÂÆû‰∏äÔºåËøôÁßçÁâπ‰æãÔºåÂæÄÂæÄ‰ΩìÁ≥ªÁöÑÊòØÊÉØÊÄßËøêÂä®ÁöÑË°®Áé∞„ÄÇ
    */

    // Á∫ø„ÄÇËøôÈáåÁî®ÊñúÁéáÂíåÂÅèÁßªÔºàÊà™Ë∑ùÔºâÊù•Ë°®Á§∫‰∏ÄÊù°ÊñúÁ∫ø„ÄÇÂÆö‰πâÂüü t ‚àà (-‚àû, +‚àû)
    // + Êõ¥ÂáÜÁ°ÆÁöÑËØ¥ÊòØÊñúÁ∫øÔºåÂõ†‰∏∫ÂÆÉ‰∏çÂåÖÂê´ÂûÇÁõ¥‰∫é X ËΩ¥Ôºà‰∏é Y ËΩ¥Âπ≥Ë°åÔºâÁöÑÂûÇÁ∫øÔºåÊ≠§Êó∂ÁöÑÊñúÁéá‰∏∫Êó†Á©∑Â§ß
    function line(t, k, b) { return [t, k * t + b]; }

    // ÂúÜ„ÄÇËøôÈáåÁî®ÂúÜÂøÉÂíåÂçäÂæÑÊù•Ë°®Á§∫‰∏Ä‰∏™ÂúÜ„ÄÇÂÆö‰πâÂüüÔºåt ‚àà [0, 1)
    // + ÂúÜÂøÖÁÑ∂ÊòØÂ±ÄÂüüÊÄßÁöÑÔºåÂç≥ÂÆÉ‰∏çÂ≠òÂú® line ËøôÁ±ªÂÖ®Â±ÄÊÄßÁöÑÂõæÂΩ¢ÂáΩÊï∞
    function circle(t, c, r) {
        // Â¶ÇÊûúÁî®ËßíÂ∫¶Âà∂ deg Êù•Ë°®Á§∫Ôºådeg ‚àà [0, 360)ÔºåÂàô const a = (deg % 360) * Math.PI / 180;
        const a = t * PI2;
        return [c[0] + r * Math.cos(a), c[1] + r * Math.sin(a)];
    }

    function circleAux(radius, aux) {
        if (!aux) return { r2: radius * radius, C: PI2 * radius };
        aux.r2 = radius * radius; aux.C = PI2 * radius;
        return aux;
    }

    function rectAux(l, t, r, b, aux) {
        const w = r - l, h = t - b;
        if (!aux) return {w, h, d: Math.sqrt(w * w + h * h)};
        aux.w = w; aux.h = h; aux.d = Math.sqrt(w * w + h * h);
        return aux;
    }

    // Á∫øÊÆµ„ÄÇËøôÈáåÁî®Ëµ∑ÁÇπÂíåÁªàÁÇπÊù•Ë°®Á§∫‰∏ÄÊù°Á∫øÊÆµ„ÄÇÂÆö‰πâÂüüÊòØ t ‚àà [0, 1]
    // + Áõ∏ÊØî‰∫éÊñúÁ∫øÔºåÁ∫øÊÆµÊòØÂ±ÄÂüüÊÄßÁöÑ„ÄÇÊâÄ‰ª•ÂÆö‰πâÂüü‰πüÂèØ‰ª•Áî®ÂΩí‰∏ÄÂåñÁöÑ t Êù•Ë°®Á§∫Ôºå‰∏îÊó†ÈúÄËÄÉËôëÊñúÁéáÊó†Á©∑Â§ßÔºå‰ª•ÂèäÂÆö‰πâÂüüÊúâÊïàÊÄßÁöÑÈóÆÈ¢ò
    function seg(t, p1, p2) { return [p1[0] + (p2[0] - p1[0]) * t, p1[1] + (p2[1] - p1[1]) * t]; }

    function segAux(p1, p2, aux) {
        const vx = p2[0] - p1[0], vy = p2[1] - p1[1], d2 = vx * vx + vy * vy;
        const len = Math.sqrt(d2), slope = Math.atan2(vy, vx) * R2D;
        if (!aux) return { vx, vy, d2, len, slope };
        aux.vx = vx; aux.vy = vy; aux.d2 = d2; aux.len = len; aux.slope = slope;
        return aux;
    }
    function distAux(p1, p2, aux) {
        const dx = p2[0] - p1[0], dy = p2[1] - p1[1], dist = Math.sqrt(dx*dx + dy*dy);
        // nor ‰∏∫ÂûÇÁõ¥Ê≥ïÁ∫øÂêëÈáèÔºàÊ≤øÁõ¥Á∫øÈ°∫Êó∂ÈíàÊóãËΩ¨ 90 Â∫¶Ôºâ
        const norX = dy / dist, norY = -dx / dist;
        if (!aux) return { dx, dy, dist, norX, norY };
        aux.dx = dx; aux.dy = dy; aux.dist = dist; aux.norX = norX; aux.norY = norY;
        return aux;
    }

    // Âºß„ÄÇËøôÈáåÁî®ÂúÜÂøÉ„ÄÅÂçäÂæÑ„ÄÅËµ∑ÂßãËßíÂ∫¶ÂíåÁªìÊùüËßíÂ∫¶Êù•Ë°®Á§∫‰∏Ä‰∏™Âºß„ÄÇÂÆö‰πâÂüüÊòØ t ‚àà [0, 1]
    // + ÂºßÊòØÂúÜÁöÑ‰∏ÄÈÉ®ÂàÜÔºå‰ΩÜË¶ÅËÄÉËôëÂØπÁß∞‰∏ÄËá¥ÊÄßÁöÑÈóÆÈ¢òÔºå‰πüÂ∞±ÊòØËµ∑ÂßãËßíÂ∫¶ÂíåÁªìÊùüËßíÂ∫¶ÁöÑÂÖàÂêéËøõË°åÁ∫¶ÊùüÂÆö‰πâ
    function arc(t, c, r, a0, a1) {
        // ËßÑËåÉÂåñ startAngle Âíå endAngle
        a0 = normRad(a0); a1 = normRad(a1);
        // Á°Æ‰øù end > start
        if (a0 > a1) a1 += PI2;
        const a = (a0 + (a1 - a0) * t);
        return [c[0] + r * Math.cos(a), c[1] + r * Math.sin(a)];
    }

    // ËÆ°ÁÆóÂºßÁöÑËæÖÂä©ÂèÇÊï∞ÔºàÁî®‰∫éÂä†ÈÄüËÆ°ÁÆóÔºâ
    function arcAux(r, a0, a1, aux) {
        const range = normRad(a1-a0);
        const ux = Math.cos(a0), uy = Math.sin(a0);     // u Ëµ∑ÁÇπÂçï‰ΩçÂêëÈáè
        const vx = Math.cos(a1), vy = Math.sin(a1);     // v ÁªàÁÇπÂçï‰ΩçÂêëÈáè
        const cUV = ux * vy - uy * vx;                  // uv ÂèâÁßØ
        const dUV = ux * vx + uy * vy;                  // uv ÁÇπÁßØ
        const r2 = r * r;
        const deg0 = a0 * R2D, deg1 = a1 * R2D;
        if (!aux) return { r2, range, deg0, deg1, ux, uy, vx, vy, cUV, dUV };
        aux.r2 = r2; aux.range = range; aux.deg0 = deg0; aux.deg1 = deg1;
        aux.ux = ux; aux.uy = uy; aux.vx = vx; aux.vy = vy; aux.cUV = cUV; aux.dUV = dUV;
        return aux;
    }

    // ease ÂáΩÊï∞ÔºàÊ≠£Âº¶/‰∫åÊ¨°/‰∏âÊ¨°/ÂõõÊ¨°/‰∫îÊ¨°/ÊåáÊï∞/ÂúÜÂΩ¢/ÂõûÂºπ/ÂºπÊÄß/ÂºπË∑≥Ôºâ
    // + ËøôÈáå t ÁöÑÂÆö‰πâÂüüÊòØ [0, 1]ÔºåË°®Á§∫‰ªéËµ∑ÁÇπÂà∞ÁªàÁÇπÁöÑÊèíÂÄº
    //   ease ÂáΩÊï∞ÁöÑÊú¨Ë¥®‰ΩìÁé∞ÁöÑÊòØÂä®/ÂäøÁöÑËΩ¨Êç¢
    const EASE_FUNC = {
        SINE: 0,
        QUAD: 3,
        CUBIC: 6,
        QUART: 9,
        QUINT: 12,
        EXPO: 15,
        CIRC: 18,
        BACK: 21,
        ELASTIC: 24,
        BOUNCE: 27
    };
    const EASE_PROC = {
        IN: 0,
        OUT: 1,
        INOUT: 2,
    };
    const EASE_NUM = 10;
    const EASE_C1 = 1.70158;
    const EASE_C2 = EASE_C1 * 1.525;
    const EASE_C3 = EASE_C1 + 1;
    const EASE_C4 = PI2 / 3;
    const EASE_C5 = PI2 / 4.5;
    const EASE_N1 = 7.5625;
    const EASE_D1 = 2.75;
    const easeFunc = [
        /* SINE + IN */ (t) => { return 1 - Math.cos((t * Math.PI) / 2); },
        /* SINE + OUT */ (t) => { return Math.sin((t * Math.PI) / 2); },
        /* SINE + INOUT */ (t) => { return -(Math.cos(Math.PI * t) - 1) / 2; },
        /* QUAD + IN */ (t) => { return t * t; },
        /* QUAD + OUT */ (t) => { return 1 - (1 - t) * (1 - t); },
        /* QUAD + INOUT */ (t) => { return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2; },
        /* CUBIC + IN */ (t) => { return t * t * t; },
        /* CUBIC + OUT */ (t) => { return 1 - Math.pow(1 - t, 3); },
        /* CUBIC + INOUT */ (t) => { return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2; },
        /* QUART + IN */ (t) => { return t * t * t * t; },
        /* QUART + OUT */ (t) => { return 1 - Math.pow(1 - t, 4); },
        /* QUART + INOUT */ (t) => { return t < 0.5 ? 8 * t * t * t * t : 1 - Math.pow(-2 * t + 2, 4) / 2; },
        /* QUINT + IN */ (t) => { return t * t * t * t * t; },
        /* QUINT + OUT */ (t) => { return 1 - Math.pow(1 - t, 5); },
        /* QUINT + INOUT */ (t) => { return t < 0.5 ? 16 * t * t * t * t * t : 1 - Math.pow(-2 * t + 2, 5) / 2; },
        /* EXPO + IN */ (t) => { return t === 0 ? 0 : Math.pow(2, 10 * (t - 1)); },
        /* EXPO + OUT */ (t) => { return t === 1 ? 1 : 1 - Math.pow(2, -10 * t); },
        /* EXPO + INOUT */ (t) => { if (t === 0) return 0; if (t === 1) return 1;
            if (t < 0.5) return Math.pow(2, 20 * t - 10) / 2;
            return (2 - Math.pow(2, -20 * t + 10)) / 2;
        },
        /* CIRC + IN */ (t) => { return 1 - Math.sqrt(1 - Math.pow(t, 2)); },
        /* CIRC + OUT */ (t) => { return Math.sqrt(1 - Math.pow(t - 1, 2)); },
        /* CIRC + INOUT */ (t) => {
            if (t < 0.5) return (1 - Math.sqrt(1 - Math.pow(2 * t, 2))) / 2;
            return (Math.sqrt(1 - Math.pow(-2 * t + 2, 2)) + 1) / 2;
        },
        /* BACK + IN */ (t) => { return EASE_C3 * t * t * t - EASE_C1 * t * t; },
        /* BACK + OUT */ (t) => { return 1 + EASE_C3 * Math.pow(t - 1, 3) + EASE_C1 * Math.pow(t - 1, 2); },
        /* BACK + INOUT */ (t) => {
            if (t < 0.5) return (Math.pow(2 * t, 2) * ((EASE_C2 + 1) * 2 * t - EASE_C2)) / 2;
            return (Math.pow(2 * t - 2, 2) * ((EASE_C2 + 1) * (t * 2 - 2) + EASE_C2) + 2) / 2;
        },
        /* ELASTIC + IN */ (t) => { if (t === 0) return 0; if (t === 1) return 1;
            return -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * EASE_C4);
        },
        /* ELASTIC + OUT */ (t) => { if (t === 0) return 0; if (t === 1) return 1;
            return Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * EASE_C4) + 1;
        },
        /* ELASTIC + INOUT */ (t) => { if (t === 0) return 0; if (t === 1) return 1;
            if (t < 0.5) return -(Math.pow(2, 20 * t - 10) * Math.sin((20 * t - 11.125) * EASE_C5)) / 2;
            return (Math.pow(2, -20 * t + 10) * Math.sin((20 * t - 11.125) * EASE_C5)) / 2 + 1;
        },
        /* BOUNCE + IN */ (t) => { return 1 - easeFunc[28] (1 - t); },
        /* BOUNCE + OUT */ (t) => {
            if (t < 1 / EASE_D1) return EASE_N1 * t * t;
            if (t < 2 / EASE_D1) return EASE_N1 * (t -= 1.5 / EASE_D1) * t + 0.75;
            if (t < 2.5 / EASE_D1) return EASE_N1 * (t -= 2.25 / EASE_D1) * t + 0.9375;
            return EASE_N1 * (t -= 2.625 / EASE_D1) * t + 0.984375;
        },
        /* BOUNCE + INOUT */ (t) => {
            if (t < 0.5) return (1 - easeFunc[28](1 - 2 * t)) / 2;
            return (1 + easeFunc[28](2 * t - 1)) / 2;
        }
    ]
    const ease = easeFunc.map(func => (t, p1, p2, amp, aux) => {

        if (amp) {

            let dx, dy, len, norX, norY;
            if (aux) {
                dx = aux.dx; dy = aux.dy; len = aux.dist;
                norX = aux.norX; norY = aux.norY;
            } else {
                dx = p2[0] - p1[0];
                dy = p2[1] - p1[1];
                len = v2Len(dx, dy);
                norX = dy / len;
                norY = -dx / len;
            }

            // easeÊõ≤Á∫øÔºöÊ≤øÁùÄÁõ¥Á∫øÂâçËøõÔºå‰ΩÜÂûÇÁõ¥ÂÅèÁßª = (func(t) - t) * amplitude (ÂπÖÂ∫¶)
            const offset = (func(t) - t) * amp * len;

            // Ê≤øÁùÄÁõ¥Á∫øÊñπÂêëÂùáÂåÄÂàÜÂ∏ÉÁÇπÔºàÊó∂Èó¥ËΩ¥Ôºâ
            const x = p1[0] + t * dx;
            const y = p1[1] + t * dy;
            return [x + norX * offset, y + norY * offset, t];
        }

        if (aux) return [p1[0] + aux.dx * t, p1[1] + aux.dy * func(t), t];
        const x1 = p1[0], y1 = p1[1], x12 = p2[0] - x1, y12 = p2[1] - y1;
        return [x1 + x12 * t, y1 + y12 * func(t), t];
    });

    // Ë¥ùÂ°ûÂ∞îÊõ≤Á∫øÁöÑ De Casteljau ÁÆóÊ≥ïÁâàÊú¨
    function DeCasteljau(t, cs) {

        if (cs.length === 1) {
            const p = cs[0]; p.push(t);
            return p;
        }

        const sub_cs = [];
        for (let i = 0; i < cs.length - 1; i++) {
            const p1 = cs[i];
            const p2 = cs[i + 1];
            sub_cs.push([
                p1[0] + t * (p2[0] - p1[0]),
                p1[1] + t * (p2[1] - p1[1])
            ]);
        }

        return DeCasteljau(t, sub_cs);
    }

    // Ë¥ùÂ°ûÂ∞îÊõ≤Á∫ø„ÄÇËøôÈáåÁî®ÊéßÂà∂ÁÇπÊï∞ÁªÑÊù•Ë°®Á§∫‰∏ÄÊù°Ë¥ùÂ°ûÂ∞îÊõ≤Á∫ø, n+1 ‰∏™ÊéßÂà∂ÁÇπ‰ª£Ë°® n Èò∂Ë¥ùÂ°ûÂ∞î„ÄÇÂÆö‰πâÂüüÊòØ t ‚àà [0, 1]
    // + Ê≥®ÊÑè: Ëµ∑ÁÇπÂíåÁªàÁÇπ‰πüÊòØÊéßÂà∂ÁÇπÁöÑ‰∏ÄÈÉ®ÂàÜ„ÄÇÊâÄ‰ª•Ê≠£Â∏∏ÊÉÖÂÜµ‰∏ãÔºå1 ‰∏™ÊéßÂà∂ÁÇπÂç≥Âè™Êúâ‰∏Ä‰∏™Ëµ∑ÁÇπ‰∏∫ 0 Èò∂Ë¥ùÂ°ûÂ∞îÔºåË°®Á§∫‰∏Ä‰∏™ÁÇπ; 2 ‰∏™ÊéßÂà∂ÁÇπ‰∏∫ 1 Èò∂Ë¥ùÂ°ûÂ∞îÔºåË°®Á§∫‰∏ÄÊù°Á∫øÊÆµÔºõ3 ‰∏™ÊéßÂà∂ÁÇπÊâçÊòØÊõ≤Á∫ø
    function bezier(t, cs) {
        console.assert(cs && cs.length > 2);      // Ëá≥Â∞ëË¶Å 3 ‰∏™ÊéßÂà∂ÁÇπÊâçÊûÑÊàêÊõ≤Á∫ø

        // ÂØπ‰∫éÈ´òÈò∂Ë¥ùÂ°ûÂ∞îÊõ≤Á∫øÔºå‰ΩøÁî® De Casteljau ÁÆóÊ≥ïËÆ°ÁÆó
        if (cs.length > 4)
            return DeCasteljau(t, cs);

        // ÂØπ‰∫é 2 Èò∂Âíå 3 Èò∂Ë¥ùÂ°ûÂ∞îÊõ≤Á∫øÔºå‰ΩøÁî®ÊòæÂºèÂÖ¨ÂºèËÆ°ÁÆó
        const n = cs.length - 1, oneMinusT = 1 - t;
        let x = 0, y = 0;
        for (let i = 0; i <= n; i++) {
            const ctrl = cs[i];
            const term = binomialCoefficient(n, i) * Math.pow(oneMinusT, n - i) * Math.pow(t, i);
            x += term * ctrl[0];
            y += term * ctrl[1];
        }
        return [x, y, t];
    }

    // Ëß£ÊûêÂíåËÆ°ÁÆóÊï∞Â≠¶Ë°®ËææÂºè
    function evalExpr(expression, x) {

        try {
            // ÂàõÂª∫‰∏Ä‰∏™ÂÆåÂÖ®ÈöîÁ¶ªÁöÑËÆ°ÁÆóÁéØÂ¢É
            const safeEval = new Function('xValue', `
            // ÂàõÂª∫Êú¨Âú∞MathÂØπË±°ÁöÑÂºïÁî®ÔºåÈÅøÂÖçÂÜ≤Á™Å
            const _Math = Math;
            const _sin = _Math.sin;
            const _cos = _Math.cos;
            const _tan = _Math.tan;
            const _log = _Math.log;
            const _sqrt = _Math.sqrt;
            const _abs = _Math.abs;
            const _exp = _Math.exp;
            const _pow = _Math.pow;
            const _floor = _Math.floor;
            const _ceil = _Math.ceil;
            const _round = _Math.round;
            const _min = _Math.min;
            const _max = _Math.max;
            const _PI = _Math.PI;
            const _E = _Math.E;

            // ÊõøÊç¢Ë°®ËææÂºè‰∏≠ÁöÑÂáΩÊï∞ÂíåÂ∏∏Èáè
            let expr = "${expression}";
            expr = expr.replace(/\\bpi\\b/gi, _PI);
            expr = expr.replace(/\\be\\b/gi, _E);
            expr = expr.replace(/\\bsin\\(/g, '_sin(');
            expr = expr.replace(/\\bcos\\(/g, '_cos(');
            expr = expr.replace(/\\btan\\(/g, '_tan(');
            expr = expr.replace(/\\blog\\(/g, '_log(');
            expr = expr.replace(/\\bln\\(/g, '_log(');
            expr = expr.replace(/\\bsqrt\\(/g, '_sqrt(');
            expr = expr.replace(/\\babs\\(/g, '_abs(');
            expr = expr.replace(/\\bexp\\(/g, '_exp(');
            expr = expr.replace(/\\bpow\\(/g, '_pow(');
            expr = expr.replace(/\\bfloor\\(/g, '_floor(');
            expr = expr.replace(/\\bceil\\(/g, '_ceil(');
            expr = expr.replace(/\\bround\\(/g, '_round(');
            expr = expr.replace(/\\bmin\\(/g, '_min(');
            expr = expr.replace(/\\bmax\\(/g, '_max(');
            expr = expr.replace(/\\^/g, '**');

            // ÊõøÊç¢x‰∏∫Êï∞ÂÄº
            expr = expr.replace(/\\bx\\b/g, '(' + xValue + ')');

            // ËÆ°ÁÆóÁªìÊûú
            return eval(expr);
        `);

            return safeEval(x);

        } catch (error) {
            console.error('Ë°®ËææÂºèËÆ°ÁÆóÂ§±Ë¥•:', error);
            console.error('ÂéüÂßãË°®ËææÂºè:', expression, 'xÂÄº:', x);
            throw new Error('Ë°®ËææÂºèËÆ°ÁÆóÈîôËØØ: ' + error.message);
        }
    }

    // ------------------ ÂåÖÂõ¥ÁõíÔºàÂ§ñÊé•Áü©ÂΩ¢Ôºâ ------------------
    /* ËøîÂõûÊ†ºÂºèÔºö[ left, top, right, bottom ]
     | ÂØπ‰∫éÈùûÂ±ÄÂüüÊÄßÊõ≤Á∫øÔºàÁõ¥Á∫ø„ÄÅÂáΩÊï∞ÔºâÔºåÂåÖÂõ¥ÁõíÂ∞±ÊòØ ROI ÂÜÖÂèØËßÜÈÉ®ÂàÜÁöÑËæπÁïå
     | ÂØπ‰∫éÂ±ÄÂüüÊÄßÊõ≤Á∫øÔºåÊú¨Ë¥®Â∞±ÊòØËÆ°ÁÆóÊâÄÊúâÊúÄÂÄºÁÇπÁöÑËæπÁïåÔºåÂç≥ÊâÄÊúâÂØºÊï∞‰∏∫ 0/Êó†Á©∑ ÁöÑÁÇπÔºå‰πüÂ∞±ÊòØÂàáÁ∫øÂíå x Âπ≥Ë°å/ y ÂûÇÁõ¥ÁöÑÁÇπ„ÄÇ‰æãÂ¶Ç‰∏ãÈù¢ arc ÈááÁî®ÁöÑÊñπÊ≥ï
     | ‰ΩÜÂØπ‰∫é‰ªªÊÑèÔºàÈªëÁõíÔºâÊõ≤Á∫øÊù•ËØ¥ÔºåÂç≥Êó†Ê≥ïÁõ¥Êé•Ê±ÇÂØºÁöÑÊõ≤Á∫øÔºåÂè™ËÉΩÈÄöËøáÈááÊ†∑Êù•Ëøë‰ººÊ±ÇËß£ÔºåÂç≥ÈÄíÂΩíÁªÜÂàÜ + Ëá™ÈÄÇÂ∫îÈááÊ†∑ÁÆóÊ≥ï
     */

    function boxOfCircle(c, r, box) {
        if (!box) return [c[0], c[1], c[0] - r, c[1] + r, c[0] + r, c[1] - r ];
        box[0] = c[0]; box[1] = c[1];
        box[2] = c[0] - r; box[3] = c[1] + r;
        box[4] = c[0] + r; box[5] = c[1] - r;
        return box;
    }
    function boxOfSeg(p1, p2, box) {
        let l, t, r, b;
        if (p1[0] < p2[0]) { l = p1[0]; r = p2[0]; } else { l = p2[0]; r = p1[0]; }
        if (p1[1] < p2[1]) { b = p1[1]; t = p2[1]; } else { b = p2[1]; t = p1[1]; }
        if (!box) return [ (l+r) * 0.5, (t+b) * 0.5, l, t, r, b ];
        box[0] = (l+r) * 0.5; box[1] = (t+b) * 0.5;
        box[2] = l; box[3] = t; box[4] = r; box[5] = b;
        return box;
    }
    function boxOfArc(c, radius, a0, a1, box) {
        // ÂºßÁöÑÊûÅÂÄºÁÇπÔºöÂ¶ÇÊûúÁ´ØÁÇπË∑®Ë∂ä‰∫ÜÂúÜÁöÑÊûÅÂÄºÁÇπÔºà0¬∞, 90¬∞, 180¬∞, 270¬∞ÔºâÔºåÈÇ£‰πàËøô‰∫õÊûÅÂÄºÁÇπÂ∞±ÊòØ box ÁöÑËæπÁïåÔºåÂê¶ÂàôÂè™ÈúÄË¶ÅËÄÉËôëÁ´ØÁÇπ

        let l, t, r, b;

        // ËÆ°ÁÆóÂºßÁ∫ø‰∏§Á´ØÁÇπ
        const Ax = c[0] + radius * Math.cos(a0);
        const Ay = c[1] + radius * Math.sin(a0);
        const Bx = c[0] + radius * Math.cos(a1);
        const By = c[1] + radius * Math.sin(a1);
        if (Ax < Bx) { l = Ax; r = Bx; } else { l = Bx; r = Ax; }
        if (Ay < By) { b = Ay; t = By; } else { b = By; t = Ay; }

        // Âà§Êñ≠ÊûÅÂÄºÁÇπ 0¬∞, 90¬∞, 180¬∞, 270¬∞
        for (const a of  [0, Math.PI / 2, Math.PI, 3 * Math.PI / 2]) {
            a0 = normRad(a0); a1 = normRad(a1);

            if (a0 <= a1) {
                if (a < a0 || a > a1) continue
            } else {
                if (a < a0 && a > a1) continue
            }

            const x = c[0] + radius * Math.cos(a);
            const y = c[1] + radius * Math.sin(a);
            if (x < l) l = x; else if (x > r) r = x;
            if (y < b) b = y; else if (y > t) t = y;
        }
        if (!box) return [ (l+r) * 0.5, (t+b) * 0.5, l, t, r, b ];
        box[0] = (l+r) * 0.5; box[1] = (t+b) * 0.5;
        box[2] = l; box[3] = t; box[4] = r; box[5] = b;
        return box;
    }
    function boxOfPolygon(ps, box) {
        let l = Infinity, r = -Infinity, b = Infinity, t = -Infinity;
        ps.forEach(p => {
            if (p[0] < l) l = p[0]; else if (p[0] > r) r = p[0];
            if (p[1] < b) b = p[1]; else if (p[1] > t) t = p[1];
        });
        if (!box) return [ (l+r) * 0.5, (t+b) * 0.5, l, t, r, b ];
        box[0] = (l+r) * 0.5; box[1] = (t+b) * 0.5;
        box[2] = l; box[3] = t; box[4] = r; box[5] = b;
        return box;
    }
    function boxOfEase(p1, p2, amp, func, aux, box) {

        if (!box) box = [Infinity, -Infinity, -Infinity, Infinity];
        else { box[0] = Infinity; box[1] = -Infinity; box[2] = -Infinity; box[3] = Infinity; }
        
        const fn = (t) => func(t, p1, p2, amp, aux);
        adaptiveRecurse(0, 1, fn(0), fn(1), fn,
            (a,m,b)=>{
                boxCombinePoint(box, a); boxCombinePoint(box, b); boxCombinePoint(box, m);
            });

        box.unshift((box[0] + box[2]) * 0.5, (box[1] + box[3]) * 0.5);
        return box;
    }
    function boxOfBezier(cs, box) {

        if (!box) box = [Infinity, -Infinity, -Infinity, Infinity];
        else { box[0] = Infinity; box[1] = -Infinity; box[2] = -Infinity; box[3] = Infinity; }
        
        const fn = (t) => bezier(t, cs);
        adaptiveRecurse(0, 1, fn(0), fn(1), fn,
            (a,m,b) => {
                boxCombinePoint(box, a); boxCombinePoint(box, b); boxCombinePoint(box, m);
            });

        box.unshift((box[0] + box[2]) * 0.5, (box[1] + box[3]) * 0.5);
        return box;
    }

    // ------------------ Ë¥®ÂøÉ ------------------
    /* + Ë¥®ÂøÉÊ±ÇËß£ÁöÑÂÖ≥ÈîÆÂú®‰∫é Green ÂÆöÁêÜÔºåÂç≥Â§öËæπÂΩ¢Âå∫ÂüüÁöÑÈù¢ÁßØÂèØ‰ª•ÈÄöËøáËæπÁïåÁßØÂàÜÊù•ËÆ°ÁÆó
     |   ÂØπÂ∫îÁöÑÔºåÊõ≤Á∫øÂèØ‰ª•ËΩ¨Êç¢‰∏∫Â§öËæπÂΩ¢Êù•Ëøë‰ººÊ±ÇËß£„ÄÇ
     |   ‰∏çËøáÊ≥®ÊÑèÔºåËøôÈáåÈááÁî®‰∫ÜËá™ÈÄÇÂ∫îÁªÜÂàÜÁÆóÊ≥ïÔºåËÄåÂÆÉÂàÜÂâ≤ÁöÑÂ§öËæπÂΩ¢Â∞±‰∏çÂÜçÊòØÈááÊ†∑ÁöÑÊ¶ÇÂøµÔºåËÄåÊòØÂæÆÁßØÂàÜÁöÑÊ¶ÇÂøµ
     |   ÊâÄ‰ª•ÂÆÉÊúÄÁªàÁöÑÁªìÊûúÂ∞±‰ºöÈÄºËøëÁúüÂÆûÁöÑË¥®ÂøÉÔºåËÄå‰∏çÊòØÈááÊ†∑ÁöÑËøë‰ººË¥®ÂøÉ
     | + Âè¶Â§ñÔºåGreen ÂÆöÁêÜÂèØ‰ª•ËÆ°ÁÆóÂá∏Â§öËæπÂΩ¢ÂíåÂáπÂ§öËæπÂΩ¢ÁöÑË¥®ÂøÉÔºå‰ΩÜ‰∏çËÉΩËÆ°ÁÆóËá™‰∫§Â§öËæπÂΩ¢
     |   ‰º†ÁªüËá™‰∫§Â§öËæπÂΩ¢ÔºåÂâçÊèêÊòØÂ§öËæπÂΩ¢Âå∫ÂüüÊòØÁî±È°∂ÁÇπÂü∫‰∫éÂ∫èÁöÑËøûÊé•ÂØºËá¥ÔºåÊ≠§Êó∂ÈÄÜÂêëÁöÑËæπÁöÑÈù¢ÁßØÂ∞±ÊòØË¥üÁöÑ
     |   ‰ΩÜËøôÈáåÁöÑË¥®ÂøÉÔºåÊåáÁöÑÊòØÁî±ÊâÄÊúâÈ°∂ÁÇπÁöÑÂá∏ÂåÖÂõ¥ÊàêÁöÑÊúÄÂ§ñÂ±ÇÂåÖÁªúÂå∫ÂüüÔºåÊâÄ‰ª•ÊòØÂú®Âá∏ÂåÖ‰∏äËÆ°ÁÆóË¥®ÂøÉ
     */

    function centroidOfRectangle(l, t, r, b, centroid) {
        if (!centroid) return [ (l + r) * 0.5, (t + b) * 0.5, (r - l) * (b - t) ];
        centroid[0] = (l + r) * 0.5;
        centroid[1] = (t + b) * 0.5;
        centroid[2] = (r - l) * (b - t);
        return centroid;
    }
    function centroidOfSeg(p1, p2, centroid) {
        if (!centroid) return [ (p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2, 0 ];
        centroid[0] = (p1[0] + p2[0]) / 2;
        centroid[1] = (p1[1] + p2[1]) / 2;
        centroid[2] = 0;
        return centroid;
    }
    function centroidOfArc(c, r, a0, a1, centroid) {
        // ËßÑËåÉÂåñËßíÂ∫¶
        let theta = a1 - a0;
        if (theta < 0) theta += PI2;
        if (theta > PI2) theta = theta % PI2;

        // ÂºìÂΩ¢Èù¢ÁßØ = ÊâáÂΩ¢Èù¢ÁßØ - ‰∏âËßíÂΩ¢Èù¢ÁßØ
        const sectorArea = 0.5 * r * r * theta;
        const triangleArea = 0.5 * r * r * Math.sin(theta);
        const area = sectorArea - triangleArea;

        // Â¶ÇÊûúËßíÂ∫¶Â§™Â∞èÔºåËøë‰ºº‰∏∫‰∏âËßíÂΩ¢
        if (theta < 1e-6) {
            const midAngle = (a0 + a1) / 2;
            const x = c[0] + r * Math.cos(midAngle);
            const y = c[1] + r * Math.sin(midAngle);
            if (!centroid) return [x, y, area];
            centroid[0] = x; centroid[1] = y; centroid[2] = area;
            return centroid;
        }

        // ÂºìÂΩ¢Ë¥®ÂøÉË∑ùÂúÜÂøÉÁöÑË∑ùÁ¶ªÔºàÊ≤øËßíÂπ≥ÂàÜÁ∫øÊñπÂêëÔºâÔºåÂÖ¨Âºè: d = (4 * r * sin¬≥(Œ∏/2)) / (3 * (Œ∏ - sin(Œ∏)))
        const halfTheta = theta / 2;
        const sinHalf = Math.sin(halfTheta);
        const centroidDistance = (4 * r * sinHalf * sinHalf * sinHalf) / (3 * (theta - Math.sin(theta)));

        // ËßíÂπ≥ÂàÜÁ∫øÊñπÂêë
        const midAngle = (a0 + a1) / 2;
        const cosA = Math.cos(midAngle);
        const sinA = Math.sin(midAngle);

        // Ë¥®ÂøÉÂùêÊ†á
        if (!centroid) return [c[0] + centroidDistance * cosA, c[1] + centroidDistance * sinA, area];
        centroid[0] = c[0] + centroidDistance * cosA;
        centroid[1] = c[1] + centroidDistance * sinA;
        centroid[2] = area;
        return centroid;
    }
    function centroidOfPolygon(ps, centroid) {
        console.assert(ps.length > 2);

        ps = convexHull(ps);

        const n = ps.length;
        if (n < 3) {
            // Â∞ÜÁ¨¨‰∏Ä‰∏™ÁÇπ‰Ωú‰∏∫ËøîÂõûÁöÑÊï∞ÊçÆÁªìÊûÑ„ÄÇp[2] ‰∏∫Èù¢ÁßØ 0
            if (!centroid) {
                const p = ps[0]; p[2] = 0;
                // Â¶ÇÊûúÂ≠òÂú®‰∏§‰∏™ÁÇπÔºåÂàôËÆ°ÁÆó‰∏≠ÁÇπ
                if (n === 2) { ps = ps[1];
                    p[0] = (p[0] + ps[0]) / 2; p[1] = (p[1] + ps[1]) / 2;
                }
                return p;
            } else {
                centroid[0] = ps[0][0];
                centroid[1] = ps[0][1];
                centroid[2] = 0;
                if (n === 2) {
                    centroid[0] = (ps[0][0] + ps[1][0]) / 2;
                    centroid[1] = (ps[0][1] + ps[1][1]) / 2;
                }
                return centroid;
            }
        }

        // === Green ÂÆöÁêÜËÆ°ÁÆóÂá∏ÂåÖË¥®ÂøÉ ===

        let area = 0, cx = 0, cy = 0;
        for (let i = 0; i < n; i++) {
            const [x0, y0] = ps[i];
            const [x1, y1] = ps[(i + 1) % n];   // ‰∏ã‰∏Ä‰∏™ÁÇπÔºåÈó≠ÂêàÂ§öËæπÂΩ¢
            const cross = x0 * y1 - x1 * y0;    // ÂèâÁßØÔºà‰∏§ËæπÁöÑÊúâÂêëÈù¢ÁßØÔºâ
            area += cross;
            cx += (x0 + x1) * cross;
            cy += (y0 + y1) * cross;
        }
        area *= 0.5;

        // Â¶ÇÊûúÈù¢ÁßØÂ§™Â∞èÊàñÈÄÄÂåñÔºå‰ΩøÁî®ËäÇÁÇπÂπ≥Âùá
        if (Math.abs(area) < 1e-14) {
            const sumX = ps.reduce((sum, p) => sum + p[0], 0);
            const sumY = ps.reduce((sum, p) => sum + p[1], 0);
            if (!centroid) return [sumX / n, sumY / n];
            centroid[0] = sumX / n; centroid[1] = sumY / n;
            return centroid;
        }

        if (!centroid) return [cx / (6 * area), cy / (6 * area), area];
        centroid[0] = cx / (6 * area);
        centroid[1] = cy / (6 * area);
        centroid[2] = area;
        return centroid;
    }
    function centroidOfEase(p1, p2, amp, func, aux, centroid) {

        let ps = [];
        const fn = (t) => func(t, p1, p2, amp, aux);
        const f0 = fn(0), f1 = fn(1);
        adaptiveRecurse(0, 1, f0, f1, fn, (a,m,b) => ps.push(a));
        ps.push(p2);

        if (ps.length < 3) {
            if (!centroid) return [ (f0[0] + f1[0]) / 2, (f0[1] + f1[1]) / 2, 0 ];
            centroid[0] = (f0[0] + f1[0]) / 2;
            centroid[1] = (f0[1] + f1[1]) / 2;
            centroid[2] = 0;
            return centroid;
        }

        return centroidOfPolygon(ps, centroid);
    }
    function centroidOfBezier(controls, centroid) {

        let ps = [];
        const fn = (t) => bezier(t, controls);
        const f0 = fn(0), f1 = fn(1);
        adaptiveRecurse(0, 1, f0, f1, fn, (a,m,b) => ps.push(a));
        ps.push(controls[controls.length - 1]);

        if (ps.length < 3) {
            if (!centroid) return [ (f0[0] + f1[0]) / 2, (f0[1] + f1[1]) / 2, 0 ];
            centroid[0] = (f0[0] + f1[0]) / 2;
            centroid[1] = (f0[1] + f1[1]) / 2;
            centroid[2] = 0;
            return centroid;
        }

        return centroidOfPolygon(ps, centroid);
    }

    // ------------------ ÂàáÁ∫ø/Ê≥ïÁ∫ø ------------------
    /* + ÂØπ‰∫é‰ªªÊÑèÊõ≤Á∫ø/ÂáΩÊï∞Êù•ËØ¥ÊàñÔºåÁî±‰∫é‰∏çÁü•ÈÅìÂõæÂΩ¢ÂáΩÊï∞ÁöÑÁªìÊûÑ‰ø°ÊÅØÔºåÊâÄ‰ª•Êó†Ê≥ïËé∑ÂæóÂØºÊï∞ÁöÑËß£ÊûêËß£„ÄÇÂç≥Âè™ËÉΩÈÄöËøáÊï∞ÂÄºÂæÆÂàÜÊù•Ëøë‰ººÊ±ÇËß£
     | + ËøîÂõûÂÄºÂÆö‰πâÔºö
     |   > null|undefinedÔºöÁÇπÊó†ÊïàÔºå‰∏çÂ±û‰∫éÂõæÂΩ¢
     |   > NaN: ‰∏çÂèØÂØº„ÄÇÊñ≠ÁÇπ/Â∞ñÁÇπ
     |   > Infinity: Êó†Á©∑ÔºåÂç≥ÂûÇÁõ¥Á∫ø
     */

    function tangentOfCircle(p, c, r) {

        // Ê£ÄÊü•ÁÇπÊòØÂê¶Âú®ÂúÜ‰∏ä
        if (!ptOnCircle(p, c, r)) return null;

        const [x, y] = p;
        const [cx, cy] = c;

        // ÂúÜÁöÑÂàáÁ∫øÂûÇÁõ¥‰∫éÂçäÂæÑ
        // ÂçäÂæÑÂêëÈáè: (x-cx, y-cy)
        // ÂàáÁ∫øÂêëÈáè: (-(y-cy), x-cx)
        const dx = -(y - cy);
        const dy = x - cx;

        // ÂûÇÁõ¥ÂàáÁ∫ø (dx = 0)
        if (Math.abs(dx) < 1e-10) return Infinity;

        return dy / dx;
    }
    function tangentOfRectangle(p, box) {

        const left = box[2], top = box[3], right = box[4], bottom = box[5];

        // Ê£ÄÊü•ÁÇπÊòØÂê¶Âú®Áü©ÂΩ¢ËæπÁïå‰∏ä
        if (!ptOnRectangle(p, left, top, right, bottom)) return null;

        const [x, y] = p;

        const eps = 1e-6;

        // Ê£ÄÊü•ÊòØÂê¶Âú®ËßíÁÇπÔºà‰∏çÂèØÂØºÔºâ
        const isCorner =
            (Math.abs(x - left) < eps || Math.abs(x - right) < eps) &&
            (Math.abs(y - top) < eps || Math.abs(y - bottom) < eps);

        if (isCorner) return NaN;

        // Âà§Êñ≠Âú®Âì™Êù°Ëæπ‰∏ä
        if (Math.abs(y - top) < eps || Math.abs(y - bottom) < eps) {
            // Ê∞¥Âπ≥ËæπÔºöÈ°∂ËæπÊàñÂ∫ïËæπ
            return 0;
        } else if (Math.abs(x - left) < eps || Math.abs(x - right) < eps) {
            // ÂûÇÁõ¥ËæπÔºöÂ∑¶ËæπÊàñÂè≥Ëæπ
            return Infinity;
        }

        return null; // ÁêÜËÆ∫‰∏ä‰∏çÂ∫îËØ•Âà∞ËææËøôÈáå
    }
    function tangentOfSeg(p, p1, p2) {

        // Ê£ÄÊü•ÁÇπÊòØÂê¶Âú®Á∫øÊÆµ‰∏ä
        if (!ptOnSeg(p, p1, p2)) return null;

        const [x1, y1] = p1;
        const [x2, y2] = p2;

        const dx = x2 - x1;
        const dy = y2 - y1;

        // Ê£ÄÊü•ÊòØÂê¶‰∏∫ÈÄÄÂåñÁöÑÁÇπ
        if (Math.hypot(dx, dy) < 1e-10) return NaN;

        // ÂûÇÁõ¥Á∫ø
        if (Math.abs(dx) < 1e-10) return Infinity;

        return dy / dx;
    }
    function tangentOfArc(p, c, r, a0, a1) {

        // Ê£ÄÊü•ÁÇπÊòØÂê¶Âú®Âºß‰∏ä
        if (!ptOnArc(p, c, r, a0, a1, null)) return null;

        const [x, y] = p;
        const [cx, cy] = c;

        // ÂºßÁöÑÂàáÁ∫ø‰∏éÂúÜÁõ∏ÂêåÔºåÂûÇÁõ¥‰∫éÂçäÂæÑ
        const dx = -(y - cy);
        const dy = x - cx;

        // ÂûÇÁõ¥ÂàáÁ∫ø
        if (Math.abs(dx) < 1e-10) return Infinity;

        return dy / dx;
    }
    function tangentOfPolygon(p, points) {

        // Ê£ÄÊü•ÁÇπÊòØÂê¶Âú®Â§öËæπÂΩ¢ËæπÁïå‰∏ä
        if (!ptOnPolygon(p, points)) return null;

        const [x, y] = p;
        const eps = 1e-6;

        // Ê£ÄÊü•ÊòØÂê¶Âú®È°∂ÁÇπÔºà‰∏çÂèØÂØºÔºâ
        for (const vertex of points) {
            if (Math.abs(x - vertex[0]) < eps && Math.abs(y - vertex[1]) < eps) {
                return NaN;
            }
        }

        // ÊâæÂà∞ÁÇπÊâÄÂú®ÁöÑËæπ
        for (let i = 0; i < points.length; i++) {
            const p1 = points[i];
            const p2 = points[(i + 1) % points.length];

            // Ê£ÄÊü•ÁÇπÊòØÂê¶Âú®ÂΩìÂâçËæπ‰∏ä
            if (ptOnSeg(p, p1, p2, eps)) {
                // ÁÇπÂú®ËøôÊù°Ëæπ‰∏äÔºåËøîÂõûËæπÁöÑÊñúÁéá
                const dx = p2[0] - p1[0];
                const dy = p2[1] - p1[1];

                if (Math.abs(dx) < eps) return Infinity; // ÂûÇÁõ¥Ëæπ
                return dy / dx;
            }
        }

        return null; // ÁêÜËÆ∫‰∏ä‰∏çÂ∫îËØ•Âà∞ËææËøôÈáå
    }
    function tangentOfEase(p, props) {

        let t;
        if (p.length > 2) t = p[2];
        else {
            const p2 = projectOnEase(p, props.ft[0], props.ft[1], props.amp, props.func, props.aux);
            if (distOfPoints(p, p2) > 1e-6) return null;
            t = p2[2];
        }

        // ‰ΩøÁî®Êï∞ÂÄºÂæÆÂàÜËÆ°ÁÆóÂàáÁ∫ø
        const [dx, dy] = numericalDerivative((t) => props.func(t, props.ft[0], props.ft[1], props.amp, props.aux), t);

        // Â∑¶Âè≥‰ªªÊÑè‰∏Ä‰æß‰∏çÂèØÂØºÔºåËßÜ‰∏∫‰∏çÂèØÂØº
        if (isNaN(dx) || isNaN(dy)) return NaN;
        // ÂûÇÁõ¥ÂàáÁ∫ø
        if (Math.abs(dx) < 1e-10) return Infinity;
        // Ê∞¥Âπ≥ÂàáÁ∫ø
        if (Math.abs(dy) < 1e-10) return 0;

        return dy / dx;
    }
    function tangentOfBezier(p, props) {

        let t;
        if (p.length > 2) t = p[2];
        else {
            const p2 = projectOnBezier(p, props.controls);
            if (distOfPoints(p, p2) > 1e-6) return null;
            t = p2[2];
        }

        // ‰ΩøÁî®Êï∞ÂÄºÂæÆÂàÜËÆ°ÁÆóÂàáÁ∫ø
        const [dx, dy] = numericalDerivative((t) => bezier(t, props.controls), t);

        // Â∑¶Âè≥‰ªªÊÑè‰∏Ä‰æß‰∏çÂèØÂØºÔºåËßÜ‰∏∫‰∏çÂèØÂØº
        if (isNaN(dx) || isNaN(dy)) return NaN;
        // ÂûÇÁõ¥ÂàáÁ∫ø
        if (Math.abs(dx) < 1e-10) return Infinity;
        // Ê∞¥Âπ≥ÂàáÁ∫ø
        if (Math.abs(dy) < 1e-10) return 0;

        return dy / dx;
    }
    function tangentOfLine(p, p1, p2) {

        // Ê£ÄÊü•ÁÇπÊòØÂê¶Âú®Áõ¥Á∫ø‰∏ä
        if (!ptOnLine(p, p1, p2)) return null;

        const [x1, y1] = p1;
        const [x2, y2] = p2;

        const dx = x2 - x1;
        const dy = y2 - y1;

        // Ê£ÄÊü•ÊòØÂê¶‰∏∫ÈÄÄÂåñÁöÑÁÇπ
        if (Math.hypot(dx, dy) < 1e-10) return NaN;

        // ÂûÇÁõ¥Á∫ø
        if (Math.abs(dx) < 1e-10) return Infinity;

        return dy / dx;
    }
    function tangentOfFunction(p, expr, range, viewRange) {

        const [x, y] = p;

        // Ê£ÄÊü•ÁÇπÊòØÂê¶Âú®ÂáΩÊï∞ÂõæÂÉè‰∏ä
        if (!ptOnFunction(p, (x) => evalExpr(expr, x))) return null;

        // ‰ΩøÁî®Êï∞ÂÄºÂæÆÂàÜËÆ°ÁÆóÂØºÊï∞
        try {
            const h = 1e-6;
            const y1 = evalExpr(expr, x - h);
            const y2 = evalExpr(expr, x + h);

            // Ê£ÄÊü•ÂáΩÊï∞ÂÄºÊòØÂê¶ÊúâÊïà
            if (isNaN(y1) || isNaN(y2)) return NaN;

            const derivative = (y2 - y1) / (2 * h);

            // Ê£ÄÊü•ÂØºÊï∞ÊòØÂê¶ÊúâÈôê
            if (!isFinite(derivative)) return NaN;

            return derivative; // ÂØπ‰∫éÂáΩÊï∞ y=f(x)Ôºådy/dx Â∞±ÊòØÊñúÁéá
        } catch (error) {
            return NaN;
        }
    }

    // ------------------ ÁÇπÂú®ÂõæÂΩ¢ËæπÁïå‰∏äÁöÑÊäïÂΩ± ------------------
    /* ÊäïÂΩ±ÁöÑÊú¨Ë¥®ÔºåÂ∞±ÊòØÂõæÂΩ¢‰∏ä‰∏éÁÇπ p Ë∑ùÁ¶ªÊúÄËøëÁöÑÁÇπ„ÄÇ
     | ËøôÂ∞±ÊÑèÂë≥ÁùÄÔºåËøô‰∏™ÁÇπ p ÂíåÊäïÂΩ±ÁÇπÔºåÂÖ∑ÊúâÊúÄÂ§ßÁöÑÁõ∏‰ººÊÄßÔºå‰πüÂ∞±ÊòØÁõ∏ÂÖ≥ÊÄß„ÄÇ
     */

    function projectOnCircle(p, c, r) {

        const cx = c[0], cy = c[1];
        const dx = p[0] - cx, dy = p[1] - cy;
        const d = Math.hypot(dx, dy);

        // Â¶ÇÊûúÂú®ÂúÜÂøÉÔºåËøîÂõûÂúÜ‰∏ä‰ªªÊÑèÁÇπ
        if (d === 0) return [cx + r, cy];

        // ÂΩí‰∏ÄÂåñÂêéÁöÑÊñπÂêëÂêëÈáè‰πò‰ª•ÂçäÂæÑ
        return [cx + (dx / d) * r, cy + (dy / d) * r];
    }
    function projectOnRectangle(p, l, t, r, b) {
        const x = p[0], y = p[1];

        // Â¶ÇÊûúÁÇπÂú®Áü©ÂΩ¢ÂÜÖÈÉ®
        if (x >= l && x <= r &&
            y >= b && y <= t) {

            // ÁÇπÂú®Áü©ÂΩ¢ÂÜÖÈÉ® ‚Üí ÊäïÂΩ±Âà∞ÊúÄËøëÁöÑËæπ
            const dl = x - l, dr = r - x, dt = t - y, db = y - b;

            const m = Math.min(dl, dr, dt, db);
            if (m === dl) return [l, y];
            if (m === dr) return [r, y];
            if (m === dt) return [x, t];
            return [x, b];
        }

        // ÁÇπÂú®Áü©ÂΩ¢Â§ñÈÉ®
        return [x < l ? l : (x > r ? r : x),
            y > t ? t : (y < b ? b : y)];
    }
    function projectOnSeg(p, p1, p2) {
        console.assert(!sameOfPoints(p1, p2));  // ‰∏çÊîØÊåÅÈÄÄÂåñ‰∏∫ÁÇπÁöÑÊÉÖÂÜµÔºàÊ≠§Êó∂ÁÇπÁßØËÇØÂÆö‰∏∫ 0ÔºåÂà§Êñ≠Êó†ÊïàÔºâ
        const x1 = p1[0], y1 = p1[1];
        const x12 = p2[0] - x1, y12 = p2[1] - y1;

        const dot = (p[0] - x1) * x12 + (p[1] - y1) * y12;
        if (dot <= 0) return p1;

        const s = dot / (x12 * x12 + y12 * y12);
        if (s >= 1) return p2;

        return [x1 + s * x12, y1 + s * y12];
    }
    function projectOnArc(p, c, r, a0, a1, eps = EPSILON) {

        const x = p[0], y = p[1];
        const cx = c[0], cy = c[1];
        let dx = x - cx, dy = y - cy;

        // ÁâπÊÆäÊÉÖÂÜµÔºöÁÇπÂú®ÂúÜÂøÉ
        if (Math.hypot(dx, dy) <= eps) {
            return [cx + r * Math.cos(a0), cy + r * Math.sin(a0)];
        }

        // ÁÇπÂØπÂ∫îÁöÑÊñπÂêëËßí
        let theta = Math.atan2(dy, dx);
        theta = normRad(theta);
        a0 = normRad(a0);
        a1 = normRad(a1);

        // Œ∏ Âú®ÂºßËåÉÂõ¥ÂÜÖ
        if (a0 <= a1 ? (theta >= a0 && theta <= a1)
                     : (theta >= a0 || theta <= a1)) {
            return [cx + r * Math.cos(theta), cy + r * Math.sin(theta)];
        }

        // Ëã•‰∏çÂú®ËåÉÂõ¥ÂÜÖÔºåÂèñÊúÄËøëÁ´ØÁÇπ
        const sx = cx + r * Math.cos(a0), sy = cy + r * Math.sin(a0);
        dx = x - sx; dy = y - sy;
        const sd = dx * dx + dy * dy;

        const ex = cx + r * Math.cos(a1), ey = cy + r * Math.sin(a1);
        dx = x - ex; dy = y - ey;
        const ed = dx * dx + dy * dy;

        return sd < ed ? [sx, sy] : [ex, ey];
    }
    function projectOnPolygon(p, ps, eps = EPSILON) {
        console.assert(ps && ps.length > 1);
        const x = p[0], y = p[1];

        const n = ps.length-1;
        let a = ps[n], b = ps[0];
        let mp = (a[0] === b[0] && a[1] === b[1]) ? a : projectOnSeg(p, a, b);
        let dx = mp[0] - x, dy = mp[1] - y;
        let md = dx * dx + dy * dy;
        if (md < eps) return mp;

        let i = 0; while (i < n) {
            const a = ps[i], b = ps[++i];

            // Â¶ÇÊûú‰∏§‰∏™ÁÇπÈáçÂêàÔºàÈõ∂ÈïøÂ∫¶ËæπÔºâÔºåË∑≥Ëøá
            if (a[0] === b[0] && a[1] === b[1]) continue;

            const pp = projectOnSeg(p, a, b);

            // Â¶ÇÊûúÊäïÂΩ±ÁÇπÊòØÂΩìÂâçËæπÁöÑËµ∑ÁÇπÔºåÂç≥ a Âú®ÂΩìÂâçËæπÁöÑ a/middle/b ‰∏≠ÊúÄËøë
            // + Ëøô‰πüÊÑèÂë≥ÁùÄÂΩìÂâçËæπÁöÑ middle/b ÊäïÂΩ±ÁÇπÔºåËÇØÂÆö‰∏ç‰ºöÊØî‰∏ä‰∏Ä‰∏™ËæπÁöÑÊäïÂΩ±ÁÇπÊõ¥Ëøë
            if (pp === a) continue;

            dx = pp[0] - x; dy = pp[1] - y;
            const d = dx * dx + dy * dy;
            if (d < eps) return pp;

            // Êõ¥Êñ∞ÊúÄÂ∞èË∑ùÁ¶ª
            if (d < md) { md = d; mp = pp; }
        }
        return mp;
    }
    function projectOnEase(p, p1, p2, amp, func, aux, eps = EPSILON, samples = 100) {

        const x = p[0], y = p[1];
        const S = func(0, p1, p2, amp, aux);

        // ËÆ°ÁÆóËµ∑ÁÇπÂíå p ÁöÑË∑ùÁ¶ªÔºåÂ¶ÇÊûúË∂≥Â§üËøëÔºåÁõ¥Êé•ËøîÂõû
        let A = S;
        let dx = A[0] - x, dy = A[1] - y;
        let md = dx * dx + dy * dy;
        if (md < eps) return A;

        let mi = 0, ms, d2;
        for (let i = 1; i <= samples; ++i) {
            const t = i / samples;
            const B = func(t, p1, p2, amp, aux);

            const s = projectRatio(p, A, B);
            // Â¶ÇÊûúÂíå A ÁÇπËøëÔºåÁõ¥Êé•Ë∑≥Âà∞‰∏ã‰∏Ä‰∏™Á∫øÊÆµ
            if (s === 0) { A = B; continue; }
            // Â¶ÇÊûúÂíå B ÁÇπËøëÔºåËÆ°ÁÆóÂíå B ÁÇπÁöÑË∑ùÁ¶ª
            if (s >= 1) {
                dx = B[0] - x; dy = B[1] - y;
                d2 = dx * dx + dy * dy;
                if (d2 <= eps) return B;    // B ÊòØÊõ≤Á∫ø‰∏äÁöÑÁÇπÔºåÂèØ‰ª•Áõ¥Êé•ËøîÂõû
            }
            // ËÆ°ÁÆóÂíåÊäïÂΩ±ÁÇπÁöÑË∑ùÁ¶ª
            else {
                const ps = [A[0] + s * (B[0] - A[0]), A[1] + s * (B[1] - A[1])];
                dx = ps[0] - x; dy = ps[1] - y;
                d2 = dx * dx + dy * dy;
            }
            // Êõ¥Êñ∞ÊúÄÂ∞èË∑ùÁ¶ª
            if (d2 < md) { md = d2; mi = i; ms = s; }
            A = B;
        }
        if (mi === 0) return S;
        if (mi === samples) return A;
        d2 = mi - 1;
        return projectRefine(p, (t) => func(t, p1, p2, amp, aux), d2/samples, mi/samples, (d2+ms)/samples);
    }
    function projectOnBezier(p, cs, eps = EPSILON, samples = 100) {

        const x = p[0], y = p[1];
        const S = bezier(0, cs);

        let A = S;
        let dx = A[0] - x, dy = A[1] - y;
        let md = dx * dx + dy * dy;
        if (md < eps) return A;

        let mi = 0, ms, d;
        for (let i = 1; i <= samples; i++) {
            const B = bezier(i / samples, cs);

            const s = projectRatio(p, A, B);
            if (s === 0) { A = B; continue; }
            if (s >= 1) {
                dx = B[0] - x; dy = B[1] - y;
                d = dx * dx + dy * dy;
                if (d <= eps) return B;    // B ÊòØÊõ≤Á∫ø‰∏äÁöÑÁÇπÔºåÂèØ‰ª•Áõ¥Êé•ËøîÂõû
            }
            else {
                const ps = [A[0] + s * (B[0] - A[0]), A[1] + s * (B[1] - A[1])];
                dx = ps[0] - x; dy = ps[1] - y;
                d = dx * dx + dy * dy;
            }
            if (d < md) { md = d; mi = i; ms = s; }
            A = B;
        }
        if (mi === 0) return S;
        if (mi === samples) return A;
        d = mi - 1;
        return projectRefine(p, (t) => bezier(t, cs), d/samples, mi/samples, (d+ms)/samples);
    }
    function projectOnLine(p, p1, p2) {
        console.assert(!sameOfPoints(p1, p2));  // ‰∏çÊîØÊåÅÈÄÄÂåñ‰∏∫ÁÇπÁöÑÊÉÖÂÜµÔºàÊ≠§Êó∂ÁÇπÁßØËÇØÂÆö‰∏∫ 0ÔºåÂà§Êñ≠Êó†ÊïàÔºâ
        const x1 = p1[0], y1 = p1[1];
        const x12 = p2[0] - x1, y12 = p2[1] - y1;   // ÊûÑÂª∫ p1 Âà∞ p2 ÁöÑÂêëÈáè

        // ËÆ°ÁÆóÂêëÈáè (A, B) ÂíåÂêëÈáè (dx, dy) ÁöÑÁÇπÁßØÔºåËøô‰ΩìÁé∞‰∫ÜÂÆÉ‰ª¨‰πãÈó¥ÁöÑÊäïÂΩ±ÂÖ≥Á≥ª
        // + Ê≠£Êï∞Ë°®Á§∫ÊäïÂΩ±ÊñπÂêë‰∏ÄËá¥ÔºåË¥üÊï∞Ë°®Á§∫ÊäïÂΩ±ÊñπÂêëÁõ∏Âèç
        //   ÁÇπÁßØÁöÑÊú¨Ë¥®ÊòØÊèèËø∞‰∫ÜÂêëÈáè (A, B) ÂíåÂêëÈáè (dx, dy) ‰πãÈó¥ÁöÑÁõ∏ÂÖ≥Èáè
        const dot = (p[0] - x1) * x12 + (p[1] - y1) * y12;

        // ËÆ°ÁÆóÊäïÂΩ±ÊØî
        /* + ‰πüÂ∞±ÊòØÁõ∏ÂÖ≥ÈáèÊØî‰∏äÊÄªÈáèÔºåËøôÈáåÁöÑÊÄªÈáèÊòØ‰ª•ÂêëÈáè (dx, dy) ‰∏∫Âü∫ÂáÜÁöÑÔºåÂç≥ÂêëÈáè (dx, dy) ÁöÑÈïøÂ∫¶ÁöÑÂπ≥ÊñπÂíå
         |   ËøôÂú®ÂõæÂΩ¢‰∏äË°®Á§∫‰ª• p1 -> p2 ÂêëÈáè‰∏∫ÂçäÂæÑÔºå‰ª• p1 ‰∏∫ÂúÜÂøÉÁöÑÂúÜÁöÑËåÉÂõ¥
         |   ‰πü‰ª£Ë°®‰∫Ü p1 -> p2 ÂêëÈáèÔºàË°®Á§∫ÁöÑÁª¥Â∫¶Ôºâ‰∏éÂÖ∂Ê≠£‰∫§Áª¥Â∫¶ÁöÑÈáèÂΩí‰∏ÄÂêéÁöÑÊÄªÈáè
         | + ÂØπÂ∫îÁöÑÔºåÂõæÂΩ¢‰∏äË°®Áé∞‰∏∫ÂêëÈáè (A, B) Âú®ÂêëÈáè (dx, dy) ‰∏äÁöÑÊäïÂΩ±ÈïøÂ∫¶ÔºåÂíåÂêëÈáè (dx, dy) ÁöÑÈïøÂ∫¶ÁöÑÊØîÂÄº
         |   Ê≠§Â§ñÔºåÊØîÂÄºÂ∞è‰∫é 1 Âç≥Áõ∏ÂÖ≥ÈáèÂú®ÊÄªÈáèËåÉÂõ¥ÂÜÖÔºåËØ¥ÊòéÊäïÂΩ±ÁÇπÂú®Á∫øÊÆµ[p1, p2]ËåÉÂõ¥ÂÜÖ
        */
        let prj_ratio = dot / (x12 * x12 + y12 * y12);
        return [x1 + prj_ratio * x12, y1 + prj_ratio * y12];
    }
    function projectOnFunction(p, expr, range, roi, eps = EPSILON, samples = 100) {

        const x = p[0], y = p[1];

        // ÈôêÂà∂(Ê®™Âêë)ÂÆö‰πâÂüüÊúâÊïàÂå∫Èó¥
        let [l, t, r, b] = roi;
        if (range) {
            if (range[0] > l) l = range[0];
            if (range[1] < r) r = range[1];
        }

        // ÂàùÂßãÂåñÂÆö‰πâÂüüÂÜÖÁöÑÁ¨¨‰∏Ä‰∏™ÁÇπ
        let A = null, B, xInf, dx, dy, md = 0, fy;
        try { fy = expr(l); } catch { fy = NaN; }
        if (isFinite(fy) && fy >= b && fy <= t) {
            A = [l, fy];
            dx = A[0] - x; dy = A[1] - y;
            md = dx * dx + dy * dy;
            if (md < eps) return A;
        } else xInf = l;  // ËÆ∞ÂΩïÊúÄÂêé‰∏Ä‰∏™Êó†Á©∑ÂÄºÁöÑ x ÂùêÊ†á

        const step = (r - l) / samples;

        let xs, xa, xb, d;
        for (let i = 1; i <= samples; ++i) {
            const fx = l + step * i;
            try { fy = expr(fx); } catch { fy = NaN; }

            // Â¶ÇÊûúÂÄºÂú®ÔºàÊúâÈôêÔºâROI ÂÜÖ
            if (isFinite(fy) && fy >= b && fy <= t) {

                // Â¶ÇÊûú‰πãÂâçÂ∑¶‰æßÊó†ÂÄºÔºàÊó†Á©∑Êàñ‰∏çÂú® ROI ÂÜÖÔºâÔºåÂΩìÂâçÂÄº‰Ωú‰∏∫ÔºàÊñ∞ÁöÑÔºâËµ∑ÁÇπ
                if (!A) {
                    A = infiniteRefine(expr, xInf, fx, fy, t, b);
                    dx = A[0] - x; dy = A[1] - y;
                    d = dx * dx + dy * dy;
                    if (d < eps) return A; // A ÊòØÂáΩÊï∞‰∏äÁöÑÁÇπÔºåÂèØ‰ª•Áõ¥Êé•ËøîÂõû
                    if (d < md) { md = d; xa = A[0]; }
                    continue;
                }
                B = [fx, fy];
            }
            // Â¶ÇÊûúÂÄº‰∏∫Êó†Á©∑Êàñ‰∏çÂú® ROI ÂÜÖ
            else { xInf = fx;

                // Â¶ÇÊûú‰πãÂâçÂ∑¶‰æßÊó†ÂÄºÔºåËØ¥ÊòéËøûÁª≠Âå∫ÂüüÊó†ÂÄºÔºåË∑≥Ëøá
                if (!A) continue;

                B = infiniteRefine(expr, xInf, A[0], A[1], t, b);
            }

            const s = projectRatio(p, A, B);
            if (s !== 0) {

                if (s >= 1) {
                    dx = B[0] - x; dy = B[1] - y;
                    d = dx * dx + dy * dy;
                    if (d <= eps) return B;    // B ÊòØÂáΩÊï∞‰∏äÁöÑÁÇπÔºåÂèØ‰ª•Áõ¥Êé•ËøîÂõû
                }
                else {
                    const ps = [A[0] + s * (B[0] - A[0]), A[1] + s * (B[1] - A[1])];
                    dx = ps[0] - x; dy = ps[1] - y;
                    d = dx * dx + dy * dy;
                }
                if (d < md) { md = d; xa = A[0]; xb = B[0]; xs = xa + s * (xb - xa); }
            }

            A = xInf === fx ? null : B;
        }
        if (xs === undefined) return A;
        function eval(x) { try { return [x, expr(x)]; } catch { return [x, NaN]; } }
        return projectRefine(p, eval, xa, xb, xs);
    }

    function projectRatio(p, p1, p2) {
        console.assert(!sameOfPoints(p1, p2));  // ‰∏çÊîØÊåÅÈÄÄÂåñ‰∏∫ÁÇπÁöÑÊÉÖÂÜµÔºàÊ≠§Êó∂ÁÇπÁßØËÇØÂÆö‰∏∫ 0ÔºåÂà§Êñ≠Êó†ÊïàÔºâ
        const x1 = p1[0], y1 = p1[1];
        const x12 = p2[0] - x1, y12 = p2[1] - y1;
        const dot = (p[0] - x1) * x12 + (p[1] - y1) * y12;
        return dot <= 0 ? 0 : dot / (x12 * x12 + y12 * y12);
    }
    function projectRefine(p, evalFn, ta, tb, ts, tol = 1e-9, maxIter = 64) {
        const x = p[0], y = p[1];
        function dist2(t) {
            const [fx, fy] = evalFn(t);
            const dx = fx - x, dy = fy - y;
            return dx * dx + dy * dy;
        }

        // ÂàùÂßãÂåñÔºöÂú® [ta, tb] ‰∏≠Áº©Â∞èÁ™óÂè£Âà∞ ts ÈôÑËøë
        const range = tb - ta;
        // ÈªòËÆ§‰ª• ts ‰∏∫‰∏≠ÂøÉÔºåÊêúÁ¥¢ ¬±25%
        let a = Math.max(ta, ts - 0.25 * range);
        let b = Math.min(tb, ts + 0.25 * range);
        // Â¶ÇÊûúÈù†ËøëËæπÁïåÔºåÂàôÊâ©Â±ïÂà∞ÂÖ®Âå∫Èó¥
        if (a < ta + 0.05 * range) a = ta;
        if (b > tb - 0.05 * range) b = tb;

        // ÂàùÂßãÈááÊ†∑ÁÇπÔºàÈªÑÈáëÂàÜÂâ≤‰∫åÂàÜÊêúÁ¥¢ÔºåÂü∫‰∫éÂå∫Èó¥ÂÜÖÂçïÂ≥∞Â±ÄÈÉ®ÊêúÁ¥¢Ôºâ
        let t1 = b - PHI * (b - a);
        let t2 = a + PHI * (b - a);
        let f1 = dist2(t1);
        let f2 = dist2(t2);
        let i = 0;
        while ((b - a) > tol && i++ < maxIter) {
            if (f1 < f2) {
                b = t2; t2 = t1; t1 = b - PHI * (b - a);
                f2 = f1; f1 = dist2(t1);
            } else {
                a = t1; t1 = t2; t2 = a + PHI * (b - a);
                f1 = f2; f2 = dist2(t2);
            }
        }

        // Âèñ‰∏≠ÁÇπ‰∏∫ÊúÄÁªàÂèÇÊï∞
        t1 = 0.5 * (a + b);
        return evalFn(t1);
    }

    // ------------------ Âà§Êñ≠ÁÇπÂú®ÂõæÂΩ¢‰∏ä ------------------
    /* ÁÇπÂú®ËæπÁïåÔºåÊÑèÂë≥ÁùÄÔºö1. ÁÇπ p ÊòØÂõæÂΩ¢ÂáΩÊï∞ÁöÑËß£; 2. ÁÇπ p ‰∏éÂáΩÊï∞ÂõæÂΩ¢ÁöÑË∑ùÁ¶ªÊó†ÈôêË∂ãËøë‰∫é 0
     | 1. ËøôÂ∞±ÊÑèÂë≥ÁùÄÔºåËß£ÁöÑÊú¨Ë¥®Â∞±ÊòØË∑ùÁ¶ª‰∏∫ 0ÔºåËÄåË∑ùÁ¶ªÔºàÂç≥Ê¨ßÂºèË∑ùÁ¶ªÔºâÂ∞±ÊòØÂêÑ‰∏™Áª¥Â∫¶ÁöÑÂ∑ÆÂºÇÁöÑÂπ≥ÊñπÂíåÔºå‰∏∫ 0 ÊÑèÂë≥ÁùÄÊó†Â∑ÆÂºÇ
     | 2. ÂâçÈù¢ÊèêÂà∞ÂõæÂΩ¢ÈÉΩÊòØÂ±ÄÂüüÊÄßÁöÑÔºåÂÖ∂Ëá™ÂèòÈáè t ‰ª£Ë°®‰∫ÜÂÖ∂Ëá™Ë∫´ÁöÑ‰∏Ä‰∏™Áõ∏ÂØπÁöÑÁª¥Â∫¶„ÄÇÊâÄ‰ª•Âè™ÊúâÁõ∏ÂØπ‰∫é t ÁöÑËß£(ÁÇπ)ÊâçÊòØÂîØ‰∏ÄÁöÑ„ÄÇ
     |    ‰ΩÜÊàë‰ª¨ÁöÑÂà§ÂÆöÁÇπ p ÂàôÊòØÁ©∫Èó¥ÂùêÊ†áÔºåÊâÄ‰ª•Êàë‰ª¨‰∏çËÉΩÁõ¥Êé•Â∞Ü p ÁÇπÁöÑ x ÂùêÊ†áÂ∏¶ÂÖ•Êù•Ê±ÇËß£ y ÂùêÊ†á„ÄÇ
     |    Èô§ÈùûÂõæÂΩ¢ÂáΩÊï∞ÊòØ‰ª• x ‰∏∫Ëá™ÂèòÈáèÁöÑÁÆÄÂçïÂáΩÊï∞ÔºàÂç≥ y = f(x) ÂΩ¢ÂºèÁöÑÂáΩÊï∞Ôºâ
     |    ‰∫ãÂÆû‰∏äÔºåÂØπ‰∫éÂ§ßÂ§öÊï∞ÂõæÂΩ¢Êù•ËØ¥ÔºåÂç≥‰ΩøÊØîËæÉÁÆÄÂçïÁöÑËû∫ÊóãÁ∫øÔºå‰πüÊó†Ê≥ïÁÆÄÂçïÁöÑÁî® x ÂùêÊ†áÊù•Ê±ÇËß£ y ÂùêÊ†áÔºàÊ≠§Êó∂‰∏Ä‰∏™ x ÂùêÊ†á‰ºöÂØπÂ∫îÂ§ö‰∏™ y ÂÄºÔºâ
     | 3. ÊâÄ‰ª•Âú®Âà§Êñ≠ÁÇπÊòØÂê¶Âú®ÂõæÂΩ¢ËæπÁïå‰∏äÊó∂ÔºåÊúÄÈÄöÁî®ÁöÑÊñπÂºèÂ∞±ÊòØÈááÊ†∑Ê≥ï„ÄÇ
     |    Âç≥Âú®ÂõæÂΩ¢ÂáΩÊï∞ÁöÑÂÆö‰πâÂüüÂÜÖÔºåÂùáÂåÄÔºàÊàñÁâπÂÆöÂàÜÂ∏ÉÔºâÈááÊ†∑Â§ö‰∏™ÁÇπÔºåËøôÊ†∑Áõ∏ÈÇªÁöÑ‰∏§‰∏™ÈááÊ†∑ÁÇπÂ∞±ÊûÑÊàê‰∫Ü‰∏Ä‰∏™Á∫øÊÆµÔºåÁÑ∂ÂêéÂà§Êñ≠ÁÇπÊòØÂê¶Âú®Á∫øÊÆµ‰∏ä
     |    Ê≠§Â§ñÔºå‰πüÂèØ‰ª•ÈÄöËøáËÆ°ÁÆóÁÇπÂà∞ÈááÊ†∑ÁÇπÁöÑË∑ùÁ¶ªÔºàË∂ãËøë‰∫é0ÔºâÊù•Âà§Êñ≠ÔºåËøôÊ†∑ÂÅö‰ºöÊõ¥Âø´Ôºå‰ΩÜ‰πüÊõ¥Á≤óÁ≥ô‰∏çÁ≤æÁ°Æ„ÄÇ
     | 4. Âá†‰∏™ÁâπÊÆäÂõæÂΩ¢ÁöÑÂà§Êñ≠Ôºå‰∫ãÂÆû‰∏äÔºåËøôÊòØÂà§ÂÆöÁöÑÂü∫Á°Ä
     |    1. Áõ¥Á∫øÔºöÂèâÁßØÔºàÁ≠âÁõ∏Ôºâ„ÄÇÊú¨Ë¥®ÊòØÁõ∏ÂØπ‰∏ÄËá¥ÊÄß
     |    2. ÂúÜÔºöË∑ùÁ¶ªÔºàÁ≠âË∑ùÔºâ„ÄÇÊú¨Ë¥®ÊòØÁõ∏ÂÖ≥‰∏ÄËá¥ÊÄß
     |    3. Áü©ÂΩ¢ÔºöÈÄªËæëÔºàÊúÄÂÄºÔºâ„ÄÇÊú¨Ë¥®ÊòØÁªüËÆ°‰∏ÄËá¥ÊÄß
     |    4. Á∫øÊÆµ/ÂºßÔºöÂú®Áõ¥Á∫ø/ÂúÜÁöÑÂü∫Á°Ä‰∏äÔºåÂ¢ûÂä†‰∫ÜÈÄªËæëÔºàÊúÄÂÄºÔºâÂà§Êñ≠
     |    5. ÂáΩÊï∞ÔºöËß£ÊûêÔºàÂçïË∞ÉÔºâ„ÄÇ‰æùËµñ‰∫éÂáΩÊï∞ÁöÑÂ§öÂØπ‰∏ÄÊò†Â∞ÑÁâπÊÄß„ÄÇ
     | 5. Âè¶Â§ñÔºåÂáΩÊï∞ÂíåÁõ¥Á∫ø‰∏ÄÊ†∑Ôºå‰∏çÂ±û‰∫éÂ±ÄÂüüÊÄßÂõæÂΩ¢ÔºåËøôÂ∞±ÊÑèÂë≥ÁùÄ
     |    1. Áõ¥Êé•‰ª• x Êàñ y ‰Ωú‰∏∫Ëá™ÂèòÈáè
     |    2. Â≠òÂú®Êó†Á©∑ÁöÑÈóÆÈ¢ò„ÄÇÂç≥ÂÆö‰πâÂüü/Ëß£ÈÉΩÂèØËÉΩÊòØÊó†Á©∑ÁöÑ
     */


    function ptOnCircle(p, c, r, eps = EPSILON) {
        const dx = p[0] - c[0], dy = p[1] - c[1];
        // ‰∏∫‰∫ÜÊÄßËÉΩÔºåËøôÈáåÊó†ÈúÄËøõË°åÂºÄÊñπÊìç‰Ωú„ÄÇ‰ΩÜÂØπ‰∫é eps ÁöÑÁ≤æÂ∫¶ËÄåË®ÄÔºåÂ¶ÇÊûúÈúÄË¶ÅÂíåÂºÄÊñπÁªìÊûú‰øùÊåÅÁ≤æÁ°Æ‰∏ÄËá¥ÔºåÂàôÈúÄË¶Å‰πò‰∏äÁõ¥ÂæÑÔºåÂç≥ eps*=2*r
        return Math.abs(dx * dx + dy * dy - r * r) <= eps;
    }
    function ptOnRectangle(p, l, t, r, b, eps = EPSILON) {
        const x = p[0], y = p[1];
        return (Math.abs(x - l) <= eps && y <= t + eps && y >= b - eps) ||
            (Math.abs(x - r) <= eps && y <= t + eps && y >= b - eps) ||
            (Math.abs(y - t) <= eps && x >= l - eps && x <= r + eps) ||
            (Math.abs(y - b) <= eps && x >= l - eps && x <= r + eps);
    }
    function ptOnSeg(p, p1, p2, eps = EPSILON) {
        console.assert(!sameOfPoints(p1, p2));  // ‰∏çÊîØÊåÅÈÄÄÂåñ‰∏∫ÁÇπÁöÑÊÉÖÂÜµÔºàÊ≠§Êó∂ÁÇπÁßØËÇØÂÆö‰∏∫ 0ÔºåÂà§Êñ≠Êó†ÊïàÔºâ
        const x = p[0], y = p[1], x1 = p1[0], y1 = p1[1], x2 = p2[0], y2 = p2[1];

        // ÈÄöËøáÈÄªËæëÂà§Êñ≠ËæπÁïå
        /* + ËæπÁïåÂà§Êñ≠‰πüÂèØ‰ª•ÈÄöËøáÁÇπÁßØÔºàÊäïÂΩ±ÔºâÁöÑÊñπÂºèÊù•Âà§Êñ≠ÔºåÂç≥
         |   0 < (x - x1)*(x2 - x1) + (y - y1)*(y2 - y1) < (x2 - x1)*(x2 - x1) + (y2 - y1)*(y2 - y1)
         |   Áõ∏ÊØî‰∫éÈÄªËæëÂà§Êñ≠ÔºåËØ•ÊñπÂºèÂú®Â§ßÈáèÁÇπÁöÑÂπ∂Ë°åËÆ°ÁÆóÊó∂ÔºåÊÄßËÉΩ‰ºöÊõ¥Â•Ω‰∏Ä‰∫õÔºåÂõ†‰∏∫ÈÅøÂÖç‰∫ÜÂàÜÊîØÈ¢ÑÊµãÂ§±Ë¥•Â∏¶Êù•ÁöÑÊÄßËÉΩÊçüÂ§±
         |   ‰ΩÜÂú®ÂçïÁÇπËÆ°ÁÆóÊó∂ÔºåÈÄªËæëÂà§Êñ≠ÁöÑÊÄßËÉΩ‰ºöÊõ¥Â•Ω
         | + Âè¶Â§ñÔºåÂà§Êñ≠‰ºòÂÖàËøòÊòØÂèâÁßØ‰ºòÂÖà„ÄÇÂêåÊ†∑ÔºåÂèâÁßØ‰ºòÂÖàÂú®Âπ∂Ë°åËÆ°ÁÆóÊó∂ÊÄßËÉΩÊõ¥Â•Ω‰∏Ä‰∫õ„ÄÇÂõ†‰∏∫ÂèØ‰ª•ÂáèÂ∞ëÂàÜÊîØÈ¢ÑÊµãÂ§±Ë¥•Â∏¶Êù•ÁöÑÊÄßËÉΩÊçüÂ§±
        */
        if (x1 <= x2) { if (x < x1 - eps || x > x2 + eps) return false; }
        else if (x < x2 - eps || x > x1 + eps) return false;
        if (y1 <= y2) { if (y < y1 - eps || y > y2 + eps) return false; }
        else if (y < y2 - eps || y > y1 + eps) return false;

        // ÂèâÁßØÂà§Êñ≠ÊòØÂê¶ÂÖ±Á∫ø
        return Math.abs((x2 - x1) * (y - y1) - (y2 - y1) * (x - x1)) <= eps;
    }
    function ptOnArc(p, c, r, a0, a1, aux, eps = EPSILON) {
        const dx = p[0] - c[0], dy = p[1] - c[1];

        // ÂÖàÁ°ÆËÆ§ÁÇπÂú®ÂúÜ‰∏ä
        if (Math.abs(dx * dx + dy * dy - r * r) > eps) return false;

        // Â¶ÇÊûúÊúâËæÖÂä©ÂèÇÊï∞ÔºåÂàô‰ΩøÁî®ËæÖÂä©ÂèÇÊï∞Êù•Âä†ÈÄüËÆ°ÁÆó
        if (aux) {
            const dx = p[0] - c[0], dy = p[1] - c[1];
            const cross = aux.ux * dy - aux.uy * dx; // u Âèâ p
            const dot = aux.ux * dx + aux.uy * dy;   // u ÁÇπ p

            // Ê£ÄÊü•ÁÇπÊòØÂê¶Âú®Ëµ∑ÁÇπÂíåÁªàÁÇπÁöÑÂêå‰æß
            if (aux.cUV >= 0) { // ÂèâÁßØ >= 0ÔºåËØ¥ÊòéÂºßÂ∫¶ <= 180 Â∫¶
                if (cross < -eps || cross > aux.cUV + eps) return false;
                if (dot < -eps || dot > aux.dUV + eps) return false;
            } else { // ÂèâÁßØ < 0ÔºåËØ¥ÊòéÂºßÂ∫¶ > 180 Â∫¶
                if (cross > eps && cross < aux.cUV - eps) return false;
                if (dot < -eps && dot > aux.dUV + eps) return false;
            }
            return true;
        }

        // ËÆ°ÁÆóÁÇπÁõ∏ÂØπ‰∫éÂúÜÂøÉÁöÑËßíÂ∫¶
        let a = Math.atan2(dy, dx); if (a < 0) a += PI2;

        // Âà§Êñ≠ËßíÂ∫¶ÊòØÂê¶Âú®ÂºßÁöÑËåÉÂõ¥ÂÜÖ
        if ((a0 = normRad(a0)) <= (a1 = normRad(a1)))
            return a >= a0 - eps && a <= a1 + eps;
        return a >= a0 - eps || a <= a1 + eps;
    }
    function ptOnPolygon(p, ps, eps = EPSILON) {
        const n = ps.length-1; console.assert(ps && n > 0);
        let i = 0; while (i < n) {
            if (ptOnSeg(p, ps[i], ps[++i], eps)) return true;
        }
        return ptOnSeg(p, ps[n], ps[0], eps);
    }
    function ptOnEase(p, p1, p2, amp, func, aux, eps = EPSILON, samples = 100) {
        // todo Ê†πÊçÆÁ≤æÂ∫¶Êù•Ë∞ÉËØïÊòØÂê¶‰ΩøÁî® refineÔºåÊàñËÄÖÁõ¥Êé•Áî®‰∫åÂàÜÊù•ÈÄºËøëÁ≤æÂ∫¶
        // Âè¶Â§ñÔºåsamples ÂèØ‰ª•‰ΩøÁî®ÂÖÉÁ¥†ÁºìÂ≠òÁöÑ points ÁöÑÂ±ûÊÄßÁöÑÊï∞Èáè
        let form = p1;
        for (let i = 1; i <= samples; ++i) {
            const t = i / samples, to = func(t, p1, p2, amp, aux);
            if (ptOnSeg(p, form, to, eps)) return true;
            form = to;
        }
        return false;
    }
    function ptOnBezier(p, cs, eps = EPSILON, samples = 100) {
        let form = bezier(0, cs);
        for (let i = 1; i <= samples; i++) {
            const to = bezier(i / samples, cs);
            if (ptOnSeg(p, form, to, eps)) return true;
            form = to;
        }
        return false;
    }
    function ptOnLine(p, p1, p2, eps = EPSILON) {
        console.assert(!sameOfPoints(p1, p2)); // ‰∏çÊîØÊåÅÈÄÄÂåñ‰∏∫ÁÇπÁöÑÊÉÖÂÜµÔºàÊ≠§Êó∂ÁÇπÁßØËÇØÂÆö‰∏∫ 0ÔºåÂà§Êñ≠Êó†ÊïàÔºâ
        // Âà§Êñ≠ÊñπÊ≥ïÔºö
        /* 1. ‰∏âÁÇπÂÖ±Á∫øÔºàÂêëÈáèÂèâÁßØ‰∏∫0ÔºâÔºöÊÄßËÉΩÊúÄÂø´: 4 Ê¨°‰πòÂä†
         |    ÂêëÈáè p1->p2 (x2-x1, y2-y1) ÂíåÂêëÈáè p1->p (x-x1, y-y1) => (x2-x1) * (y-y1) - (y2-y1) * (x-x1) = 0
         | 2. Ëß£ÊûêÂ∏¶ÂÖ•: 6 Ê¨°‰πòÂä†;
         |    slopeOfPoints * x + interceptOfPoints - y = 0
         | 3. Ë∑ùÁ¶ª‰∏∫ 0Ôºö ÊÄßËÉΩÊúÄÂ∑Æ: 6 Ê¨°‰πòÂä† + Èô§Ê≥ï + ÂºÄÊñπ
         |    distanceFromPointToLine = 0
         */
        return Math.abs((p2[0] - p1[0]) * (p[1] - p1[1]) - (p2[1] - p1[1]) * (p[0] - p1[0])) <= eps;
    }
    function ptOnFunction(p, expr, eps = EPSILON) {
        try {
            const y = expr(p[0]);
            return Math.abs(p[1] - y) <= eps;
        }
        catch (e) { return false; }
    }

    // ------------------ Âà§Êñ≠ÁÇπÂíåÂõæÂΩ¢ÁöÑÁõ∏ÂØπÂÖ≥Á≥ª ------------------
    /* + ÂÖ≥‰∫é"ÂÜÖÈÉ®"ÁöÑÂÆö‰πâ
     |   > Âá†‰Ωï‰∏äÔºåËã•ÁªèËøáÊüê‰∏™ÁÇπÁöÑÊâÄÊúâÊñπÂêë‰∏≠ÔºåËá≥Â∞ëÂ≠òÂú®‰∏ÄÊù°Áõ¥Á∫øÁ©øËøáÂõæÂΩ¢Âå∫ÂüüÔºåÂπ∂‰∏éÂõæÂΩ¢Êúâ‰∏§‰∏™‰∫§ÁÇπÔºå‰∏îËøô‰∏§‰∏™‰∫§ÁÇπÂú®ÁªèËøáÁÇπÁöÑ‰∏§‰æßÔºåÈÇ£‰πàËØ•ÁÇπÂ∞±Âú®ÂõæÂΩ¢ÂÜÖÈÉ®
     | + ËøôÈáåÁöÑËøîÂõûÂÄºÊòØ‰∏Ä‰∏™‰∏âÂÖÉÁªÑ: [x, y, int]
     |   > x, y Ë°®Á§∫ÁÇπÂú®ÂõæÂΩ¢‰∏äÁöÑÊäïÂΩ±ÁÇπ
     |   > int Ë°®Á§∫ÁÇπÁõ∏ÂØπ‰∫éÂõæÂΩ¢ÁöÑ‰ΩçÁΩÆÔºö-1: ÂÜÖÈÉ®Ôºå0: ËæπÁïå‰∏äÔºå1: Â§ñÈÉ®
     */

    function ptBesideCircle(p, c, r, eps = EPSILON) {

        const cx = c[0], cy = c[1];
        const dx = p[0] - cx, dy = p[1] - cy;
        const d = Math.hypot(dx, dy);

        // Â¶ÇÊûúÂú®ÂúÜÂøÉÔºåËøîÂõûÂúÜ‰∏ä‰ªªÊÑèÁÇπ
        if (d === 0) return [cx + r, cy, -1];

        // ÂΩí‰∏ÄÂåñÂêéÁöÑÊñπÂêëÂêëÈáè‰πò‰ª•ÂçäÂæÑ
        let pp = [cx + (dx / d) * r, cy + (dy / d) * r];

        pp.push(Math.abs(d - r) <= eps ? 0 : d < r - eps ? -1 : 1);
        return pp;
    }
    function ptBesideRectangle(p, l, t, r, b, eps = EPSILON) {
        const x = p[0], y = p[1];

        // Âú®ËæπÁïå‰∏äÊàñÂÜÖÈÉ®
        if (x >= l - eps && x <= r + eps &&
            y >= b - eps && y <= t + eps) {

            const dl = x - l, dr = r - x, dt = t - y, db = y - b;

            const m = Math.min(dl, dr, dt, db);
            if (m === dl) return [l, y, dl <= eps ? 0 : -1];
            if (m === dr) return [r, y, dr <= eps ? 0 : -1];
            if (m === dt) return [x, t, dt <= eps ? 0 : -1];
            return [x, b, db <= eps ? 0 : -1];
        }

        if (x < l) {
            if (y > t + eps) return [l, t, 1];
            if (y < b - eps) return [l, b, 1];
            return [l, y, 1];
        }
        if (x > r) {
            if (y > t + eps) return [r, t, 1];
            if (y < b - eps) return [r, b, 1];
            return [r, y, 1];
        }
        if (y > t) return [x, t, 1];
        return [x, b, 1];
    }
    function ptBesideSeg(p, p1, p2, eps = EPSILON) {
        console.assert(!sameOfPoints(p1, p2));  // ‰∏çÊîØÊåÅÈÄÄÂåñ‰∏∫ÁÇπÁöÑÊÉÖÂÜµÔºàÊ≠§Êó∂ÁÇπÁßØËÇØÂÆö‰∏∫ 0ÔºåÂà§Êñ≠Êó†ÊïàÔºâ
        const x1 = p1[0], y1 = p1[1];
        const x12 = p2[0] - x1, y12 = p2[1] - y1;

        const dot = (p[0] - x1) * x12 + (p[1] - y1) * y12;
        if (dot < -eps) return [p1[0], p1[1], 1];

        let pp;
        if (dot <= 0) pp = [p[0], p[1]];
        else {
            const s = dot / (x12 * x12 + y12 * y12);
            if (s > 1+eps) return [p2[0], p2[1], 1];
            pp = s >= 1 ? [p2[0], p2[1]] : [x1 + s * x12, y1 + s * y12];
        }

        pp.push(distOfPoints(p, pp) <= eps ? 0 : 1);
        return pp;
    }
    function ptBesideArc(p, c, r, a0, a1, p1, p2, aux, eps = EPSILON) {
        const x = p[0], y = p[1];
        const cx = c[0], cy = c[1];
        const dx = x - cx, dy = y - cy, d2 = dx * dx + dy * dy;
        const r2 = aux ? aux.r2 : r * r;
        const eps2 = eps * eps;

        // Ëé∑ÂèñÂºßÁöÑÁ´ØÁÇπ
        let x1, y1, x2, y2;
        if (p1 && p2) {
            x1 = cx + r * Math.cos(a0); y1 = cy + r * Math.sin(a0);
            x2 = cx + r * Math.cos(a1); y2 = cy + r * Math.sin(a1);
            x1 = p1[0]; y1 = p1[1];
            x2 = p2[0]; y2 = p2[1];
        } else if (aux) {
            x1 = cx + r * aux.ux; y1 = cy + r * aux.uy;
            x2 = cx + r * aux.vx; y2 = cy + r * aux.vy;
        } else {
            x1 = cx + r * Math.cos(a0); y1 = cy + r * Math.sin(a0);
            x2 = cx + r * Math.cos(a1); y2 = cy + r * Math.sin(a1);
        }

        // ÁÇπÂú®Âº¶ÁöÑÁ´ØÁÇπ p1 ‰πã‰∏äÊàñ‰πãÂ§ñ
        const x12 = x2 - x1, y12 = y2 - y1;
        const dot = (x - x1) * x12 + (y - y1) * y12;
        if (dot <= 0) return [x1, y1, d2 - r2 < eps2 ? 0 : 1];

        // ÁÇπÂú®Âº¶ÁöÑÁ´ØÁÇπ p2 ‰πã‰∏äÊàñ‰πãÂ§ñ
        const s = dot / (x12 * x12 + y12 * y12);
        if (s >= 1) return [x2, y2, d2 - r2 < eps2 ? 0 : 1];

        // ÁÇπÂú®Âº¶ÁöÑ‰∏≠Èó¥ÈÉ®ÂàÜÁöÑÊäïÂΩ±
        let pp = [x1 + s * x12, y1 + s * y12];

        // Â¶ÇÊûú p Âú®Âº¶‰∏äÔºåÊàñ‰∏éÂúÜÂøÉÂú®Âº¶Âêå‰æßÔºàÂêå‰æßÁ¨¶Âè∑Áõ∏ÂêåÔºâ
        const pc = (x - x1)*(y2 - y1) - (y - y1)*(x2 - x1);         // p Âèâ AB
        const cc = (cx - x1)*(y2 - y1) - (cy - y1)*(x2 - x1);       // c Âèâ AB
        if (pc * cc >= -eps2) {
            pp.push(Math.abs(pc) <= eps ? 0 : 1);
            return pp;
        }

        // Ëé∑ÂèñÁÇπÂú®ÂúÜ‰∏äÁöÑÊäïÂΩ±
        const d = Math.sqrt(d2);
        let pp2 = [cx + (dx / d) * r, cy + (dy / d) * r];

        // ÁÇπÂú®ÂúÜ‰∏äÊàñÂúÜÂ§ñ
        x2 = d2 - r2;
        if (x2 >= -eps2) {
            pp2.push(x2 <= eps2 ? 0 : 1);
            return pp2;
        }
        x2 = r2 - d2;

        // ËÆ°ÁÆóÁÇπÂà∞Áõ¥Á∫øÊäïÂΩ±ÁÇπË∑ùÁ¶ª
        x1 = pp[0] - x; y1 = pp[1] - y;
        if ((x1 * x1 + y1 * y1) < x2) {
            pp2.push(-1);
            return pp2;
        }
        pp.push(-1);
        return pp;
    }
    function ptBesideConvexPolygon(p, ps, eps = EPSILON) {
        console.assert(ps.length > 2);

        const x = p[0], y = p[1];
        const n = ps.length;

        let md = Infinity;
        let projX = 0, projY = 0;
        let allInside = true;   // Âá∏Â§öËæπÂΩ¢Ôºå‰∏ÄÊó¶Ë¢´Âà§Êñ≠‰∏∫Â§ñÈÉ®ÔºåÂàô‰∏ÄÂÆöÊòØÂ§ñÈÉ®

        for (let i = 0; i < n; i++) {
            const [x1, y1] = ps[i];
            const [x2, y2] = ps[(i + 1) % n];
            const ex = x2 - x1, ey = y2 - y1;

            // ÁÇπÂà∞ËæπÁöÑÊäïÂΩ±ÂèÇÊï∞ s
            const dot = (x - x1) * ex + (y - y1) * ey;
            let s = dot / (ex * ex + ey * ey);
            s = Math.max(0, Math.min(1, s)); // clamp Âà∞ËæπÁïå‰∏ä

            // ÊäïÂΩ±ÁÇπ
            const px = x1 + s * ex;
            const py = y1 + s * ey;

            // ÂèâÁßØÂà§Êñ≠ÁÇπÊòØÂê¶Âú®ËæπÁöÑÂÜÖ‰æßÔºàÂâçÊèêÊòØÁÇπÊòØÈ°∫Êó∂ÈíàÔºâ
            const cross = (x - x1) * ey - (y - y1) * ex;
            if (Math.abs(cross) <= eps) return [px, py, 0]; // Âú®ËæπÁïå‰∏ä
            if (cross > 0) allInside = false;

            // Ë∑ùÁ¶ªÂπ≥Êñπ
            const dx = x - px, dy = y - py;
            const d = dx * dx + dy * dy;

            // Êõ¥Êñ∞ÊúÄÁü≠Ë∑ùÁ¶ª
            if (d < md) { md = d; projX = px; projY = py; }
        }

        return [projX, projY, allInside ? -1 : 1];
    }
    function ptBesidePolygon(p, ps, aux, eps = EPSILON) {
        return ptBesideConvexPolygon(p, aux ? aux.convex : convexHull(ps), eps);
    }
    function ptBesideEase(p, p1, p2, amp, func, aux, convex, eps = EPSILON) {
        if (!convex) convex = adaptiveConvexHull((t) => func(t, p1, p2, amp, aux));
        return ptBesideConvexPolygon(p, convex, eps);
    }
    function ptBesideBezier(p, cs, convex, eps = EPSILON) {
        if (!convex) convex = adaptiveConvexHull((t) => bezier(t, cs));
        return ptBesideConvexPolygon(p, convex, eps);
    }

    // ------------------ Â§ñÈÉ®ÁÇπ‰∏éÂõæÂΩ¢ËæπÁïåÁöÑÂ§πËßíËåÉÂõ¥ ------------------
    /* + Âç≥ÂíåÂèØËßÅËæπÁïåÔºàËΩÆÂªìÔºâÊâÄÂΩ¢ÊàêÁöÑÊâáÂΩ¢Âå∫ÂüüÁöÑËßíÂüü
    */

    function ptFaceCircle(p, c, r) {
        const dx = c[0] - p[0], dy = c[1] - p[1];
        const d = Math.sqrt(dx * dx + dy * dy);

        // ‰ªéËßÇÊµãÁÇπ p Âà∞ÂúÜÂøÉ c ÁöÑÊñπÂêëËßí
        const aPC = Math.atan2(dy, dx);
        // ÂàáÁ∫ø‰∏é pc ËøûÁ∫øÁöÑÂ§πËßí
        const aPT = Math.asin(r / d);

        // ËøîÂõû‰∏§Êù°ÂàáÁ∫øÁöÑÊñπÂêëËßíÔºà‰ª• pc ÁöÑËßÜËßíÁúãÔºâ
        return [(aPC + aPT) * R2D, (aPC - aPT) * R2D];
    }
    function ptFaceRectangle(p, l, t, r, b) {
        /* Ê†πÊçÆËßÇÊµãÁÇπ p Áõ∏ÂØπ‰∫éÁü©ÂΩ¢ÁöÑ‰ΩçÁΩÆÔºåÁõ¥Êé•Á°ÆÂÆö‰∏§‰∏™ÂàáÁÇπ
         | 8 ‰∏™Âå∫ÂüüÂàÜÂ∏ÉÔºö
         |     1  |  2  |  3
         |   -----|-----|-----
         |     4  | Áü©ÂΩ¢ |  5
         |   -----|-----|-----
         |     6  |  7  |  8
        */
        const [px, py] = p;

        let cornerL, cornerR;

        if (px < l) { // Â∑¶‰æßÂå∫Âüü (1, 4, 6)
            if (py > t) { // Âå∫Âüü 1: Â∑¶‰∏ä - Â∑¶‰∏ãËßíÂà∞Âè≥‰∏äËßí
                cornerR = [l, b]; cornerL = [r, t];
            } else if (py < b) { // Âå∫Âüü 6: Â∑¶‰∏ã - Âè≥‰∏ãËßíÂà∞Â∑¶‰∏äËßí
                cornerR = [r, b]; cornerL = [l, t];
            } else { // Âå∫Âüü 4: Ê≠£Â∑¶ - Â∑¶‰∏ãËßíÂà∞Â∑¶‰∏äËßí
                cornerR = [l, b]; cornerL = [l, t];
            }
        }
        else if (px > r) { // Âè≥‰æßÂå∫Âüü (3, 5, 8)
            if (py > t) { // Âå∫Âüü 3: Âè≥‰∏ä - Â∑¶‰∏äËßíÂà∞Âè≥‰∏ãËßí
                cornerR = [l, t]; cornerL = [r, b];
            } else if (py < b) { // Âå∫Âüü 8: Âè≥‰∏ã - Âè≥‰∏äËßíÂà∞Â∑¶‰∏ãËßí
                cornerR = [r, t]; cornerL = [l, b];
            } else { // Âå∫Âüü 5: Ê≠£Âè≥ - Âè≥‰∏äËßíÂà∞Âè≥‰∏ãËßí
                cornerR = [r, t]; cornerL = [r, b];
            }
        } else { // ‰∏≠Èó¥Âàó (2, 7)
            if (py > t) { // Âå∫Âüü 2: Ê≠£‰∏ä - Â∑¶‰∏äËßíÂà∞Âè≥‰∏äËßí
                cornerR = [l, t]; cornerL = [r, t];
            } else { // Âå∫Âüü 7: Ê≠£‰∏ã - Âè≥‰∏ãËßíÂà∞Â∑¶‰∏ãËßí
                cornerR = [r, b]; cornerL = [l, b];
            }
        }

        // ËøîÂõû‰∏§‰∏™ÂàáÁÇπÁöÑÊñπÂêëËßíÔºà‰ª• pc ÁöÑËßÜËßíÁúãÔºâ
        return [dirOfPoints(p, cornerL), dirOfPoints(p, cornerR)];
    }
    function ptFaceSeg(p, p1, p2) {

        const a1 = dirOfPoints(p, p1);
        const a2 = dirOfPoints(p, p2);

        // Âà§Êñ≠ p Âú®Á∫øÊÆµÁöÑÂì™‰∏Ä‰æßÔºàÂèâÁßØÔºâ
        // vCross(p, p1, p2) > 0: p Âú® p1‚Üíp2 ÁöÑÂ∑¶‰æßÔºåÈÄÜÊó∂ÈíàÈ°∫Â∫èÊòØ p1 ‚Üí p2
        // vCross(p, p1, p2) < 0: p Âú® p1‚Üíp2 ÁöÑÂè≥‰æßÔºåÈÄÜÊó∂ÈíàÈ°∫Â∫èÊòØ p2 ‚Üí p1
        if (vCross(p, p1, p2) >= 0) {
            return [a2, a1];
        } else {
            return [a1, a2];
        }
    }
    function ptFaceArc(p, c, r, a0, a1) {
        const norm = normRadS, cross = v2CrossAux;
        const [x, y] = p, [cx, cy] = c;
        const dx = x - cx, dy = y - cy;
        const d2 = dx * dx + dy * dy, d = Math.sqrt(d2);

        // ÂΩí‰∏ÄÂåñËæìÂÖ•ÁöÑÂºßËßíÂ∫¶ÔºåÁ°Æ‰øù‰∏éÂêéÁª≠ËÆ°ÁÆóÁöÑËßíÂ∫¶Âú®Âêå‰∏ÄËåÉÂõ¥ÂÜÖ
        a0 = norm(a0);
        a1 = norm(a1);

        const phi = Math.atan2(dy, dx); // œÜ: c -> p ÊñπÂêëËßí
        const theta = Math.asin(r / d); // Œ∏: p Âà∞ÂàáÁÇπÁöÑÂ§πËßíÔºàÁöÑ‰∏ÄÂçä)
        const gamma = Math.acos(r / d); // Œ≥: c Âà∞ÂàáÁÇπÁöÑÂ§πËßíÔºàÁöÑ‰∏ÄÂçä)

        // p Âà∞ÂàáÁÇπÁöÑÊñπÂêëËßí
        const rayTL = norm(phi + Math.PI + theta), rayTL_d = rayTL * R2D;
        const rayTR = norm(phi + Math.PI - theta), rayTR_d = rayTR * R2D;

        // c Âà∞ÂàáÁÇπÁöÑÊñπÂêëËßí
        // + ËøôÈáåÁöÑ L/R ÊòØ‰ª• pc ËßÜËßíÂÆö‰πâÁöÑÔºå‰ª• c ÁöÑËßÜËßíÁúãÂàôÁõ∏Âèç
        const tauL = norm(phi - gamma), tauL_d = tauL * R2D;
        const tauR = norm(phi + gamma), tauR_d = tauR * R2D;

        // Âà§Êñ≠ÂàáÁÇπÊòØÂê¶ÂëΩ‰∏≠ÂºßÊÆµ
        const hitL = inArc(tauL, a0, a1);
        const hitR = inArc(tauR, a0, a1);

        let rayL, rayR;
        if (hitL && hitR) { rayL = rayTL; rayR = rayTR; } // ‰∏§‰∏™ÂàáÁÇπÈÉΩÂú®Âºß‰∏ä
        else {

            // ÂºßÁ´ØÁÇπÂùêÊ†á
            const Ax = cx + r * Math.cos(a0), Ay = cy + r * Math.sin(a0);
            const Bx = cx + r * Math.cos(a1), By = cy + r * Math.sin(a1);

            // p Âà∞ÂºßÁ´ØÁÇπÁöÑÊñπÂêëËßí
            const rayA0 = norm(Math.atan2(Ay - y, Ax - x));
            const rayA1 = norm(Math.atan2(By - y, Bx - x));

            // Âº¶Á´ØÁÇπ A->B ÁöÑÂêëÈáè
            const vx = Bx - Ax, vy = By - Ay;
            // AP ‰∏é AB ÁöÑÂèâÁßØ
            const crossP = cross(Ax, Ay, vx, vy, x, y);

            // p Âú®Âº¶ÁöÑÂª∂ÈïøÁ∫ø‰∏äÔºåÂç≥ p ‰∏é‰∏§Á´ØÁÇπÂÖ±Á∫ø
            if (crossP === 0) rayL = rayR = rayA1;

            // P„ÄÅC Áõ∏ÂØπ AB Âêå‰æßÔºàÂç≥ AC ‰∏é AB ÁöÑÂèâÁßØÔºå‰∏é AP ‰∏é AB ÁöÑÂèâÁßØÁ¨¶Âè∑Áõ∏ÂêåÔºâ
            else if (cross(Ax, Ay, vx, vy, cx, cy) * crossP > 0) {

                if (isMajorArc(a0, a1)) { // ÂØπ‰∫éÂ§ßÂºß
                    rayL = rayA0; rayR = rayA1;
                } else {
                    rayL = rayA1; rayR = rayA0;
                }
            } else if (isMajorArc(a0, a1)) {
                rayL = rayA1; rayR = rayA0;
            } else {
                rayL = rayA0; rayR = rayA1;
            }

            // Â¶ÇÊûúÂàáÁÇπÂú®Âºß‰∏äÔºåÁî®ÂàáÁÇπË¶ÜÁõñÁõ∏Â∫îÁöÑËæπÁïå
            if (hitL) rayL = rayTL;
            if (hitR) rayR = rayTR;
        }

        // ËøîÂõû‰∏§‰∏™ÂàáÁÇπÁöÑÊñπÂêëËßíÔºà‰ª• pc ÁöÑËßÜËßíÁúãÔºâ
        // + Ê≥®ÊÑèÔºåËøôÈáå‰∏çËÉΩ assert(rayL <= rayR)
        //   Âõ†‰∏∫ÔºåÂΩìËßíÂ∫¶Ë∑®Ë∂ä ¬±œÄ ËæπÁïåÊó∂ÔºårayL ÂèØËÉΩÂ§ß‰∫é rayRÔºà‰æãÂ¶Ç rayL=170¬∞, rayR=-170¬∞Ôºâ
        return [rayL * R2D, rayR * R2D];
    }
    function ptFaceConvexPolygon(p, c, convex, PA = 3) {
    // „ÄêÂàáÁÇπÂÆö‰πâ„Äë‰ªéËßÇÂØüÁÇπ p ÁúãÂêëÂá∏ÂåÖ cÔºö
    //   - CCWÂàáÁÇπ(r)Ôºöp ÁöÑÂ∑¶ÊâãÊñπÂêë = ÈÄÜÊó∂ÈíàÊúÄËøúÂèØËßÅÁÇπ = ËßíÂ∫¶ËæÉÂ§ß (thetaRight)
    //   - CWÂàáÁÇπ(l)Ôºöp ÁöÑÂè≥ÊâãÊñπÂêë = È°∫Êó∂ÈíàÊúÄËøúÂèØËßÅÁÇπ = ËßíÂ∫¶ËæÉÂ∞è (thetaLeft)
    //   Ê≠£Â∏∏ÊÉÖÂÜµ‰∏ã thetaLeft < thetaRight
    //   ËøîÂõû [thetaLeft, thetaRight, l, r] = [CWËßíÂ∫¶, CCWËßíÂ∫¶, CWÂàáÁÇπÁ¥¢Âºï, CCWÂàáÁÇπÁ¥¢Âºï]
        console.assert(convex.length > 2);
        const ICCW = PA + 1, ICW = PA + 2;
        const n = convex.length;

        const [px, py] = p;
        const [cx, cy] = c;

        // ÈÄöËøáÁÇπ c Âà∞ p ÁöÑÊñπÂêëËßíÂ∫¶Ôºå‰∫åÂàÜÊü•Êâæ pc Á©øËøáÁöÑËæπÁ∫øÊÆµÁöÑËµ∑ÁÇπÁ¥¢Âºï
        let l = binarySearchPoleAngle(convex, Math.atan2(py - cy, px - cx), PA), r = (l + 1) % n;  // ËæπÁöÑÁªàÁÇπ

        // CCWÂàáÁÇπÔºö‰ªé p ÁúãÂêë c ÁöÑÂ∑¶ÊâãÊñπÂêëÔºàÈÄÜÊó∂ÈíàÊúÄËøúÂèØËßÅÁÇπÔºåËßíÂ∫¶ËæÉÂ§ßÔºâ
        // ‰ΩøÁî® inv+ (ICCW) Á¥¢ÂºïÂêëÂè≥ÔºàÈ°∫Êó∂ÈíàÔºâÊêúÁ¥¢
        (function findCCW() {

            // ËØªÂèñ inv+ (ICCW) Á¥¢ÂºïÔºöÈÄÜÊó∂ÈíàÊñπÂêëÁ¨¨‰∏Ä‰∏™‰∏çÂèØËßÅÁöÑÁÇπÔºåÂàáÁÇπÂú® (r, invCCW] Âå∫Èó¥ÂÜÖ
            const invCCW = convex[r][ICCW]; console.assert(invCCW >= 0 && invCCW < n && invCCW !== r);

            // ËÆ°ÁÆóÂå∫Èó¥Â§ßÂ∞è
            const dist = (invCCW - r + n) % n;

            // Âå∫Èó¥Âè™Êúâ‰∏Ä‰∏™ÁÇπÔºàr Êú¨Ë∫´ÔºâÔºår Â∞±ÊòØÂàáÁÇπ
            if (dist === 1) {
                return;
            }

            const next0 = (r + 1) % n;
            // CCWÂàáÁÇπÊù°‰ª∂Ôºönext Âú®Â∞ÑÁ∫ø p‚Üír ÁöÑÂ∑¶‰æßÊàñÂÖ±Á∫ø
            // vCross(p, r, next) >= 0 Ë°®Á§∫ next Âú® p‚Üír Â∑¶‰æß
            const cross = vCross(p, convex[r], convex[next0]);
            if (cross >= 0) {
                return;
            }

            // Âú® (r, invCCW] Âå∫Èó¥‰∫åÂàÜÊü•ÊâæÂàáÁÇπÔºàÊéíÈô§ rÔºâ
            let lo = 1, hi = dist, best = dist;
            while (lo <= hi) {
                const mid = (lo + hi) >> 1;
                const idx = (r + mid) % n;
                const nextIdx = (idx + 1) % n;
                const crossMid = vCross(p, convex[idx], convex[nextIdx]);
                // CCWÂàáÁÇπÊù°‰ª∂ÔºönextIdx Âú® p‚Üíidx Âè≥‰æßÔºàÂÜÖ‰æßÔºâ
                // Â¶ÇÊûú nextIdx Âú®Â∑¶‰æßÔºàÂ§ñ‰æßÔºâÔºåËØ¥Êòé idx Ëøò‰∏çÊòØCCWÂàáÁÇπÔºåÂèØ‰ª•ÁªßÁª≠ÂêëÂè≥ÊêúÁ¥¢
                if (crossMid < 0) {
                    lo = mid + 1;
                }
                // idx ÊòØÂàáÁÇπÊàñÂ∑≤ËøáÂàáÁÇπÔºåËÆ∞ÂΩïbestÂπ∂ÂêëÂ∑¶Êî∂Áº©
                else {
                    best = mid;
                    hi = mid - 1;
                }
            }
            r = (r + best) % n;
        })();

        // CWÂàáÁÇπÔºö‰ªé p ÁúãÂêë c ÁöÑÂè≥ÊâãÊñπÂêëÔºàÈ°∫Êó∂ÈíàÊúÄËøúÂèØËßÅÁÇπÔºåËßíÂ∫¶ËæÉÂ∞èÔºâ
        // ‰ΩøÁî® inv- (ICW) Á¥¢ÂºïÂêëÂ∑¶ÔºàÈÄÜÊó∂ÈíàÔºâÊêúÁ¥¢
        (function findCW() {

            // ËØªÂèñ inv- (ICW) Á¥¢ÂºïÔºöÈ°∫Êó∂ÈíàÊñπÂêëÁ¨¨‰∏Ä‰∏™‰∏çÂèØËßÅÁöÑÁÇπÔºåÂàáÁÇπÂú® (invCW, l] Âå∫Èó¥ÂÜÖ
            const invCW = convex[l][ICW]; console.assert(invCW >= 0 && invCW < n && invCW !== l);

            // ËÆ°ÁÆóÂå∫Èó¥Â§ßÂ∞è
            const distL = (l - invCW + n) % n;

            // Âå∫Èó¥Âè™Êúâ‰∏Ä‰∏™ÁÇπÔºàl Êú¨Ë∫´ÔºâÔºål Â∞±ÊòØÂàáÁÇπ
            if (distL === 1) {
                return;
            }

            const prev0 = (l - 1 + n) % n;
            // CWÂàáÁÇπÊù°‰ª∂ÔºöprevÔºàÈÄÜÊó∂ÈíàÊñπÂêëÁöÑÂâç‰∏Ä‰∏™È°∂ÁÇπÔºâÂú®Â∞ÑÁ∫ø p‚Üíl ÁöÑÂè≥‰æßÊàñÂÖ±Á∫ø
            // vCross(p, l, prev) <= 0 Ë°®Á§∫ prev Âú® p‚Üíl Âè≥‰æß
            const cross = vCross(p, convex[l], convex[prev0]);
            if (cross <= 0) {
                return;
            }

            // Âú® (invCW, l] Âå∫Èó¥‰∫åÂàÜÊü•ÊâæÂàáÁÇπÔºàÊéíÈô§ lÔºâ
            let lo = 1, hi = distL, best = distL;
            while (lo <= hi) {
                const mid = (lo + hi) >> 1;
                const idx = (l - mid + n) % n;
                const prevIdx = (idx - 1 + n) % n;
                const crossMid = vCross(p, convex[idx], convex[prevIdx]);
                // CWÂàáÁÇπÊù°‰ª∂ÔºöprevIdxÔºàÈÄÜÊó∂ÈíàÊñπÂêëÂâç‰∏Ä‰∏™ÔºâÂú® p‚Üíidx Âè≥‰æßÔºàÂÜÖ‰æßÔºâ
                // Â¶ÇÊûú prevIdx Âú®Â∑¶‰æßÔºàÂ§ñ‰æßÔºâÔºåËØ¥Êòé idx Ëøò‰∏çÊòØCWÂàáÁÇπÔºåÂèØ‰ª•ÁªßÁª≠ÂêëÂ∑¶ÊêúÁ¥¢
                if (crossMid > 0) {
                    lo = mid + 1;
                }
                // idx ÊòØÂàáÁÇπÊàñÂ∑≤ËøáÂàáÁÇπÔºåËÆ∞ÂΩïbestÂπ∂ÂêëÂè≥Êî∂Áº©
                else {
                    best = mid;
                    hi = mid - 1;
                }
            }
            l = (l - best + n) % n;
        })();

        // ËÆ°ÁÆó‰ªéËßÇÊµãÁÇπÂà∞ÂàáÁÇπÁöÑËßíÂ∫¶
        const leftVec = [convex[l][0] - px, convex[l][1] - py];
        const rightVec = [convex[r][0] - px, convex[r][1] - py];

        let thetaLeft = Math.atan2(leftVec[1], leftVec[0]);
        let thetaRight = Math.atan2(rightVec[1], rightVec[0]);

        // ËßÑËåÉÂåñËßíÂ∫¶Âà∞ [0, 2œÄ)
        if (thetaLeft < 0) thetaLeft += 2 * Math.PI;
        if (thetaRight < 0) thetaRight += 2 * Math.PI;

        // ËÆ°ÁÆóÂèØËßÅÊâáÂΩ¢ËßíÂ∫¶Ôºà‰ªé CW ÂàáÁÇπÈÄÜÊó∂ÈíàÂà∞ CCW ÂàáÁÇπÔºâ
        let delta = thetaRight - thetaLeft;
        if (delta < 0) delta += 2 * Math.PI;

        return [thetaLeft * R2D, thetaRight * R2D];
    }
    function ptFacePolygon(p, c, convex) {
        return ptFaceConvexPolygon(p, c, convex);
    }
    function ptFaceEase(p, c, convex) {
        return ptFaceConvexPolygon(p, c, convex);
    }
    function ptFaceBezier(p, c, convex) {
        return ptFaceConvexPolygon(p, c, convex);
    }

</script>

<script>

/* ================================ */
/* ÂÖ®Â±ÄÂ∏∏ÈáèÂíåÂíåÈòàÂÄºÈÖçÁΩÆ */
/* ================================ */

// ===== Êï∞ÊçÆÁ±ªÂûãÂÆö‰πâ =====

// Êï∞ÊçÆÁ±ªÂûãÈÖçÁΩÆ
const DATA_TYPES = {
    S: 0,                               // Â≠óÁ¨¶‰∏≤
    C: 1,                               // È¢úËâ≤ÂÄº
    B: 2,                               // Â∏ÉÂ∞îÂÄº
    I: 3,                               // Êï¥Êï∞
    F: 4,                               // ÈªòËÆ§ÊµÆÁÇπÊï∞ÔºåÁî± DECIMAL_PRECISION_DEFAULT ÂÆö‰πâ
    F1: 5,                              // ÊµÆÁÇπÊï∞Ôºå1‰ΩçÂ∞èÊï∞
    F2: 6,                              // ÊµÆÁÇπÊï∞Ôºå2‰ΩçÂ∞èÊï∞
    F3: 7,                              // ÊµÆÁÇπÊï∞Ôºå3‰ΩçÂ∞èÊï∞
    F4: 8,                              // ÊµÆÁÇπÊï∞Ôºå4‰ΩçÂ∞èÊï∞
};

// È¢úËâ≤Ëß£ÊûêÂáΩÊï∞ - Â∞ÜËá™Âä®Ëâ≤ËΩ¨Êç¢‰∏∫ÂÆûÈôÖÈ¢úËâ≤
const AUTO_COLOR = 'auto';              // Ëá™Âä®Ëâ≤Ê†áËØÜ
function resolveColor(color) {
    if (color === AUTO_COLOR) {
        return THEME ? '#ffffff' : '#333333'; // ÈªëÂ§úÊ®°Âºè‰∏∫ÁôΩËâ≤ÔºåÊµÖËâ≤Ê®°Âºè‰∏∫Ê∑±ÁÅ∞Ëâ≤
    }
    return color;
}

// ===== ‰∫§‰∫íÂ∏∏Èáè =====

const DOUBLE_CLICK_DELAY = 300;         // ÂèåÂáªÈó¥ÈöîÊó∂Èó¥ÔºàÊØ´ÁßíÔºâ
const DOUBLE_CLICK_THRESHOLD = 3;       // ÂèåÂáª‰ΩçÁΩÆÂÆπÂ∑ÆÔºàÂÉèÁ¥†Ôºâ

const CTRL_ALT_HOLD_DELAY = 800;        // Ctrl+Alt ÈïøÊåâËß¶ÂèëÊó∂Èó¥ÔºàÊØ´ÁßíÔºâ

const DECIMAL_PRECISION_DEFAULT = 2;    // ÈªòËÆ§Â∞èÊï∞Á≤æÂ∫¶Ôºà2‰ΩçÔºâ
const DECIMAL_PRECISION_ANGLE = 1;      // ËßíÂ∫¶Â∞èÊï∞Á≤æÂ∫¶Ôºà1‰ΩçÔºâ

// ===== ÂùêÊ†áÁ≥ªÂ∏∏Èáè =====

const UNIT_SIZE = 10;                   // Âçï‰Ωç(1) Èó¥ÈöîÔºàÂÉèÁ¥†Ôºâ
const MIN_SCALE = 0.1;                  // ÊúÄÂ∞èÁº©ÊîæÂÄçÊï∞
const MAX_SCALE = 5.0;                  // ÊúÄÂ§ßÁº©ÊîæÂÄçÊï∞
const COORDINATE_STATES = {
    INITIAL: 'initial',                 // ÂàùÂßãÁä∂ÊÄÅÔºàÂéüÁÇπÂú®Â∑¶‰∏ãËßíÔºâ
    BOTTOM_CENTER: 'bottom_center',     // ÂéüÁÇπÂú®Â±èÂπï‰∏ãÊñπ‰∏≠Èó¥
    CENTERED: 'centered'                // ÂéüÁÇπÂ±Ö‰∏≠Áä∂ÊÄÅ
};

// ÂùêÊ†áÁ≥ªÂàùÂßã‰ΩçÁΩÆ
const INITIAL_OFFSET_X = UNIT_SIZE * 2; // ÂàùÂßãXÂÅèÁßª
const INITIAL_OFFSET_Y = -UNIT_SIZE * 2;// ÂàùÂßãYÂÅèÁßª

// ËôöÊãüÂùêÊ†áËΩ¥Ê®°Âºè
const VIRTUAL_AXIS_MODE = {
    SEAMLESS: 'seamless',               // Êó†ÁºùÂàáÊç¢Ê®°ÂºèÔºöÁúüÂÆûËΩ¥Âà∞ËææËôöÊãü‰ΩçÁΩÆÊó∂Á´ãÂç≥ÂàáÊç¢
    VIEWPORT: 'viewport'                // ËßÜÂè£ËæπÁºòÊ®°ÂºèÔºöÁúüÂÆûËΩ¥ÂÆåÂÖ®ÁßªÂá∫ËßÜÂè£ÂêéÊâçÊòæÁ§∫ËôöÊãüËΩ¥
};
const CURRENT_VIRTUAL_AXIS_MODE = VIRTUAL_AXIS_MODE.SEAMLESS; // ÂΩìÂâç‰ΩøÁî®ÁöÑËôöÊãüÂùêÊ†áËΩ¥Ê®°Âºè

// ËôöÊãüÂùêÊ†áËΩ¥Á∫øÂûã
const VIRTUAL_AXIS_LINE_STYLE = {
    SOLID: 'solid',                     // ÂÆûÁ∫ø
    DASHED: 'dashed'                    // ËôöÁ∫ø
};
const CURRENT_VIRTUAL_AXIS_LINE_STYLE = VIRTUAL_AXIS_LINE_STYLE.SOLID; // ÂΩìÂâç‰ΩøÁî®ÁöÑËôöÊãüÂùêÊ†áËΩ¥Á∫øÂûã

// ===== ÁÇπÂÖÉÁ¥†ËßÜËßâËÆæÁΩÆ =====

const POINT_DEFAULT_SIZE = 2;           // ÁÇπÁöÑÈªòËÆ§Â§ßÂ∞è
const POINT_STYLES = {
    CIRCLE: 'circle',                   // ÂúÜÂΩ¢ÁÇπ
    SQUARE: 'square'                    // ÊñπÂΩ¢ÁÇπ
};
const POINT_DEFAULT_STYLE = POINT_STYLES.CIRCLE; // ÈªòËÆ§ÁÇπÊ†∑Âºè

const OBSERVE_POINT_HIT_RADIUS = 12;    // ËßÇÊµãÁÇπÁÇπÂáªÊ£ÄÊµãÂçäÂæÑÔºàÂÉèÁ¥†Ôºâ

// ===== ÂÖàÂÖÉÁ¥†ËßÜËßâËÆæÁΩÆ =====

const DEFAULT_LINE_WIDTH = 2;
const DEFAULT_LINE_COLOR = AUTO_COLOR;  // ÈªòËÆ§‰ΩøÁî®Ëá™Âä®Ëâ≤

const LINE_AVAILABLE_COLORS = [
    AUTO_COLOR, // Ëá™Âä®Ëâ≤ÔºàÈªòËÆ§Ôºâ
    '#ff0000', '#00ff00', '#0000ff', '#ff8800', '#800080',
    '#ff1493', '#00ced1', '#32cd32', '#ffd700', '#ff6347',
    '#9370db', '#20b2aa', '#f0e68c', '#dda0dd', '#87ceeb',
    '#cccccc', '#333333', '#000000'  // ÊµÖÁÅ∞„ÄÅÊ∑±ÁÅ∞„ÄÅÈªëËâ≤
];

// È´ò‰∫ÆÊïàÊûúÈÖçÁΩÆ
const HIGHLIGHT_COLOR = '#3498db';
const HIGHLIGHT_SHADOW_BLUR = 2;        // shadowBlur = HIGHLIGHT_SHADOW_BLUR / scale
const HIGHLIGHT_LINE_WIDTH_FACTOR = 1.0; // Á∫øÂÆΩÊîæÂ§ßÂÄçÊï∞
const HIGHLIGHT_LINE_WIDTH_MIN = 2;     // ÊúÄÂ∞èÁ∫øÂÆΩ

/* ================================ */
/* ÂÖ®Â±ÄÁä∂ÊÄÅÂèòÈáè */
/* ================================ */

// ÁªòÂà∂ÂÖÉÁ¥†Áõ∏ÂÖ≥ÂèòÈáè
const ElementTypes = {
    POINT: 0,                   // ÁÇπÂÖÉÁ¥†
    CIRCLE: 1,                  // ÂúÜÂΩ¢ÂÖÉÁ¥†
    RECTANGLE: 2,               // Áü©ÂΩ¢ÂÖÉÁ¥†
    SEG: 3,                     // Á∫øÊÆµÂÖÉÁ¥†
    ARC: 4,                     // ÂºßÁ∫øÂÖÉÁ¥†
    POLYGON: 5,                 // Â§öËæπÂΩ¢ÂÖÉÁ¥†
    EASE: 6,                    // easeÊõ≤Á∫øÂÖÉÁ¥†
    BEZIER: 7,                  // Ë¥ùÂ°ûÂ∞îÊõ≤Á∫øÂÖÉÁ¥†
    FUNCTION: 8                 // ÂáΩÊï∞ÂõæÂÉèÂÖÉÁ¥†
};
const ElementTypesText = [
    ['ÁÇπ', 'Point'],
    ['ÂúÜ', 'Circle'],
    ['Áü©ÂΩ¢', 'Rectangle'],
    ['Á∫øÊÆµ', 'Segment'],
    ['ÂºßÁ∫ø', 'Arc'],
    ['Â§öËæπÂΩ¢', 'Polygon'],
    ['easeÊõ≤Á∫ø', 'Ease Curve'],
    ['Ë¥ùÂ°ûÂ∞îÊõ≤Á∫ø', 'Bezier Curve'],
    ['ÂáΩÊï∞', 'Function']
];
function getElementTypeText(type, lang = LANG) {
    return ElementTypesText[type][lang] || Object.keys(ElementTypes).find(k => ElementTypes[k] === type) || type;
}
const FeatureTypes = {
    SYMMETRIC: 0,                       // ÂØπÁß∞ÁÇπ
    HYPER: 1,                           // Ë∂ÖÁÇπ
    START: 2,                           // Ëµ∑ÁÇπ
    END: 3,                             // ÁªàÁÇπ
    INFLECTION: 4,                      // ÊãêÁÇπÔºàÊõ≤ÁéáÂèòÂåñÁÇπÔºå‰∫åÈò∂ÂØºÊï∞‰∏∫ 0 ÁÇπÔºâ
    SINGULARITY: 5,                     // Â•áÂºÇÁÇπÔºàÂûÇÁõ¥„ÄÅÔºåÂØºÊï∞‰∏çÂ≠òÂú®ÁÇπÔºâ
    CORNER: 6,                          // ËßíÁÇπÔºà‰∏çÂèØÂØºÔºåÂáÜÁ°ÆËØ¥ÊòØÂ∑¶Âè≥ÂØºÊï∞‰∏çÂêåÔºâ
};
const FeatureTypesText = [
    ['ÂØπÁß∞ÁÇπ', 'Symmetric'],
    ['Ë∂ÖÁÇπ', 'Hyper'],
    ['Ëµ∑ÁÇπ', 'Start'],
    ['ÁªàÁÇπ', 'End'],
    ['ÊãêÁÇπ', 'Inflection'],
    ['Â•áÂºÇÁÇπ', 'Singularity'],
    ['ËßíÁÇπ', 'Corner']
];
// ÁâπÂæÅÁÇπÈ¢úËâ≤Êï∞ÁªÑÔºàÊåâ FeatureTypes Á¥¢ÂºïÔºâ
const FeatureColors = [
    '#ff4444',    // 0: SYMMETRIC - Á∫¢Ëâ≤ÔºöÂØπÁß∞ÁÇπ
    '#ff4444',    // 1: HYPER - Á∫¢Ëâ≤ÔºöË∂ÖÁÇπ
    '#ff4444',    // 2: START - Á∫¢Ëâ≤ÔºöËµ∑ÁÇπ
    '#ff4444',    // 3: END - Á∫¢Ëâ≤ÔºöÁªàÁÇπ
    '#44ff44',    // 4: INFLECTION - ÁªøËâ≤ÔºöÊãêÁÇπ
    '#ffff44',    // 5: SINGULARITY - ÈªÑËâ≤ÔºöÂ•áÂºÇÁÇπ
    '#ff4444',    // 6: CORNER - Á∫¢Ëâ≤ÔºöËßíÁÇπ
];

function Point(p, size = POINT_DEFAULT_SIZE, style = POINT_DEFAULT_STYLE) {
    return { coords:p, size, style }
}
function Circle(center, p) {
    const radius = Math.hypot(p[0] - center[0], p[1] - center[1]);
    center.push(/* area */Math.PI * radius * radius);
    return { radius, aux: circleAux(radius),
        centroid: center,
        box: boxOfCircle(center, radius)
    };
}
function CircleRebuild(props) {
    const { radius, aux, centroid } = props;
    circleAux(radius, aux);
    centroid[2] = Math.PI * radius * radius;
    boxOfCircle(centroid, radius, props.box);
}
function Rectangle(x1, y1, x2, y2) {
    let l, r, t, b;
    if (x1 < x2) {
        if (y1 < y2) { l = x1; r = x2; t = y2; b = y1; }
        else { l = x1; r = x2; t = y1; b = y2; }
    } else if (y1 < y2) { l = x2; r = x1; t = y2; b = y1; }
    else { l = x2; r = x1; t = y1; b = y2; }
    return {
        ft: [[l, t, FeatureTypes.CORNER], [r, t, FeatureTypes.CORNER],
            [r, b, FeatureTypes.CORNER], [l, b, FeatureTypes.CORNER]],
        aux: rectAux(l, t, r, b),
        centroid: centroidOfRectangle(l, t, r, b),
        box: [(l+r)/2, (t+b)/2, l, t, r, b]
    };
}
function RectangleRebuild(props) {
    const { ft, aux, box, centroid } = props;
    rectAux(box[2], box[3], box[4], box[5], aux);
    box[0] = (box[2] + box[4]) / 2;
    box[1] = (box[3] + box[5]) / 2;
    centroidOfRectangle(box[2], box[3], box[4], box[5], centroid);
    ft[0][0] = box[2]; ft[0][1] = box[3];
    ft[1][0] = box[4]; ft[1][1] = box[3];
    ft[2][0] = box[4]; ft[2][1] = box[5];
    ft[3][0] = box[2]; ft[3][1] = box[5];
}
function Seg(p1, p2) { p1.push(FeatureTypes.START); p2.push(FeatureTypes.END);
    return { ft:[p1, p2], aux: segAux(p1, p2),
        centroid: centroidOfSeg(p1, p2),
        box: boxOfSeg(p1, p2)
    };
}
function SegRebuild(props) {
    const { ft, aux, box, centroid } = props;
    segAux(ft[0], ft[1], aux);
    boxOfSeg(ft[0], ft[1], box);
    centroidOfSeg(ft[0], ft[1], centroid);
}
function Arc(center, radius, p1, p2) {

    let startRad = Math.atan2(p1[1] - center[1], p1[0] - center[0]); if (startRad < 0) startRad += PI2;
    let endRad = Math.atan2(p2[1] - center[1], p2[0] - center[0]); if (endRad < 0) endRad += PI2;
    if (endRad < startRad) startRad -= PI2;

    center.push(FeatureTypes.HYPER);
    p1.push(FeatureTypes.START);
    // Ê≥®ÊÑèËøôÈáåÁöÑ p2 ‰∏çÊòØÂºßÁ∫øÁöÑÁ´ØÁÇπÔºåËÄåÊòØÂºßÁ∫øÁöÑËæÖÂä©ÊéßÂà∂ÁÇπ
    p2 = [center[0] + radius * Math.cos(endRad), center[1] + radius * Math.sin(endRad), FeatureTypes.END];
    const midAngle = (startRad + endRad) / 2;
    const midPoint = [
        center[0] + radius * Math.cos(midAngle),
        center[1] + radius * Math.sin(midAngle),
        FeatureTypes.SYMMETRIC
    ];
    return { ft: [center, p1, p2, midPoint], radius, startRad, endRad, aux: arcAux(radius, startRad, endRad),
        centroid: centroidOfArc(center, radius, startRad, endRad),
        box: boxOfArc(center, radius, startRad, endRad)
    };
}
function ArcRebuild(props) {
    const { ft, radius, startRad, endRad, aux, box, centroid } = props;
    arcAux(radius, startRad, endRad, aux);
    centroidOfArc(ft[0], radius, startRad, endRad, centroid);
    boxOfArc(ft[0], radius, startRad, endRad, box);
}
function Polygon(points, closed) {
    console.assert(points.length >= 3);
    const l = points.length - 1;
    points[0].push(FeatureTypes.START); points[l].push(FeatureTypes.END);
    for (let i = 1; i < l; i++) points[i].push(FeatureTypes.CORNER);
    const centroid = centroidOfPolygon(points);
    return { ft: points, closed,
        centroid: centroid,
        box: boxOfPolygon(points),
        convex: poleAngles(convexHull(points), centroid, true)
    };
}
function PolygonRebuild(props) {
    const { ft, box, centroid } = props;
    centroidOfPolygon(ft, centroid);
    boxOfPolygon(ft, box);
    props.convex = poleAngles(convexHull(ft), centroid, true);
}
function Ease(p1, p2, type, proc, amp = 0.4) {
    const func = ease[type + proc], aux = distAux(p1, p2);
    const points = pixelEval((t) => func(t, p1, p2, amp, aux), false);
    p1.push(FeatureTypes.START); p2.push(FeatureTypes.END);
    const centroid = centroidOfEase(p1, p2, amp, func, aux);
    return { ft: [p1, p2], type, proc, amp, func, aux,
        centroid: centroid,
        box: boxOfEase(p1, p2, amp, func, aux),
        points, convex: poleAngles(convexHull(points), centroid, true)
    };
}
function EaseRebuild(props) {
    const { ft, type, proc, amp, aux, box, centroid } = props;
    props.func = ease[type + proc];
    distAux(ft[0], ft[1], aux);
    centroidOfEase(ft[0], ft[1], amp, props.func, aux, centroid);
    boxOfEase(ft[0], ft[1], amp, props.func, aux, box);
    props.points = pixelEval((t) => func(t, ft[0], ft[1], amp, aux), false);
    props.convex = poleAngles(convexHull(props.points), centroid, true);
}
const EaseTypeTexts = [
    ['Ê≠£Âº¶', 'Sine'],
    ['‰∫åÊ¨°', 'Quadratic'],
    ['‰∏âÊ¨°', 'Cubic'],
    ['ÂõõÊ¨°', 'Quartic'],
    ['‰∫îÊ¨°', 'Quintic'],
    ['ÊåáÊï∞', 'Exponential'],
    ['ÂúÜÂΩ¢', 'Circular'],
    ['ÂõûÂºπ', 'Back'],
    ['ÂºπÊÄß', 'Elastic'],
    ['ÂºπË∑≥', 'Bounce']
];
function getEaseTypeText(type, lang = LANG) {
    return EaseTypeTexts[type/3][lang] || Object.keys(EASE_FUNC).find(k => EASE_FUNC[k] === type) || type;
}
const EaseProcTexts = [
    ['Ê∏êÂÖ•', 'In'],
    ['Ê∏êÂá∫', 'Out'],
    ['Ê∏êÂÖ•/Ê∏êÂá∫', 'In/Out']
];
function getEaseProcText(proc, lang = LANG) {
    return EaseProcTexts[proc][lang] || Object.keys(EASE_PROC).find(k => EASE_PROC[k] === proc) || proc;
}
const EASE_GROUP_COLORS = [
    '#16a085',  // ËìùÁªøËâ≤
    '#007bff',  // ËìùËâ≤
    '#9b59b6',  // Á¥´Ëâ≤
    '#e67e22',  // Ê©ôËâ≤
    '#2ecc71',  // ÁªøËâ≤
    '#f3cc12',  // ÈªÑËâ≤
    '#e74c3c',  // Á∫¢Ëâ≤
    '#ff6b35',  // Ê©ôÁ∫¢Ëâ≤
    '#34495e',  // Ê∑±ÁÅ∞
    '#1abc9c'   // ÈùíËâ≤
];
function Bezier(p1, p2, controls) {
    controls.unshift(p1); controls.push(p2);
    const points = pixelEval((t) => bezier(t, controls), false);
    p1.push(FeatureTypes.START); p2.push(FeatureTypes.END);
    const centroid = centroidOfBezier(controls);
    return { ft: [p1, p2], controls: controls, aux: distAux(p1, p2),
        centroid: centroid,
        box: boxOfBezier(controls),
        points, convex: poleAngles(convexHull(points), centroid, true)
    };
}
function BezierRebuild(props) {
    const { ft, controls, aux, box, centroid } = props;
    ft[0] = controls[0]; ft[1] = controls[controls.length - 1];
    distAux(ft[0], ft[1], aux);
    centroidOfBezier(controls, centroid);
    boxOfBezier(controls, box);
    props.points = pixelEval((t) => bezier(t, controls), false);
    props.convex = poleAngles(convexHull(props.points), centroid, true);
}
const BezierTypeTexts = [
    ['Ê¨°Ë¥ùÂ°ûÂ∞îÊõ≤Á∫ø', 'Bezier Curve'],
    ['‰∫åÊ¨°Ë¥ùÂ°ûÂ∞îÊõ≤Á∫ø', 'Quadratic Bezier Curve'],
    ['‰∏âÊ¨°Ë¥ùÂ°ûÂ∞îÊõ≤Á∫ø', 'Cubic Bezier Curve'],
    ['ÂõõÊ¨°Ë¥ùÂ°ûÂ∞îÊõ≤Á∫ø', 'Quartic Bezier Curve'],
    ['‰∫îÊ¨°Ë¥ùÂ°ûÂ∞îÊõ≤Á∫ø', 'Quintic Bezier Curve']
];
// ËæÖÂä©ÂáΩÊï∞ÔºöËé∑ÂèñË¥ùÂ°ûÂ∞îÊõ≤Á∫øÁ±ªÂûãÊñáÊú¨
function getBezierTypeText(controlCount, lang = LANG) {
    controlCount -= 2; console.assert(controlCount > 0);
    switch (controlCount) {
        case 1: case 2: case 3: case 4: return BezierTypeTexts[controlCount][lang];
        default: return `${controlCount+1} ` + BezierTypeTexts[0][lang];
    }
}

function moveLocalElement(props, dx, dy) {
    props.box[0] += dx; props.box[1] += dy; // cx, cy
    props.box[2] += dx; props.box[3] += dy; // l, t
    props.box[4] += dx; props.box[5] += dy; // r, b
    props.centroid[0] += dx;
    props.centroid[1] += dy;
    if (props.ft) props.ft.forEach(p => { p[0] += dx; p[1] += dy; });
    if (props.controls) props.controls.forEach(p => { p[0] += dx; p[1] += dy; });
    if (props.convex) props.convex.forEach(p => { p[0] += dx; p[1] += dy; });
}

function Func(expr, range) {
    return { ft: [], expr: expr, range: range,
        points: pixelEval((x) => evalExpr(expr, x), range)
    };
}

// ÂÖÉÁ¥†ÁÆ°ÁêÜÂèòÈáè
//-----------------------

let elementIdBase = 0;                  // ÂÖÉÁ¥† ID ÁîüÊàêÂü∫Êï∞
function Element(type, props, attrs) {
    return { id: ++elementIdBase,
        type: type,
        props: props,
        attrs: attrs,
        visible: true,
        transform: {
            // ÁøªËΩ¨ÂèòÊç¢ÔºöËßÇÊµãÁÇπÂùêÊ†á + ËßÇÊµãÊñπÂêë + ÁøªËΩ¨Á±ªÂûã
            flip: {
                observePos: [0, 0],             // ËßÇÊµãÁÇπÂùêÊ†á, todo: Á°ÆËÆ§ÊòØÂê¶Â≠òÂú® observePos[2]
                observeDir: null,               // ËßÇÊµãÊñπÂêëÔºàËßíÂ∫¶ÔºâÔºånull Ë°®Á§∫Ëá™Âä®ËÆ°ÁÆó
                observePosLSConstrain: false,   // ÂØπËßÇÊµãÁÇπÂùêÊ†áËøõË°åÂ±ÄÈÉ®ÂØπÁß∞ÊÄßÁ∫¶ÊùüÔºàËØ•Â±ûÊÄßÁî®‰∫éÁ°Æ‰øù UI Êìç‰ΩúÈÄâÈ°πÂíåÊï∞ÊçÆÁä∂ÊÄÅÂÖ∑Êúâ‰∏ÄËá¥ÊÄßÔºâ
                observeDirLSConstrain: false,   // ÂØπËßÇÊµãÊñπÂêëËøõË°åÂ±ÄÈÉ®ÂØπÁß∞ÊÄßÁ∫¶ÊùüÔºàÂêå‰∏äÔºâ
                forwardY: false,                // ÊúùÂêëÁøªËΩ¨ (ÂûÇÁõ¥ÁøªËΩ¨)
                sideX: false                    // ÂùêÂêëÁøªËΩ¨ (Ê∞¥Âπ≥ÁøªËΩ¨)
            },
            // Ââ™ÂàáÂèòÊç¢ÔºöËßÇÊµãÁÇπÂùêÊ†á + ËßÇÊµãÊñπÂêë + Áü©ÈòµÂâ™Âàá
            shear: {
                observePos: [0, 0],             // ËßÇÊµãÁÇπÂùêÊ†á
                observeDir: null,               // ËßÜËßíËßíÂ∫¶ÔºàÂ∫¶ÔºâÔºånull Ë°®Á§∫Ëá™Âä®ËÆ°ÁÆó
                observePosLSConstrain: false,   // ÂØπËßÇÊµãÁÇπÂùêÊ†áËøõË°åÂ±ÄÈÉ®ÂØπÁß∞ÊÄßÁ∫¶Êùü
                observeDirLSConstrain: false,   // ÂØπËßÇÊµãÊñπÂêëËøõË°åÂ±ÄÈÉ®ÂØπÁß∞ÊÄßÁ∫¶Êùü
                angleX: 0,                      // XËΩ¥Ââ™ÂàáËßíÂ∫¶ÔºàÂ∫¶Ôºâ
                angleY: 0,                      // YËΩ¥Ââ™ÂàáËßíÂ∫¶ÔºàÂ∫¶Ôºâ
                forwardY: 0,                    // ÊúùÂêëÂâ™Âàá (YÊñπÂêëÁü©ÈòµÂÖÉÁ¥†)
                sideX: 0                        // ÂùêÂêëÂâ™Âàá (XÊñπÂêëÁü©ÈòµÂÖÉÁ¥†)
            },
            // ÊóãËΩ¨ÂèòÊç¢ÔºöËßÇÊµãÁÇπÂùêÊ†á
            rotation: {
                observePos: [0, 0],             // ËßÇÊµãÁÇπÂùêÊ†á
                observePosLSConstrain: false,   // ÂØπËßÇÊµãÁÇπÂùêÊ†áËøõË°åÂ±ÄÈÉ®ÂØπÁß∞ÊÄßÁ∫¶Êùü
                angle: 0                        // ÊóãËΩ¨ËßíÂ∫¶ÔºàÂ∫¶Ôºâ
            },
            // Áº©ÊîæÂèòÊç¢ÔºöËßÇÊµãÁÇπÂùêÊ†á
            scale: {
                observePos: [0, 0],             // ËßÇÊµãÁÇπÂùêÊ†á
                observePosLSConstrain: false,   // ÂØπËßÇÊµãÁÇπÂùêÊ†áËøõË°åÂ±ÄÈÉ®ÂØπÁß∞ÊÄßÁ∫¶Êùü
                x: 1,                           // XËΩ¥Áº©ÊîæÂõ†Â≠ê
                y: 1                            // YËΩ¥Áº©ÊîæÂõ†Â≠ê
            },
            // Âπ≥ÁßªÂèòÊç¢
            translation: [0, 0]                 // Âπ≥ÁßªÂêëÈáè
        }
    }
}
function Attributes(lineSize = DEFAULT_LINE_WIDTH, color = DEFAULT_LINE_COLOR) {
    const attrs = { color: DEFAULT_LINE_COLOR };
    if (lineSize) attrs.width = DEFAULT_LINE_WIDTH;
    return attrs;
}
let elements = [];                      // ÁªòÂà∂ÂÖÉÁ¥†ÂØπË±°ÈõÜÂêà

// ‰øùÂ≠òÂíåÂä†ËΩΩÂäüËÉΩ
//-----------------------

// ‰øùÂ≠ò elements ‰∏∫ JSON Êñá‰ª∂
function saveElementsToJSON() {
    try {
        // ÁîüÊàêÈªòËÆ§Êñá‰ª∂ÂêçÔºà‰∏çÂ∏¶ .json ÂêéÁºÄÔºâ
        const timestamp = Date.now();
        const defaultFileName = `elements_${timestamp}`;
        
        // ÂºπÂá∫ÂØπËØùÊ°ÜËÆ©Áî®Êà∑Á°ÆËÆ§Êàñ‰øÆÊîπÊñá‰ª∂Âêç
        const fileName = prompt('ËØ∑ËæìÂÖ•‰øùÂ≠òÁöÑÊñá‰ª∂Âêç:', defaultFileName);
        
        // Â¶ÇÊûúÁî®Êà∑ÂèñÊ∂àÔºåÂàô‰∏ç‰øùÂ≠ò
        if (fileName === null || fileName.trim() === '') {
            return;
        }
        
        // Ëá™Âä®Ê∑ªÂä† .json ÂêéÁºÄ
        let finalFileName = fileName.trim();
        // Â¶ÇÊûúÁî®Êà∑ËæìÂÖ•‰∫Ü .json ÂêéÁºÄÔºåÂÖàÂéªÊéâ
        if (finalFileName.endsWith('.json')) {
            finalFileName = finalFileName.slice(0, -5);
        }
        finalFileName += '.json';
        
        // ÊûÑÈÄ† JSON Êï∞ÊçÆ
        const data = {
            version: "1.0",
            timestamp: new Date().toISOString(),
            elements: elements
        };

        // ËΩ¨Êç¢‰∏∫ JSON Â≠óÁ¨¶‰∏≤
        const jsonString = JSON.stringify(data, null, 2);

        // ÂàõÂª∫ Blob ÂØπË±°
        const blob = new Blob([jsonString], { type: 'application/json' });

        // ÂàõÂª∫‰∏ãËΩΩÈìæÊé•
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = finalFileName;

        // Ëß¶Âèë‰∏ãËΩΩ
        a.click();

        // ÈáäÊîæ URL ÂØπË±°
        URL.revokeObjectURL(url);

        console.log('Elements saved successfully');
    } catch (error) {
        console.error('Failed to save elements:', error);
        alert('‰øùÂ≠òÂ§±Ë¥•Ôºö' + error.message);
    }
}

function loadElementsFromJSON(file) {
    if (!file) return;

    const reader = new FileReader();
    reader.onload = function(event) {
        try {
            const data = JSON.parse(event.target.result);

            if (!data.elements || !Array.isArray(data.elements)) {
                throw new Error('Invalid JSON format: missing elements array');
            }

            // Âä†ËΩΩÂÖÉÁ¥†Êï∞ÊçÆ
            elements = data.elements;
            nextElementId = Math.max(0, ...elements.map(e => e.id)) + 1;

            // ÂèñÊ∂àÈÄâÊã©
            selectedElement = null;
            UIHidePropertyPanel();

            // Êõ¥Êñ∞ÂÖÉÁ¥†Èù¢Êùø
            uiUpdateElementPanel();

            // ÈáçÁªò
            draw();

            // ÂÖ≥Èó≠‰∏ä‰º†ÂØπËØùÊ°Ü
            UIHideUploadDialog();

            console.log(`Loaded ${elements.length} elements from JSON`);
        } catch (error) {
            console.error('Failed to parse JSON:', error);
            alert('Âä†ËΩΩÂ§±Ë¥•Ôºö' + error.message);
        }
    };

    reader.readAsText(file);
}

// ÂùêÊ†áÁ≥ªÁä∂ÊÄÅÂèòÈáè
//-----------------------

let scale = 1.0;                        // ÂΩìÂâçÁº©ÊîæÂÄçÊï∞
let offsetX = INITIAL_OFFSET_X;         // XËΩ¥ÂÅèÁßªÈáè
let offsetY = INITIAL_OFFSET_Y;         // YËΩ¥ÂÅèÁßªÈáè
let coordinateState = COORDINATE_STATES.INITIAL;

let mouseMath = null;                   // ÂΩìÂâçÈº†Ê†áÁöÑÊï∞Â≠¶ÂùêÊ†áÁ≥ª‰ΩçÁΩÆ [x, y]ÔºåÊîØÊåÅÁΩëÊ†ºÂØπÈΩê
let mouseScreenX = 0;                   // ÂΩìÂâçÈº†Ê†áÁöÑÂ±èÂπïÂùêÊ†áÁ≥ª‰ΩçÁΩÆÔºå‰∏çÊîØÊåÅÁΩëÊ†ºÂØπÈΩê
let mouseScreenY = 0;

// Ê≥®ÊÑèÔºöÊï∞Â≠¶ÂùêÊ†áÁ≥ªYËΩ¥Âêë‰∏ä‰∏∫Ê≠£ÔºåÂ±èÂπïÂùêÊ†áÁ≥ªYËΩ¥Âêë‰∏ã‰∏∫Ê≠£ÔºåÈúÄË¶ÅÂûÇÁõ¥ÈïúÂÉèÁøªËΩ¨
function mathToScreen(mathX, mathY) {
    return [
        offsetX + mathX * UNIT_SIZE * scale,
        canvas.height + offsetY - mathY * UNIT_SIZE * scale
    ];
}
function screenToMath(screenX, screenY) {
    return [
        (screenX - offsetX) / (UNIT_SIZE * scale),
        (canvas.height + offsetY - screenY) / (UNIT_SIZE * scale)
    ];
}

// ÂùêÊ†áÁ≥ªÂèòÂåñÂêéÔºåÂêåÊ≠•Êõ¥Êñ∞ÁºìÂ≠òÁöÑÂ±èÂπïÂùêÊ†á
function syncScreenCoords() {

    // ÂêåÊ≠•Èº†Ê†áÂ±èÂπïÂùêÊ†á
    if (mouseMath) {
        [mouseScreenX, mouseScreenY] = mathToScreen(mouseMath[0], mouseMath[1]);
    }

    if (drawStart) {
        drawDown = mathToScreen(drawStart[0], drawStart[1]);
    }

    // ÂêåÊ≠•ËßÇÊµãÁÇπÂ±èÂπïÂùêÊ†á
    if (observingPoint) {
        observingPointInScreen = mathToScreen(observingPoint[0], observingPoint[1]);
    }
}

// Êõ¥Êñ∞Èù¢Êùø‰ΩçÁΩÆÔºàÊ†πÊçÆÂùêÊ†áÁ≥ªÁä∂ÊÄÅÔºâ
function updatePanelPosition() {
    const elementsPanel = document.querySelector('.elements-panel');
    const propertyPanel = document.querySelector('.property-panel');
    
    if (coordinateState === COORDINATE_STATES.INITIAL) {
        // ÂéüÁÇπÂú®Â∑¶‰∏ã ‚Üí Èù¢ÊùøÂú®Âè≥Ëæπ
        elementsPanel?.classList.remove('left-align');
        propertyPanel?.classList.remove('left-align');
    } else {
        // ÂéüÁÇπÂú®‰∏≠Èó¥ÊàñÂè≥Ëæπ ‚Üí Èù¢ÊùøÂú®Â∑¶Ëæπ
        elementsPanel?.classList.add('left-align');
        propertyPanel?.classList.add('left-align');
    }
}

// Âá†‰ΩïÂÖÉÁ¥†ÁöÑÁªòÂà∂ÂàõÂª∫
//-----------------------

// Êñ∞Â¢ûÁªòÂà∂ÂÖÉÁ¥†Áõ∏ÂÖ≥ÂèòÈáè
const DRAWING = {
    AUX_LINE: 1,                        // ÁªòÂà∂ËæÖÂä©Á∫øÈò∂ÊÆµ
    AUX_MENU: 2,                        // ÁªàÁÇπÈÄâÂÆöÂºπÂá∫ÁªòÂà∂ÂÖÉÁ¥†ËèúÂçïÈò∂ÊÆµÔºàËØ•Èò∂ÊÆµËæÖÂä©Á∫øË¢´Âõ∫ÂÆöÔºå‰∏çÂÜçË∑üÈöèÈº†Ê†áÁßªÂä®Ôºâ
    POLYGON: 3,
    ARC: 4,
    EASE: 5,
    BEZIER: 6
};
let drawing = 0;                        // ÂΩìÂâçÊ≠£Âú®ÁªòÂà∂ÁöÑÂÖÉÁ¥†
let drawDown = null;                    // Èº†Ê†áÊåâ‰∏ãÊó∂ÁöÑÂ±èÂπïÂùêÊ†áÁ≥ª‰ΩçÁΩÆ
let drawStart = null;                   // Ëµ∑ÁÇπÂùêÊ†áÔºåÈº†Ê†áÂùêÊ†áÊç¢ÁÆóÂêéÁöÑÁªìÊûú
let drawEnd = null;                     // ÁªàÁÇπÂùêÊ†áÔºåÂêå‰∏ä

// Â§öËæπÂΩ¢ÁªòÂà∂Áõ∏ÂÖ≥ÂèòÈáè
let drawingPolygon = [];                // Â§öËæπÂΩ¢ÁöÑÁÇπÊï∞ÁªÑ

// ÂºßÁ∫øÁªòÂà∂Áõ∏ÂÖ≥ÂèòÈáè
let arcStartPoint = null;               // ÂºßÁ∫øËµ∑ÁÇπ
let arcEndPoint = null;                 // ÂºßÁ∫øÁªàÁÇπ
let arcCenterPoint = null;              // ÂºßÁ∫øÂúÜÂøÉÁÇπ
let arcRadius = 0;                      // ÂºßÁ∫øÂçäÂæÑ
let isPerpendicularLocked = false;      // ÊòØÂê¶ÂêØÁî®ÂûÇÁõ¥ÈîÅÂÆöÊ®°Âºè
let chordMidPoint = null;               // Âº¶ÁöÑ‰∏≠ÁÇπ
let perpVector = null;                  // ÂûÇÁõ¥ÂêëÈáèÔºàÂçï‰ΩçÂêëÈáèÔºâ

// easeÊõ≤Á∫øÁªòÂà∂Áõ∏ÂÖ≥ÂèòÈáè
let easeStartPoint = null;              // easeÊõ≤Á∫øËµ∑ÁÇπ
let easeEndPoint = null;                // easeÊõ≤Á∫øÁªàÁÇπ
let currentEaseType = -1;               // ÂΩìÂâçeaseÁ±ªÂûãÔºàsine, quad, cubic, quart, quint, expo, circ, back, elastic, bounceÔºâ
let currentEaseProc = -1;               // ÂΩìÂâçeaseËøáÁ®ãÔºàin, out, inOutÔºâ

// Ë¥ùÂ°ûÂ∞îÊõ≤Á∫øÁªòÂà∂Áõ∏ÂÖ≥ÂèòÈáè
let bezierStartPoint = null;            // Ë¥ùÂ°ûÂ∞îÊõ≤Á∫øËµ∑ÁÇπ
let bezierEndPoint = null;              // Ë¥ùÂ°ûÂ∞îÊõ≤Á∫øÁªàÁÇπ
let bezierControlPoints = [];           // ÊéßÂà∂ÁÇπÊï∞ÁªÑÔºàÊîØÊåÅ‰ªªÊÑèÊï∞ÈáèÔºâ
let bezierControlPointCount = 2;        // ÂΩìÂâçË¥ùÂ°ûÂ∞îÊõ≤Á∫øÁöÑÊéßÂà∂ÁÇπÊï∞Èáè
let currentBezierControlIndex = 0;      // ÂΩìÂâçÊ≠£Âú®ËÆæÁΩÆÁöÑÊéßÂà∂ÁÇπÁ¥¢ÂºïÔºà0ÂºÄÂßãÔºâ

// Âá†‰ΩïÂÖÉÁ¥†ÁöÑËßÇÊµã‰∫§‰∫í
//-----------------------

let selectedElement = null;             // ÂΩìÂâçÈÄâ‰∏≠ÁöÑÂÖÉÁ¥†ID

let projectingPoint = null;             // Èº†Ê†áÊåáÈíàÂú®ÔºàÂΩìÂâçÈÄâÊã©ÁöÑÔºâÂÖÉÁ¥†‰∏äÁöÑÊäïÂΩ±ÁÇπÔºàÂç≥Â∞ÜÈº†Ê†áËßÜ‰∏∫ËßÇÊµãÁÇπÔºâ
let projectionTangent = null;           // ÂΩìÂâçÊäïÂΩ±ÁÇπÁöÑÂàáÁ∫øÊñúÁéáÔºönull(ÂàùÂßãÂÄº), undefined(ÁÇπÊó†Êïà), NaN(‰∏çÂèØÂØº), Infinity(ÂûÇÁõ¥), Êï∞ÂÄº(ÊñúÁéá)

const TRANSFORM = {
    FLIP: 1,                            // ÁøªËΩ¨
    SHEAR: 2,                           // Ââ™Âàá
    ROTATION: 3,                        // ÊóãËΩ¨
    SCALE: 4,                           // Áº©Êîæ
    TRANSLATION: 5,                     // Âπ≥Áßª
};
let activeTransform = 0;                // ÂΩìÂâçÊøÄÊ¥ªÁöÑÂèòÊç¢Á±ªÂûã
let observingPoint = null;              // ÂΩìÂâçÊøÄÊ¥ªÁöÑËßÇÊµãÁÇπ [x, y, relative]ÔºåÊï∞Â≠¶ÂùêÊ†áÁ≥ª„ÄÇ
                                        // + relative Ë°®Á§∫ËßÇÊµãÁÇπÁõ∏ÂØπÊÄßÂÖ≥Á≥ª„ÄÇ-1: Âú®ÂÜÖÈÉ®; 0: Âú®ËæπÁïå‰∏ä; 1: Âú®Â§ñÈÉ®
let constrainObservePosLocalSymmetry = false; // ÂØπËßÇÊµãÁÇπ‰ΩçÁΩÆËøõË°åÂ±ÄÈÉ®ÂØπÁß∞ÊÄßÁ∫¶Êùü
let constrainObserveDirLocalSymmetry = false; // ÂØπËßÇÊµãÊñπÂêëËøõË°åÂ±ÄÈÉ®ÂØπÁß∞ÊÄßÁ∫¶Êùü

let observingPointInScreen = null;      // ÂΩìÂâçÊøÄÊ¥ªÁöÑËßÇÊµãÁÇπ [x, y]ÔºåÂ±èÂπïÂùêÊ†áÁ≥ª
let observingRelevant = null;           // ÔºàÂΩìËßÇÊµãÁÇπÂú®Â§ñÈÉ®Êó∂ÔºâÊª°Ë∂≥Â±ÄÈÉ®ÂØπÁß∞ÊÄßÁöÑÊñπÂêëËåÉÂõ¥ [x, y]

let observingDirection = false;         // ÊòØÂê¶Ê≠£Âú®ÊòæÁ§∫ËßÇÊµãÊñπÂêëÔºàÂú® flip/shear ÂèòÊç¢Ê®°Âºè‰∏ãÔºå‰∏îÊåâ‰Ωè Alt ÈîÆÊó∂ÂêØÁî®Ôºâ

/* ================================ */
/* UI ‰∫§‰∫í
/* ================================ */

let uiHelpShown = false;                // Â∏ÆÂä©ÂØπËØùÊ°ÜÊòØÂê¶ÊòæÁ§∫
let uiHelpCurrentTab = 'basic';         // ÂàáÊç¢Â∏ÆÂä© tab
let uiDrawMenuShown = false;            // ÁªòÂà∂ËèúÂçïÊòØÂê¶ÊòæÁ§∫
let uiElementsPanelShown = false;       // ÂÖÉÁ¥†ÁÆ°ÁêÜÈù¢ÊùøÊòØÂê¶ÊòæÁ§∫
let uiAttributesDialogShown = false;    // ÂÖÉÁ¥†Â±ûÊÄßÂØπËØùÊ°ÜÊòØÂê¶ÊòæÁ§∫
let uiPropertyPanelShown = false;       // ÂÖÉÁ¥†ÁºñËæëÈù¢ÊùøÊòØÂê¶ÊòæÁ§∫
let uiPropertyCurrentTab = null;        // ÂΩìÂâçÊøÄÊ¥ªÁöÑÂ±ûÊÄßÊ†áÁ≠æÈ°µ
let uiUploadShown = false;              // Êñá‰ª∂‰∏ä‰º†ÂØπËØùÊ°Ü

let uiMenuPopping = false;              // popup ËèúÂçïÂºπÂá∫Áä∂ÊÄÅÔºåÂç≥Ê†áËÆ∞Ê≠£Âú®ÂºπÂá∫ÔºåÈÅøÂÖçË¢´ÂêéÁª≠ÁöÑ click ‰∫ã‰ª∂ÂÖ≥Èó≠
                                        // + popup ËèúÂçïÁöÑÈÄªËæë‰∏ÄËà¨ÊòØÔºåmouseup ÂºπÂá∫ + click ËèúÂçïÂå∫ÂüüÂ§ñ‰ºöÂÖ≥Èó≠
                                        //   ‰ΩÜÊòØÂú®Èº†Ê†á‰∫§‰∫íÁ≥ªÁªü‰∏≠Ôºåmouseup ‰∫ã‰ª∂Âêé‰∏ÄËà¨‰ºöËß¶Âèë click ‰∫ã‰ª∂Ôºå
                                        //   ËøôÂ∞±ÊÑèÂë≥ÁùÄÔºåÈöèÂêéÁöÑ click ‰∫ã‰ª∂‰ºöÂØºËá¥ÂàöÊòæÁ§∫ÁöÑËèúÂçï‰ºöË¢´Á´ãÂç≥ÂÖ≥Èó≠

//-----------------------

let uiFunctionLastExpression = '';      // ÂáΩÊï∞ÁªòÂà∂ÂØπËØù‰∏äÊ¨°ËæìÂá∫Áä∂ÊÄÅÔºàÈúÄÊ±Ç‰∏ä‰øùÁïôÊúÄÂêé‰∏ÄÊ¨°ËæìÂÖ•Ôºâ
let uiFunctionLastXMin = null;
let uiFunctionLastXMax = null;

let uiEditingSaved0 = null;             // ÁºñËæëËøáÁ®ã‰∏≠ÁöÑÂéüÂßãÁä∂ÊÄÅÂ§á‰ªΩ
let uiEditingSaved1 = null;

//-----------------------

const DRAGGING = {
    COORDS: 1,
    ELEMENT: 2,
    OBSERVE_POINT: 3,
}
let dragging = 0;                       // ÂΩìÂâçÊòØÂê¶Â§Ñ‰∫éÊãñÊãΩÁä∂ÊÄÅ
let dragDownClientX;                    // ÊãñÊãΩËµ∑Âßã‰ΩçÁΩÆÔºàcanvas ËßÜÂè£ÂùêÊ†áÔºâ
let dragDownClientY;
let dragStart;                          // ÊãñÊãΩËµ∑Âßã‰ΩçÁΩÆÔºàÊï∞Â≠¶ÂùêÊ†áÔºâ
let dragOffsetX;                        // ÊãñÊãΩÂºÄÂßãÊó∂ÁöÑÂùêÊ†áÁ≥ªÁöÑÂÅèÁßª‰ΩçÁΩÆ
let dragOffsetY;
let dragElement;                        // Ë¢´ÊãñÊãΩÁöÑÂÖÉÁ¥†
let dragCenterX;                        // ÊãñÊãΩÂºÄÂßãÊó∂ÁöÑÂÖÉÁ¥†ÁöÑ‰∏≠ÂøÉÁÇπÔºàÊï∞Â≠¶ÂùêÊ†áÔºâ
let dragCenterY;

let lastLeftClickTime = 0;              // Â∑¶ÈîÆÂèåÂáªÊ£ÄÊµã
let lastLeftClickX;
let lastLeftClickY;
let lastRightClickTime = 0;             // Âè≥ÈîÆÂèåÂáªÊ£ÄÊµã
let lastRightClickX;
let lastRightClickY;

// Èº†Ê†áÊçïËé∑Áõ∏ÂÖ≥ÁöÑÂáΩÊï∞ÂºïÁî®ÔºàÁî®‰∫éÂä®ÊÄÅÁªëÂÆö/Ëß£Áªë document Á∫ßÂà´ÁöÑ‰∫ã‰ª∂Ôºâ
let capturedMouseMove = null;
let capturedMouseUp = null;

let isShiftPressed = false;             // AltÈîÆÁä∂ÊÄÅ
let isCtrlPressed = false;              // CtrlÈîÆÁä∂ÊÄÅ
let isAltPressed = false;               // Command/MetaÈîÆÁä∂ÊÄÅÔºàÁî®‰∫éÂ§öËæπÂΩ¢ÁªòÂà∂Ôºâ
let isKeyAPressed = false;              // Â≠óÊØçÈîÆAÁä∂ÊÄÅÔºàÁî®‰∫éÊòæÁ§∫ÂàáÁ∫øÔºâ
let isKeySPressed = false;              // Â≠óÊØçÈîÆSÁä∂ÊÄÅÔºàÁî®‰∫éÊòæÁ§∫Ê≥ïÁ∫øÔºâ
let isKeyZPressed = false;              // Â≠óÊØçÈîÆZÁä∂ÊÄÅÔºàÁî®‰∫éÂùêÊ†áÁ≥ªÊìç‰ΩúÔºâ

let keyClickTimer = null;               // ÊåâÈîÆÂèåÂáªÊ£ÄÊµã
let keyClicking = null;
let ctrlAltKeyHoldTimer = null;         // Ctrl+Alt ÈîÆÈïøÊåâÊ£ÄÊµã

//====================================

// ÂàùÂßãÂåñÁªëÂÆöÂ∏ÆÂä©ÂØπËØùÊ°Ü‰∫ã‰ª∂Â§ÑÁêÜ
document.getElementById('helpOverlay').addEventListener(CTRL_CLICK_EVENT, function(e) {
    e.preventDefault();
    e.stopPropagation();
    if (e.target === this) {
        UIHideHelpDialog();
    }
});

// ‰∏ªÈ¢òÂàáÊç¢ÊåâÈíÆ
document.getElementById('themeToggleBtn').addEventListener(CTRL_CLICK_EVENT, function(e) {
    e.preventDefault();
    e.stopPropagation();
    uiActToggleDarkModeInHelp();
});

// ËØ≠Ë®ÄÂàáÊç¢ÊåâÈíÆ
document.getElementById('langToggleBtn').addEventListener(CTRL_CLICK_EVENT, function(e) {
    e.preventDefault();
    e.stopPropagation();
    uiActToggleLanguageInHelp();
});

// ËØ≠Ë®ÄÂàáÊç¢ÊåâÈíÆÁöÑÊÇ¨ÂÅúÊïàÊûú
document.getElementById('langToggleBtn').addEventListener('mouseenter', function() {
    const langToggleText = document.getElementById('langToggleText');
    // ÊØèÊ¨°ÊÇ¨ÂÅúÊó∂ÈáçÊñ∞ËØªÂèñÊúÄÊñ∞ÁöÑÁõÆÊ†áËØ≠Ë®Ä
    const targetLang = this.getAttribute('data-target-lang');
    if (targetLang && langToggleText) {
        langToggleText.textContent = targetLang;
    }
});

document.getElementById('langToggleBtn').addEventListener('mouseleave', function() {
    const langToggleText = document.getElementById('langToggleText');
    // Èº†Ê†áÁ¶ªÂºÄÊó∂ÊÅ¢Â§çÊòæÁ§∫ÂΩìÂâçËØ≠Ë®Ä
    if (langToggleText) {
        langToggleText.textContent = LangText.LANG_TAG[LANG];
    }
});

// ÁªëÂÆöÂ∏ÆÂä©ÂØπËØùÊ°ÜÊ†áÁ≠æÈ°µÂàáÊç¢‰∫ã‰ª∂
document.querySelectorAll('.help-tab').forEach(tab => {
    const tabName = tab.getAttribute('data-tab');
    
    tab.addEventListener(CTRL_CLICK_EVENT, function(e) {
        e.preventDefault();
        e.stopPropagation();
        uiSwitchHelpTab(tabName);
    });
});

// Â∏ÆÂä©ÂØπËØùÊ°Ü
function UIShowHelpDialog() {
    document.getElementById('helpOverlay').classList.add('show');
    uiHelpShown = true;
    
    // Êõ¥Êñ∞ËØ≠Ë®ÄÊåâÈíÆÁä∂ÊÄÅ‰ª•ÂåπÈÖçÂΩìÂâçËØ≠Ë®Ä
    const langToggleText = document.getElementById('langToggleText');
    if (langToggleText) {
        langToggleText.textContent = LANG === 0 ? '‰∏≠' : 'EN';
        langToggleText.parentElement.setAttribute('data-target-lang', LANG === 0 ? 'EN' : '‰∏≠');
    }

    // Ê£ÄÊü•ÂÜÖÂÆπÊòØÂê¶ÈúÄË¶ÅÊªöÂä®ÔºåÊ∑ªÂä†Áõ∏Â∫îÁöÑÁ±ªÂêç
    setTimeout(() => {
        const helpDialog = document.querySelector('.help-dialog');
        const helpContent = document.querySelector('.help-dialog-content');

        if (helpContent && helpDialog) {
            if (helpContent.scrollHeight > helpContent.clientHeight) {
                helpDialog.classList.add('scrollable');
            } else {
                helpDialog.classList.remove('scrollable');
            }
        }
    }, 100);
}
function UIHideHelpDialog() {
    document.getElementById('helpOverlay').classList.remove('show');
    uiHelpShown = false;
}
function uiSwitchHelpTab(tabName) {
    // ÁßªÈô§ÊâÄÊúâ active Á±ª
    document.querySelectorAll('.help-tab').forEach(tab => {
        tab.classList.remove('active');
    });
    document.querySelectorAll('.help-tab-content').forEach(content => {
        content.classList.remove('active');
    });
    
    // Ê∑ªÂä† active Á±ªÂà∞ÂΩìÂâç tab
    const activeTab = document.querySelector(`.help-tab[data-tab="${tabName}"]`);
    const activeContent = document.getElementById(`help-tab-${tabName}`);
    
    if (activeTab) activeTab.classList.add('active');
    if (activeContent) activeContent.classList.add('active');
    
    uiHelpCurrentTab = tabName;
    
    // ÈáçÊñ∞Ê£ÄÊü•ÊªöÂä®Áä∂ÊÄÅ
    setTimeout(() => {
        const helpDialog = document.querySelector('.help-dialog');
        const helpContent = document.querySelector('.help-dialog-content');
        if (helpContent && helpDialog) {
            if (helpContent.scrollHeight > helpContent.clientHeight) {
                helpDialog.classList.add('scrollable');
            } else {
                helpDialog.classList.remove('scrollable');
            }
        }
    }, 10);
}
function uiNavigateHelpTab(direction) {
    const tabs = ['basic', 'coordinate', 'element', 'app'];
    const currentIndex = tabs.indexOf(uiHelpCurrentTab);
    let newIndex = currentIndex + direction;
    
    // Âæ™ÁéØÂØºËà™
    if (newIndex < 0) newIndex = tabs.length - 1;
    if (newIndex >= tabs.length) newIndex = 0;
    
    uiSwitchHelpTab(tabs[newIndex]);
}

// Â∏ÆÂä©ÂØπËØùÊ°Ü‰∏≠ÁöÑ‰∏ªÈ¢òÂàáÊç¢ÂáΩÊï∞ - Èò≤Ê≠¢ÂØπËØùÊ°ÜÂÖ≥Èó≠
function uiActToggleDarkModeInHelp() {
    
    // ‰∏¥Êó∂Ê†áËÆ∞ÔºåÈò≤Ê≠¢Â∏ÆÂä©ÂØπËØùÊ°ÜË¢´ÈîÆÁõò‰∫ã‰ª∂ÂÖ≥Èó≠
    window.preventHelpClose = true;

    UITheme(!THEME);

    // Áü≠ÊöÇÂª∂ËøüÂêéÁßªÈô§Ê†áËÆ∞
    setTimeout(() => {
        window.preventHelpClose = false;
        if (!isCtrlPressed) {
            UIHideHelpDialog();
        }
    }, 200);
}
// Âú®Â∏ÆÂä©ÂØπËØùÊ°Ü‰∏≠ÂàáÊç¢ËØ≠Ë®Ä
function uiActToggleLanguageInHelp() {

    // ÂàáÊç¢ÂÖ®Â±ÄËØ≠Ë®ÄÂèòÈáè
    LANG = LANG === 0 ? 1 : 0;
    
    // Êõ¥Êñ∞ÊâÄÊúâUIÊñáÂ≠óÔºàÂåÖÊã¨ËØ≠Ë®ÄÊåâÈíÆÔºâ
    UILang(LANG);
}

//------------------------------------

// ÂÖÉÁ¥†ÈòüÂàóÈù¢Êùø
function UIShowElementsPanel() {
    if (!uiElementsPanelShown) {
        document.getElementById('elementsPanel').classList.add('show');
        uiElementsPanelShown = true;

        // ÊòæÁ§∫Èù¢ÊùøÊó∂Á°Æ‰øùÂÜÖÂÆπÊòØÊúÄÊñ∞ÁöÑ
        uiUpdateElementPanel();
    }
}
function UIHideElementsPanel() {
    document.getElementById('elementsPanel').classList.remove('show');
    uiElementsPanelShown = false;
}
function UIToggleElementsPanel() {
    uiElementsPanelShown ? UIHideElementsPanel() : UIShowElementsPanel();
}

// ÂÆö‰ΩçÂÖÉÁ¥†Âà∞Â±èÂπï‰∏≠ÂøÉÔºàÊ†πÊçÆÂÖÉÁ¥†Á±ªÂûãÊô∫ËÉΩË∞ÉÊï¥Ôºâ
function uiCenterElementOnScreen(element) {
    if (!element) return false;
    
    // Ê†πÊçÆÂÖÉÁ¥†Á±ªÂûãËÆ°ÁÆó‰∏≠ÂøÉÂíåÁõÆÊ†á‰ΩçÁΩÆ
    let targetOffsetX, targetOffsetY;
    
    if (element.type === ElementTypes.POINT) {
        // ÁÇπÂÖÉÁ¥†ÔºöÁõ¥Êé•‰ΩøÁî®ÂùêÊ†áÁÇπ‰Ωú‰∏∫‰∏≠ÂøÉ
        const centerX = element.props.coords[0];
        const centerY = element.props.coords[1];
        
        const screenCenterX = canvas.width / 2;
        const screenCenterY = canvas.height / 2;
        
        const [elementScreenX, elementScreenY] = mathToScreen(centerX, centerY);
        
        targetOffsetX = offsetX + (screenCenterX - elementScreenX);
        targetOffsetY = offsetY + (screenCenterY - elementScreenY);
        
    } else if (element.type === ElementTypes.FUNCTION) {
        // ÂáΩÊï∞ÂÖÉÁ¥†ÔºöÊ†πÊçÆÂÆö‰πâÂüüË∞ÉÊï¥
        const range = element.props.range;
        const xMin = range[0];
        const xMax = range[1];
        
        // YËΩ¥ÔºöÊÅ¢Â§çÂà∞ËßÜÂè£ÂûÇÁõ¥‰∏≠Á∫øÔºàcanvas.height / 2Ôºâ
        // ËÆ°ÁÆóÈúÄË¶ÅÁöÑ offsetYÔºö‰ΩøÂæóÂéüÁÇπÁöÑÂ±èÂπïYÂùêÊ†á = canvas.height / 2
        // originScreenY = canvas.height + offsetY
        // ÊâÄ‰ª• offsetY = canvas.height / 2 - canvas.height = -canvas.height / 2
        targetOffsetY = -canvas.height / 2;
        
        // XËΩ¥ÔºöÊ†πÊçÆÂÆö‰πâÂüüÂà§Êñ≠
        if (!isFinite(xMin) && !isFinite(xMax)) {
            // Â∑¶Âè≥ÈÉΩÊòØÊó†Á©∑ÔºöÂéüÁÇπÂ§Ñ‰∫éÂ±èÂπï‰∏≠Â§Æ
            targetOffsetX = canvas.width / 2;
        } else if (!isFinite(xMin)) {
            // Â∑¶‰æßÊó†Á©∑ÔºöÂéüÁÇπÂ§Ñ‰∫éÂ±èÂπïÂ∑¶‰æß
            // ‰Ωø xMax ÊòæÁ§∫Âú®Â±èÂπïÂè≥‰æßËæπÁºò
            targetOffsetX = canvas.width - xMax * UNIT_SIZE * scale;
        } else if (!isFinite(xMax)) {
            // Âè≥‰æßÊó†Á©∑ÔºöÂéüÁÇπÂ§Ñ‰∫éÂ±èÂπïÂè≥‰æß
            // ‰Ωø xMin ÊòæÁ§∫Âú®Â±èÂπïÂ∑¶‰æßËæπÁºò
            targetOffsetX = -xMin * UNIT_SIZE * scale;
        } else {
            // Â∑¶Âè≥ÈÉΩÊúâÈôêÔºö‰ΩøÂÆö‰πâÂüüÂ±Ö‰∏≠
            const centerX = (xMin + xMax) / 2;
            const screenCenterX = canvas.width / 2;
            targetOffsetX = screenCenterX - centerX * UNIT_SIZE * scale;
        }
        
    } else if (element.props.box) {
        // Êúâ box Â±ûÊÄßÁöÑÂÖÉÁ¥†Ôºö‰ΩøÁî® box ‰∏≠ÂøÉ
        const centerX = element.props.box[0];
        const centerY = element.props.box[1];
        
        const screenCenterX = canvas.width / 2;
        const screenCenterY = canvas.height / 2;
        
        const [elementScreenX, elementScreenY] = mathToScreen(centerX, centerY);
        
        targetOffsetX = offsetX + (screenCenterX - elementScreenX);
        targetOffsetY = offsetY + (screenCenterY - elementScreenY);
        
    } else if (element.props.centroid) {
        // Êúâ centroid ÁöÑÂÖÉÁ¥†ÔºàÂ¶ÇÂúÜÂΩ¢Ôºâ
        const centerX = element.props.centroid[0];
        const centerY = element.props.centroid[1];
        
        const screenCenterX = canvas.width / 2;
        const screenCenterY = canvas.height / 2;
        
        const [elementScreenX, elementScreenY] = mathToScreen(centerX, centerY);
        
        targetOffsetX = offsetX + (screenCenterX - elementScreenX);
        targetOffsetY = offsetY + (screenCenterY - elementScreenY);
        
    } else {
        // Êó†Ê≥ïÁ°ÆÂÆö‰∏≠ÂøÉÔºå‰∏çÊâßË°å
        return false;
    }
    
    // Êõ¥Êñ∞ offset
    offsetX = targetOffsetX;
    offsetY = targetOffsetY;
    
    // ÂêåÊ≠•Â±èÂπïÂùêÊ†á
    syncScreenCoords();
    
    // Ê†áËÆ∞ÂùêÊ†áÁ≥ªÁºìÂ≠òÈúÄË¶ÅÊõ¥Êñ∞ÔºàÂπ≥ÁßªÂèòÂåñÔºâ
    invalidateCoordinateCache();
    
    draw();
    return true;
}

// Êõ¥Êñ∞ÁªòÂà∂ÂÖÉÁ¥†Èù¢Êùø
function uiUpdateElementPanel() {
    const elementsList = document.getElementById('elementsList');
    const elementCount = document.getElementById('elementCount');
    if (!elementsList || !elementCount) {
        console.error('Elements panel DOM elements not found!', { elementsList, elementCount });
        return;
    }

    // Êõ¥Êñ∞ÂÖÉÁ¥†Êï∞Èáè
    elementCount.textContent = ''+elements.length;

    // Ëé∑ÂèñÂΩìÂâç UI ÂàóË°®‰∏≠ÁöÑÂÖÉÁ¥†ID
    const currentElements = Array.from(elementsList.children).map(item =>
        parseInt(item.getAttribute('data-element-id'))
    ).filter(id => !isNaN(id));
    // Ëé∑ÂèñÂΩìÂâçÁªòÂà∂ÂÖÉÁ¥†ÁöÑIDÂàóË°®
    const newElements = elements.map(el => el.id);
    // ÊØîËæÉ‰∏§‰∏™ÂàóË°®ÊòØÂê¶Áõ∏Âêå
    const listsEqual = currentElements.length === newElements.length &&
                       currentElements.every((id, index) => id === newElements[index]);

    // Â¶ÇÊûúÂàóË°®ÂÖÉÁ¥†Êú™ÂèëÁîüÂèòÂåñÔºåÂè™Êõ¥Êñ∞ÂèØËßÅÊÄßÁä∂ÊÄÅ
    if (listsEqual && elements.length > 0) {
        elements.forEach(element => {
            const elementItem = elementsList.querySelector(`[data-element-id="${element.id}"]`);
            if (elementItem) {
                const toggleBtn = elementItem.querySelector('.element-btn.toggle');
                if (toggleBtn) {
                    toggleBtn.textContent = element.visible ? LangText.HIDE[LANG] : LangText.SHOW_BTN[LANG];
                }
                elementItem.className = `element-item ${element.visible ? '' : 'hidden'}`;
            }
        });
        return;
    }

    // ÂàóË°®ÂèëÁîüÂèòÂåñÔºåÈáçÊñ∞Ê∏≤Êüì„ÄÇ‰∏îÂΩìÊ≤°ÊúâÂÖÉÁ¥†Êó∂ÔºåÊòæÁ§∫ÊèêÁ§∫
    if (elements.length === 0) {
        elementsList.innerHTML = '<div class="empty-message">ÊöÇÊó†ÁªòÂà∂ÂÖÉÁ¥†<br><small>ÂèåÂáªÂàõÂª∫ÁÇπÔºåÊãñÊãΩÂàõÂª∫ÂõæÂΩ¢</small></div>';
        return;
    }

    // ÁîüÊàêÂÖÉÁ¥†ÂàóË°®
    elementsList.innerHTML = '';
    elements.forEach((element) => {
        const elementItem = document.createElement('div');
        const isNewElement = !currentElements.includes(element.id);

        elementItem.className = `element-item ${element.visible ? '' : 'hidden'} ${isNewElement ? 'new-item' : ''} ${selectedElement === element ? 'selected' : ''}`;
        elementItem.setAttribute('data-type', element.type);
        elementItem.setAttribute('data-element-id', element.id);

        // Ê∑ªÂä†ÁÇπÂáªÈÄâ‰∏≠ÂäüËÉΩ
        elementItem.addEventListener('click', function(e) {
            // Â¶ÇÊûúÁÇπÂáªÁöÑÊòØÊåâÈíÆÔºå‰∏çËß¶ÂèëÈÄâ‰∏≠
            if (e.target.classList.contains('element-btn')) {
                return;
            }
            // ÊéíÈô§ Ctrl ÈîÆÔºåÈÅøÂÖç‰∏éÂÖ∂‰ªñÊìç‰ΩúÂÜ≤Á™Å
            if (e.ctrlKey || e.metaKey) {
                return;
            }
            uiSelectElement(element);
        });

        // Ê∑ªÂä†ÂèåÂáªÊâìÂºÄÂ±ûÊÄßÈù¢ÊùøÂäüËÉΩ
        elementItem.addEventListener('dblclick', function(e) {
            // Â¶ÇÊûúÂèåÂáªÁöÑÊòØÊåâÈíÆÔºå‰∏çËß¶ÂèëÊâìÂºÄÂ±ûÊÄß
            if (e.target.classList.contains('element-btn')) {
                return;
            }
            e.stopPropagation();
            
            // Ctrl + ÂèåÂáªÔºöÂÆö‰ΩçÂà∞ÂÖÉÁ¥†‰∏≠ÂøÉ
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault(); // ÈòªÊ≠¢ÈªòËÆ§Ë°å‰∏∫ÔºåÈò≤Ê≠¢ÊñáÊú¨ÈÄâÊã©
                uiCenterElementOnScreen(element);
                return;
            }
            
            // ÊôÆÈÄöÂèåÂáªÔºöÊâìÂºÄÂ±ûÊÄßÈù¢Êùø
            UIShowPropertyPanel(element.id);
        });

        // Â±èËîΩÂè≥ÈîÆËèúÂçïÔºåÈÅøÂÖç Ctrl + Â∑¶ÈîÆË¢´ÂΩì‰ΩúÂè≥ÈîÆÂ§ÑÁêÜ
        elementItem.addEventListener('contextmenu', function(e) {
            e.preventDefault();
            e.stopPropagation();
        });

        // ÈòªÊ≠¢ mousedown Êó∂ÁöÑÊñáÊú¨ÈÄâÊã©ÔºàÁâπÂà´ÊòØ Ctrl + ÁÇπÂáªÊó∂Ôºâ
        elementItem.addEventListener('mousedown', function(e) {
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault(); // ÈòªÊ≠¢ÊñáÊú¨ÈÄâÊã©
                e.stopPropagation(); // ÈòªÊ≠¢‰∫ã‰ª∂ÂÜíÊ≥°
            }
        });

        // ÂêåÊó∂Âú® selectstart ‰∫ã‰ª∂‰∏≠ÈòªÊ≠¢ÊñáÊú¨ÈÄâÊã©
        elementItem.addEventListener('selectstart', function(e) {
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                return false;
            }
        });

        HTMLElementListItem(element, elementItem, LANG);

        elementsList.appendChild(elementItem);

        // Âú®Âä®ÁîªÂÆåÊàêÂêéÁßªÈô§ new-item Á±ªÂêçÔºå‰ª•ÂÖçÈáçÂ§çËß¶ÂèëÂä®Áîª
        if (isNewElement) requestAnimationFrame(() => { setTimeout(() => { elementItem.classList.remove('new-item'); }, 150); });
    });
}
// ÈÄâÊã©ÊåáÂÆöÁªòÂà∂ÂÖÉÁ¥†
function uiSelectElement(element) {

    // Â¶ÇÊûúÁÇπÂáªÁöÑÊòØÂ∑≤ÈÄâ‰∏≠ÁöÑÂÖÉÁ¥†ÔºåÂàôÊâßË°åÂèñÊ∂àÈÄâ‰∏≠ÈÄªËæë
    if (selectedElement === element) {
        uiUnselectElement();
        return;
    }

    // ÂèñÊ∂à‰πãÂâçÁöÑÈÄâ‰∏≠
    if (selectedElement) {
        const prevItem = document.querySelector(`[data-element-id="${selectedElement.id}"]`);
        if (prevItem) {
            prevItem.classList.remove('selected');
        }
    }

    // ÈÄâ‰∏≠Êñ∞ÂÖÉÁ¥†
    selectedElement = element;
    const elementItem = document.querySelector(`[data-element-id="${element.id}"]`);
    if (elementItem) {
        elementItem.classList.add('selected');
    }

    // ÈÄâ‰∏≠ÂÖÉÁ¥†Êó∂‰∏çÁ´ãÂç≥ÊòæÁ§∫Ë∑üË∏™ÁÇπÔºåÁ≠âÂæÖÈº†Ê†áÁßªÂä®
    projectingPoint = null;
    projectionTangent = null;

    if (uiPropertyPanelShown && uiPropertyCurrentTab === 'props') {
        uiUpdateCommonIntrinsics();
        uiBuildParameters();
        uiBuildIntrinsics();
        uiBuildFeaturePoints();
    }

    draw();
}
// ÂèñÊ∂àÂΩìÂâçÈÄâÊã©ÁªòÂà∂ÂÖÉÁ¥†
function uiUnselectElement() {

    if (selectedElement) {
        const elementItem = document.querySelector(`[data-element-id="${selectedElement.id}"]`);
        if (elementItem) {
            elementItem.classList.remove('selected');
        }
    }

    selectedElement = null;
    projectingPoint = null;
    projectionTangent = null;

    draw(); // ÈáçÊñ∞Ê∏≤Êüì‰ª•ÈöêËóèË∑üË∏™ÁÇπÂíåÁâπÂæÅÁÇπ
}
// Âà†Èô§ÊåáÂÆöÁªòÂà∂ÂÖÉÁ¥†
function uiDeleteElement(id) {
    if (confirm('Á°ÆÂÆöË¶ÅÂà†Èô§Ëøô‰∏™ÂÖÉÁ¥†ÂêóÔºü')) {
        removeElement(id);
        draw(); // ÈáçÁªòÁîªÂ∏É

    }
}
// ÂàáÊç¢ÊåáÂÆöÁªòÂà∂ÂÖÉÁ¥†ÁöÑÊòæÁ§∫/ÈöêËóèÁä∂ÊÄÅ
function uiToggleElementVisibility(id) {
    let element = selectedElement;
    if (!element || element.id !== id) {
        element = elements.find(el => el.id === id);
        if (!element) return false;
    }
    element.visible = !element.visible;

    // Âè™Êõ¥Êñ∞ÂΩìÂâçÂÖÉÁ¥†ÁöÑÊòæÁ§∫Áä∂ÊÄÅÔºå‰∏çÈáçÊñ∞Ê∏≤ÊüìÊï¥‰∏™ÂàóË°®
    const elementItem = document.querySelector(`[data-element-id="${id}"]`);
    if (elementItem) {
        const toggleBtn = elementItem.querySelector('.element-btn.toggle');
        if (toggleBtn) {
            toggleBtn.textContent = element.visible ? LangText.HIDE[LANG] : LangText.SHOW_BTN[LANG];
        }
        elementItem.className = `element-item ${element.visible ? '' : 'hidden'}`;
    }

    draw(); // ÈáçÁªòÁîªÂ∏É

    return element.visible;
}

//------------------------------------

// ÂàùÂßãÂåñÁªëÂÆöÂá†‰ΩïÁªòÂà∂ËèúÂçï‰∫ã‰ª∂Â§ÑÁêÜ
document.querySelectorAll('.menu-item').forEach((item) => {
    item.addEventListener('click', (e) => {
        e.stopPropagation();

        UIHideGeometryMenu();

        if (!drawStart || !drawEnd) return;

        const type = item.getAttribute('data-type');
        switch (type) {
            case ""+ElementTypes.SEG:
                addElement(ElementTypes.SEG, Seg(drawStart, drawEnd), Attributes()); break;
            case ""+ElementTypes.RECTANGLE:
                addElement(ElementTypes.RECTANGLE, Rectangle(drawStart[0], drawStart[1], drawEnd[0], drawEnd[1]), Attributes());
                break;
            case ""+ElementTypes.CIRCLE:
                addElement(ElementTypes.CIRCLE, Circle(drawStart, drawEnd), Attributes());
                break;
            case ""+ElementTypes.ARC:
                enterArcCurvatureMode();
                return;
            case ""+ElementTypes.EASE:
                enterEaseMode();
                return;
            case ""+ElementTypes.BEZIER:
                enterBezierMode();
                return;
        }

        // ÈªòËÆ§Ê∏ÖÈô§ÁªòÂà∂Áä∂ÊÄÅ
        drawing = 0;
        draw();
    });
});

// Âá†‰ΩïÂÖÉÁ¥†ÁªòÂà∂ËèúÂçï
function UIShowGeometryMenu(x, y) {
    const menu = document.getElementById('drawMenu');
    const menuWidth = 140, menuHeight = 90;

    // Á°Æ‰øùËèúÂçï‰∏çË∂ÖÂá∫Â±èÂπïËæπÁïå
    const r = window.innerWidth - menuWidth, b = window.innerHeight - menuHeight;

    menu.style.left = (x > r ? r - 10 : x) + 'px';
    menu.style.top = (y > b ? b - 10 : y) + 'px';
    menu.style.display = 'block';
    uiDrawMenuShown = true;
}
function UIHideGeometryMenu() {
    const menu = document.getElementById('drawMenu');
    menu.style.display = 'none';
    uiDrawMenuShown = false;
}

// ËèúÂçïÁÇπÂáªÂå∫ÂüüÊ£ÄÊµã
function UIMenuHitTest(event) {
    const menu = document.getElementById('drawMenu');
    if (menu.style.display === 'none') return false;

    const rect = menu.getBoundingClientRect();
    return event.clientX >= rect.left &&
           event.clientX <= rect.right &&
           event.clientY >= rect.top &&
           event.clientY <= rect.bottom;
}

//------------------------------------

// ÂáΩÊï∞ÂÖÉÁ¥†ÁªòÂà∂ÂØπËØùÊ°Ü
function UIOpenFunctionDialog() {

    // Â¶ÇÊûúÂ±ûÊÄßÈù¢ÊùøÊâìÂºÄÔºåÁ¶ÅÊ≠¢ÊâìÂºÄÂáΩÊï∞ÂØπËØùÊ°Ü
    // + ËØ•Êìç‰Ωú‰Ωú‰∏∫Êé•Âè£ÔºåÈúÄË¶ÅÂú®ÂáΩÊï∞ÂÜÖÈÉ®ÂØπ‰æùËµñÊù°‰ª∂ÂÅöÈ™åËØÅ
    if (uiPropertyPanelShown) {
        return;
    }

    const overlay = document.querySelector('.function-overlay');
    const functionInput = document.getElementById('functionInput');
    const xMinInput = document.getElementById('xMinInput');
    const xMaxInput = document.getElementById('xMaxInput');

    if (functionInput) functionInput.value = uiFunctionLastExpression;
    if (xMinInput) xMinInput.value = uiFunctionLastXMin ? uiFunctionLastXMin : null;
    if (xMaxInput) xMaxInput.value = uiFunctionLastXMax ? uiFunctionLastXMax : null;

    // ‰∏∫ÊâÄÊúâËæìÂÖ•Ê°ÜÊ∑ªÂä†ÂõûËΩ¶ÈîÆÁõëÂê¨Âô®
    const inputs = [functionInput, xMinInput, xMaxInput];
    inputs.forEach(input => {
        if (input) {
            // ÁßªÈô§‰πãÂâçÂèØËÉΩÂ≠òÂú®ÁöÑÁõëÂê¨Âô®
            input.removeEventListener('keydown', uiFunctionHandleInputKeydown);
            // Ê∑ªÂä†Êñ∞ÁöÑÁõëÂê¨Âô®
            input.addEventListener('keydown', uiFunctionHandleInputKeydown);
        }
    });

    overlay.classList.add('show');
    if (functionInput) functionInput.focus();
}
function UICloseFunctionDialog() {
    const overlay = document.querySelector('.function-overlay');
    overlay.classList.remove('show');
}

// ÂõûËΩ¶ÈîÆÊâßË°åÁ°ÆËÆ§
function uiFunctionHandleInputKeydown(e) {
    if (e.key === 'Enter') {
        e.preventDefault();
        uiApplyFunction(); // ÊâßË°åÁªòÂà∂ÂáΩÊï∞
    }
}
// ËÆ°ÁÆóÂπ∂ÊòæÁ§∫ÂáΩÊï∞È¢ÑËßà‰ø°ÊÅØ
function uiPreviewFunction() {

    const functionInput = document.getElementById('functionInput');
    const xMinInput = document.getElementById('xMinInput');
    const xMaxInput = document.getElementById('xMaxInput');

    const expression = functionInput ? functionInput.value.trim() : '';
    let xMin = xMinInput && xMinInput.value.trim() ? parseFloat(xMinInput.value) : null;
    let xMax = xMaxInput && xMaxInput.value.trim() ? parseFloat(xMaxInput.value) : null;

    if (!expression) {
        alert('ËØ∑ËæìÂÖ•ÂáΩÊï∞Ë°®ËææÂºèÔºÅ');
        return;
    }

    function domain_ok() {
        if (xMin !== null) {
            if (isNaN(xMin)) return false;
            if (xMax === null) return true;
            if (isNaN(xMax)) return false;
            return xMin < xMax;
        }
        else return xMax === null || !isNaN(xMax);
    }
    if (!domain_ok()) {
        alert('ËØ∑ËæìÂÖ•ÊúâÊïàÁöÑxËåÉÂõ¥ÔºÅ');
        return;
    }

    try {
        // ËÆ°ÁÆóÂ§ö‰∏™ÊµãËØïÁÇπÊù•Â±ïÁ§∫ÂáΩÊï∞ÁâπÊÄß
        const testPoints = [];
        const step = (xMax - xMin) / 10;

        for (let i = 0; i <= 10; i++) {
            const x = xMin + i * step;
            const y = evalExpr(expression, x);
            if (isFinite(y)) {
                testPoints.push({ x: x.toFixed(2), y: y.toFixed(3) });
            }
        }

        if (testPoints.length === 0) {
            throw new Error('Âú®ÊåáÂÆöËåÉÂõ¥ÂÜÖÊó†Ê≥ïËÆ°ÁÆóÊúâÊïàÁöÑÂáΩÊï∞ÂÄº');
        }

        // ËÆ°ÁÆóÂáΩÊï∞ÁöÑ‰∏Ä‰∫õÂü∫Êú¨ÁâπÊÄß
        const yValues = testPoints.map(p => parseFloat(p.y));
        const minY = Math.min(...yValues);
        const maxY = Math.max(...yValues);
        const range = maxY - minY;

        // ÂàõÂª∫È¢ÑËßà‰ø°ÊÅØ
        let previewInfo = `‚úÖ ÂáΩÊï∞Ë°®ËææÂºèÊúâÊïàÔºÅ\n\n`;
        previewInfo += `üìä ÂáΩÊï∞ÁâπÊÄßÈ¢ÑËßàÔºö\n`;
        previewInfo += `‚Ä¢ Ë°®ËææÂºè: y = ${expression}\n`;

        // ÊòæÁ§∫ËåÉÂõ¥‰ø°ÊÅØÔºåÂ¶ÇÊûúÊòØÂ§ßËåÉÂõ¥ÂàôÊòæÁ§∫‰∏∫Êó†Á©∑
        const isLargeRange = Math.abs(xMax - xMin) > 150;
        const xRangeText = isLargeRange ?
            `(-‚àû, +‚àû) [ÈááÊ†∑ËåÉÂõ¥: ${xMin}, ${xMax}]` :
            `[${xMin}, ${xMax}]`;
        previewInfo += `‚Ä¢ xËåÉÂõ¥: ${xRangeText}\n`;
        previewInfo += `‚Ä¢ yËåÉÂõ¥: [${minY.toFixed(3)}, ${maxY.toFixed(3)}]\n`;
        previewInfo += `‚Ä¢ ÂÄºÂüüË∑®Â∫¶: ${range.toFixed(3)}\n\n`;

        previewInfo += `üéØ ÂÖ≥ÈîÆÁÇπÈ¢ÑËßà:\n`;
        previewInfo += `‚Ä¢ f(${xMin}) = ${testPoints[0].y}\n`;
        previewInfo += `‚Ä¢ f(${((xMin + xMax) / 2).toFixed(2)}) = ${testPoints[5].y}\n`;
        previewInfo += `‚Ä¢ f(${xMax}) = ${testPoints[testPoints.length - 1].y}\n\n`;

        previewInfo += `ÁÇπÂáª"ÁªòÂà∂"Â∞ÜÂáΩÊï∞Ê∑ªÂä†Âà∞ÁîªÂ∏É‰∏äÔºÅ`;

        alert(previewInfo);

    } catch (error) {
        alert('‚ùå ÂáΩÊï∞Ë°®ËææÂºèÈîôËØØÔºö\n\n' + error.message + '\n\nËØ∑Ê£ÄÊü•Ë°®ËææÂºèËØ≠Ê≥ïÊòØÂê¶Ê≠£Á°Æ„ÄÇ');
    }
}
// Â∫îÁî®ÂáΩÊï∞ÁªòÂà∂
function uiApplyFunction() {

    try {
        const functionInput = document.getElementById('functionInput');
        const xMinInput = document.getElementById('xMinInput');
        const xMaxInput = document.getElementById('xMaxInput');

        const expression = functionInput ? functionInput.value.trim() : '';
        let xMin = xMinInput && xMinInput.value.trim() ? parseFloat(xMinInput.value) : null;
        let xMax = xMaxInput && xMaxInput.value.trim() ? parseFloat(xMaxInput.value) : null;

        // È™åËØÅËæìÂÖ•
        if (!expression) {
            alert('ËØ∑ËæìÂÖ•ÂáΩÊï∞Ë°®ËææÂºèÔºÅ');
            return;
        }

        function domain_ok() {
            if (xMin !== null) {
                if (isNaN(xMin)) return false;
                if (xMax === null) return true;
                if (isNaN(xMax)) return false;
                return xMin < xMax;
            }
            else return xMax === null || !isNaN(xMax);
        }
        if (!domain_ok()) {
            alert('ËØ∑ËæìÂÖ•ÊúâÊïàÁöÑxËåÉÂõ¥ÔºÅ');
            return;
        }

        // Êõ¥Êñ∞ÂΩìÂâçÂáΩÊï∞ÂèÇÊï∞
        uiFunctionLastExpression = expression;
        uiFunctionLastXMin = xMin;
        uiFunctionLastXMax = xMax;

        try {

            // Áõ¥Êé•‰ΩøÁî®FuncÊûÑÈÄ†ÂáΩÊï∞ÁîüÊàêÁÇπ
            const element = Func(expression, [xMin, xMax]);
            if (element.points.length === 0) {
                alert('Êó†Ê≥ïËÆ°ÁÆóÂáΩÊï∞ÂÄºÔºåËØ∑Ê£ÄÊü•Ë°®ËææÂºèÔºÅ');
                return;
            }

            // ÂÖ≥Èó≠ÂØπËØùÊ°Ü
            UICloseFunctionDialog();

            addElement(ElementTypes.FUNCTION, element, Attributes());

            // ÈáçÁªòÁîªÂ∏É
            draw();

        } catch (error) {
            console.error('ÂáΩÊï∞ÁÇπËÆ°ÁÆóÈîôËØØ:', error);
            alert('ÂáΩÊï∞Ë°®ËææÂºèÈîôËØØÔºö' + error.message);
        }

    } catch (error) {
        console.error('applyFunctionÂ§ñÂ±ÇÈîôËØØ:', error);
        alert('Â∫îÁî®ÂáΩÊï∞Êó∂Âá∫ÈîôÔºö' + error.message);
    }
}

//------------------------------------

// ÂàùÂßãÂåñÁªëÂÆöÂ±ûÊÄßÂØπËØùÊ°Ü‰∫ã‰ª∂Â§ÑÁêÜ
document.getElementById('attributesOverlay').addEventListener('click', function(e) {
    if (e.target === this) {
        UICloseAttributes();
    }
});

// ÁªòÂà∂ÂÖÉÁ¥†ËÆæÁΩÆÂØπËØùÊ°Ü
function UIOpenAttributes(elementId) {
    if (!selectedElement || selectedElement.id !== elementId) {
        uiSelectElement(elements.find(el => el.id === elementId));
        if (!selectedElement) return;
    }

    uiAttributesDialogShown = true;

    // ÂàùÂßãÂåñÈ¢úËâ≤ÈÄâÊã©Âô®
    const colorPickerGroup = document.getElementById('colorPickerGroup');
    colorPickerGroup.innerHTML = '';

    LINE_AVAILABLE_COLORS.forEach(color => {
        const colorOption = document.createElement('div');
        colorOption.className = 'color-option';

        if (color === AUTO_COLOR) {
            // Ëá™Âä®Ëâ≤ÊòæÁ§∫‰∏∫Ê∏êÂèòÊïàÊûú
            colorOption.classList.add('auto-color');
            colorOption.innerHTML = '<span>Ëá™Âä®</span>';
        } else {
            colorOption.style.backgroundColor = color;
        }

        colorOption.onclick = () => uiActSelectColor();

        // Ê£ÄÊü•ÂΩìÂâçÂÖÉÁ¥†ÁöÑÈ¢úËâ≤ÊòØÂê¶ÂåπÈÖç
        const currentColor = selectedElement.props.color;
        if (isColorMatch(currentColor, color)) {
            colorOption.classList.add('selected');
        }

        colorPickerGroup.appendChild(colorOption);
    });

    // ÂàùÂßãÂåñÁ∫øÂÆΩËÆæÁΩÆ
    const currentWidth = selectedElement.attrs.width || DEFAULT_LINE_WIDTH;
    document.getElementById('widthSlider').value = currentWidth;
    uiUpdateWidthPreview(currentWidth);

    // ÊòæÁ§∫ÂØπËØùÊ°Ü
    document.getElementById('attributesOverlay').classList.add('show');
}
function UICloseAttributes() {
    document.getElementById('attributesOverlay').classList.remove('show');
    uiAttributesDialogShown = false;
}

// Â∫îÁî®ÂÖÉÁ¥†Â±ûÊÄßËÆæÁΩÆ
function uiApplyAttributes() {
    if (!uiAttributesDialogShown || !selectedElement) return;

    // Êõ¥Êñ∞È¢úËâ≤
    const selectedColor = document.querySelector('.color-option.selected');
    if (selectedColor) {
        selectedElement.attrs.color = selectedColor.style.backgroundColor;
    }

    // Êõ¥Êñ∞Á∫øÂÆΩ
    const widthSlider = document.getElementById('widthSlider');
    if (widthSlider) {
        selectedElement.attrs.width = parseFloat(widthSlider.value);
    }

    // ÈáçÁªòÁîªÂ∏É
    draw();

    // ÂÖ≥Èó≠ÂØπËØùÊ°Ü
    UICloseAttributes();
}

// Êõ¥Êñ∞Á∫øÂÆΩÈ¢ÑËßà
function uiUpdateWidthPreview(width) {
    const widthValue = document.getElementById('widthValue');
    const widthPreview = document.getElementById('widthPreview');
    if (widthValue) {
        widthValue.textContent = parseFloat(width).toFixed(1);
    }
    if (widthPreview) {
        widthPreview.style.height = Math.max(1, width) + 'px';
        widthPreview.style.backgroundColor = '#666';
        widthPreview.style.width = '100px';
        widthPreview.style.borderRadius = '2px';
        widthPreview.style.margin = '10px 0';
    }
}

// ÈÄâÊã©È¢úËâ≤
function uiActSelectColor() {
    // ÁßªÈô§‰πãÂâçÁöÑÈÄâ‰∏≠Áä∂ÊÄÅ
    document.querySelectorAll('.color-option').forEach(option => {
        option.classList.remove('selected');
    });
    // ËÆæÁΩÆÊñ∞ÁöÑÈÄâ‰∏≠Áä∂ÊÄÅ
    event.target.classList.add('selected');
}

//------------------------------------

document.getElementById('flip-section').querySelectorAll('input').forEach(input => { input.oninput = input.onchange; })
document.getElementById('shear-section').querySelectorAll('input').forEach(input => { input.oninput = input.onchange; })
document.getElementById('rotation-section').querySelectorAll('input').forEach(input => { input.oninput = input.onchange; })
document.getElementById('scale-section').querySelectorAll('input').forEach(input => { input.oninput = input.onchange; })
document.getElementById('translation-section').querySelectorAll('input').forEach(input => { input.oninput = input.onchange; })

// ÁâπÊÄßÈù¢ÊùøÂáΩÊï∞
function UIShowPropertyPanel(elementId) {

    if (!selectedElement || selectedElement.id !== elementId) {
        selectedElement = elements.find(el => el.id === elementId);
        if (!selectedElement) return;
    }

    // ÈöêËóèÂÖÉÁ¥†Èù¢ÊùøÔºåÊòæÁ§∫ÂèòÊç¢Èù¢Êùø
    UIHideElementsPanel();

    // Â§á‰ªΩÂÖÉÁ¥†ÂéüÂßãÊï∞ÊçÆ
    uiEditingSaved0 = JSON.parse(JSON.stringify(selectedElement.props));
    uiEditingSaved1 = JSON.parse(JSON.stringify(selectedElement.transform));

    // Êõ¥Êñ∞Â°´ÂÖÖÂΩìÂâçÂÖÉÁ¥†ÁöÑÂ±ûÊÄßÊï∞ÊçÆ
    uiUpdateProperties(selectedElement);

    // Ê£ÄÊü•ÂΩìÂâçÊøÄÊ¥ªÁöÑÊ†áÁ≠æÈ°µÔºàËøêË°åËÆ∞ÂΩïÊúÄÂêé‰∏ÄÊ¨°ÊøÄÊ¥ªÁöÑ tabÔºâ
    uiPropertyCurrentTab = 'props'; // ÈªòËÆ§Ê†áÁ≠æÈ°µ
    const activeTab = document.querySelector('.property-tab.active');
    if (activeTab) {
        uiPropertyCurrentTab = activeTab.getAttribute('data-tab');
        uiActiveTransform(['flip', 'shear', 'rotation', 'scale', 'translation'].indexOf(uiPropertyCurrentTab) + 1);
    }

    // ÊòæÁ§∫Â±ûÊÄßÈù¢Êùø
    document.getElementById('propertyPanel').classList.add('show');
    uiPropertyPanelShown = true;

    // Á´ãÂç≥ÈáçÊñ∞ÁªòÂà∂ÁîªÂ∏É‰ª•ÊòæÁ§∫‰∏≠ÂøÉÁÇπÂíåËßÇÊµãÁÇπ
    draw();
}
function UIHidePropertyPanel() {

    if (uiPropertyPanelShown) {
        if (uiEditingSaved0) {
            selectedElement.props = JSON.parse(JSON.stringify(uiEditingSaved0));
            uiEditingSaved0 = null;
        }
        if (uiEditingSaved1) {
            selectedElement.transform = JSON.parse(JSON.stringify(uiEditingSaved1));
            uiEditingSaved1 = null;
        }
        uiPropertyPanelShown = false;
    }
    document.getElementById('propertyPanel').classList.remove('show');

    uiPropertyCurrentTab = null;
    observingPointInScreen = observingPoint = null;
    projectingPoint = projectionTangent = null;

    // Á´ãÂç≥ÈáçÊñ∞ÁªòÂà∂ÁîªÂ∏É‰ª•ÁßªÈô§‰∏≠ÂøÉÁÇπ
    draw();

    // ËøîÂõûÂà∞ÂÖÉÁ¥†Èù¢Êùø
    UIShowElementsPanel();
}

// ÂàáÊç¢ÁâπÊÄßÊ†áÁ≠æÈ°µ
function uiSwitchPropertiesTab(tabName) {

    if (!uiPropertyPanelShown || !selectedElement) return;

    // Êõ¥Êñ∞ÂΩìÂâçÊ†áÁ≠æÈ°µ
    uiPropertyCurrentTab = tabName;

    // ÁßªÈô§ÊâÄÊúâÊ¥ªÂä®Áä∂ÊÄÅ
    document.querySelectorAll('.property-tab').forEach(tab => {
        tab.classList.remove('active');
    });
    document.querySelectorAll('.property-section').forEach(section => {
        section.classList.remove('active');
    });

    // ÊøÄÊ¥ªÈÄâ‰∏≠ÁöÑÊ†áÁ≠æÈ°µ
    const activeTab = document.querySelector(`[onclick*="'${tabName}')"]`);
    if (activeTab) {
        activeTab.classList.add('active');
    }
    // ÊøÄÊ¥ªÂØπÂ∫îÁöÑÂÜÖÂÆπÂå∫Âüü
    const section = document.getElementById(tabName + '-section');
    if (section) {
        section.classList.add('active');
    }

    // Â¶ÇÊûúÂàáÊç¢Âà∞ÁâπÂæÅÊ†áÁ≠æÈ°µÔºåÊõ¥Êñ∞ÁâπÂæÅ‰ø°ÊÅØ
    if (tabName === 'props') {
        uiActiveTransform(0);
    }
    else uiActiveTransform(['flip', 'shear', 'rotation', 'scale', 'translation'].indexOf(tabName) + 1);

    draw();
}
// ÈáçÁΩÆÁâπÊÄß‰∏∫ÂéüÂÄºÔºàÂèñÊ∂àÂèòÊõ¥Ôºâ
function uiResetProperties() {
    if (!uiPropertyPanelShown || (!uiEditingSaved0 && !uiEditingSaved1) || !selectedElement) return;

    // Â¶ÇÊûúÂú®ÁºñËæëÁä∂ÊÄÅÔºåÊÅ¢Â§çÂà∞ÂéüÂßãÁä∂ÊÄÅ
    if (uiEditingSaved0) selectedElement.props = JSON.parse(JSON.stringify(uiEditingSaved0));
    if (uiEditingSaved1) selectedElement.transform = JSON.parse(JSON.stringify(uiEditingSaved1));

    // Êõ¥Êñ∞Èù¢ÊùøÊòæÁ§∫
    uiUpdateProperties(selectedElement);

    // ÈáçÁªò
    draw();
}
// Â∫îÁî®ÁâπÊÄßËÆæÁΩÆ
function uiApplyProperties() {
    if (!uiPropertyPanelShown || !selectedElement) return;

    // ÈáçÊñ∞ÂàùÂßãÂåñ‰∏¥Êó∂Áä∂ÊÄÅÔºå‰ª•ÂΩìÂâçÂ∫îÁî®ÂêéÁöÑÁä∂ÊÄÅ‰∏∫Êñ∞Âü∫ÂáÜ
    uiEditingSaved0 = JSON.parse(JSON.stringify(selectedElement.props));
    uiEditingSaved1 = JSON.parse(JSON.stringify(selectedElement.transform));

    // Êõ¥Êñ∞ÁïåÈù¢ÊòæÁ§∫
    uiUpdateProperties(selectedElement);
}

// Â∑•ÂÖ∑ÂáΩÊï∞: Áªô input Êéß‰ª∂ËµãÂÄºÔºåÂéüÂÄº‰Ωú‰∏∫ placeholder
function uiInitInputValue(input, currentValue, originalValue, decimalPlaces = DECIMAL_PRECISION_DEFAULT) {
    if (!input) return;

    // Ê£ÄÊü• currentValue ÊòØÂê¶‰∏∫ null Êàñ undefined
    if (currentValue == null) {
        input.value = '';
        return;
    }

    input.value = parseFloat(currentValue.toFixed(decimalPlaces));
    if (originalValue !== undefined) {
        input.placeholder = `${parseFloat(originalValue.toFixed(decimalPlaces))}`;
        input.style.backgroundColor = 'var(--input-focus-bg)'; // ‰ΩøÁî®CSSÂèòÈáèÊ†áËØÜÁºñËæëÁä∂ÊÄÅ
    } else {
        input.placeholder = '';
        input.style.backgroundColor = '';
    }
}
function uiSetInputValue(input, value, decimalPlaces = DECIMAL_PRECISION_DEFAULT) {
    if (input)  input.value = value == null ? '' : parseFloat(value.toFixed(decimalPlaces));
}
// Â∑•ÂÖ∑ÂáΩÊï∞: ËÆæÁΩÆËßÇÊµãÊñπÂêëËæìÂÖ•Ê°ÜÁöÑÂÄºÔºåÊîØÊåÅ null ÂÄºÊòæÁ§∫‰∏∫Á©∫
function uiInitObserveDirInputValue(input, currentValue, originalValue, decimalPlaces = DECIMAL_PRECISION_ANGLE) {
    if (!input) return;

    // null ÂÄºÊòæÁ§∫‰∏∫Á©∫Ôºåplaceholder ÊòæÁ§∫ TOWARD_CENTROID
    if (currentValue === null) {
        input.value = '';
        input.placeholder = LangText.TOWARD_CENTROID[LANG];
        input.style.backgroundColor = originalValue === null ? '' : 'var(--input-focus-bg)';
        return;
    }

    // Èùû null ÂÄºÊ≠£Â∏∏ÊòæÁ§∫
    input.value = parseFloat(currentValue.toFixed(decimalPlaces));
    if (originalValue !== undefined && originalValue !== null) {
        input.placeholder = `${parseFloat(originalValue.toFixed(decimalPlaces))}`;
        input.style.backgroundColor = 'var(--input-focus-bg)';
    } else if (originalValue === null) {
        input.placeholder = LangText.TOWARD_CENTROID[LANG];
        input.style.backgroundColor = 'var(--input-focus-bg)';
    } else {
        input.placeholder = '';
        input.style.backgroundColor = '';
    }
}
function uiSetObserveDirInputValue(input, value, decimalPlaces = DECIMAL_PRECISION_ANGLE) {
    if (input)  input.value = value == null ? '' : parseFloat(value.toFixed(decimalPlaces));
}
// Â∑•ÂÖ∑ÂáΩÊï∞: Áªô checkbox Êéß‰ª∂ËµãÂÄºÔºå‰ª•‰∏çÂêåÈ¢úËâ≤Âå∫ÂàÜÊòØÂê¶ÂíåÂéüÂÄº‰∏çÂêå
function uiInitCheckboxValue(checkbox, currentValue, originalValue) {
    if (!checkbox) return;
    checkbox.checked = currentValue;
    if (originalValue !== undefined && currentValue !== originalValue) {
        checkbox.style.boxShadow = '0 0 3px #4CAF50';
    } else {
        checkbox.style.boxShadow = '';
    }
}

// ÊûÑÈÄ†ÁâπÊÄßË°®ÂçïÈ°π
function uiBuildParameters() {
    if (!selectedElement) return;
    const container = document.getElementById('elementParameters');
    if (!container) return;
    container.innerHTML = '';
    switch (selectedElement.type) {
        case ElementTypes.POINT:
            HTMLPointParameters(selectedElement, container, LANG);
            break;
        case ElementTypes.SEG:
            HTMLLineParameters(selectedElement, container, LANG);
            break;
        case ElementTypes.RECTANGLE:
            HTMLRectangleParameters(selectedElement, container, LANG);
            break;
        case ElementTypes.CIRCLE:
            HTMLCircleParameters(selectedElement, container, LANG);
            break;
        case ElementTypes.ARC:
            HTMLArcParameters(selectedElement, container, LANG);
            break;
        case ElementTypes.POLYGON:
            HTMLPolygonParameters(selectedElement, container, LANG);
            break;
        case ElementTypes.EASE:
            HTMLEaseParameters(selectedElement, container, LANG);
            break;
        case ElementTypes.BEZIER:
            HTMLBezierParameters(selectedElement, container, LANG);
            break;
        case ElementTypes.FUNCTION:
            HTMLFunctionParameters(selectedElement, container, LANG);
            break;
    }
}
function uiBuildIntrinsics() {
    if (!selectedElement) return;
    const propertiesGroup = document.getElementById('propertiesGroup');
    const container = document.getElementById('dynamicProperties');
    if (!propertiesGroup || !container) return;

    container.innerHTML = '';
    switch (selectedElement.type) {
        case ElementTypes.POINT:
            propertiesGroup.style.display = 'none';
            return;
        case ElementTypes.SEG:
            HTMLLineProperties(selectedElement, container, LANG);
            break;
        case ElementTypes.RECTANGLE:
            HTMLRectangleProperties(selectedElement, container, LANG);
            break;
        case ElementTypes.CIRCLE:
            HTMLCircleProperties(selectedElement, container, LANG);
            break;
        case ElementTypes.ARC:
            HTMLArcProperties(selectedElement, container, LANG);
            break;
        case ElementTypes.POLYGON:
            HTMLPolygonProperties(selectedElement, container, LANG);
            break;
        case ElementTypes.EASE:
            HTMLEaseProperties(selectedElement, container, LANG);
            break;
        case ElementTypes.BEZIER:
            HTMLBezierProperties(selectedElement, container, LANG);
            break;
        case ElementTypes.FUNCTION:
            HTMLFunctionProperties(selectedElement, container, LANG);
            break;
        default:
            container.innerHTML = '<p>ÂΩìÂâçÂÖÉÁ¥†Á±ªÂûã‰∏çÊîØÊåÅÂä®ÊÄÅÁâπÊÄß„ÄÇ</p>';
    }
    propertiesGroup.style.display = 'block';
}
function uiBuildFeaturePoints() {
    if (!selectedElement) return;

    const featurePointsGroup = document.getElementById('featurePointsGroup');
    const container = document.getElementById('featurePoints');
    if (!featurePointsGroup || !container) return;

    container.innerHTML = '';
    if (selectedElement.type === ElementTypes.POINT ||
        selectedElement.type === ElementTypes.CIRCLE) {
        featurePointsGroup.style.display = 'none';
        return;
    }
    HTMLUnifiedFeaturePoints(selectedElement, container, LANG);
    featurePointsGroup.style.display = 'block';
}
function uiActiveTransform(transform) {

    if (!(activeTransform = transform)) {
        observingPointInScreen = observingPoint = null;
        return;
    }

    switch (transform) {
        case TRANSFORM.FLIP: const flip = selectedElement.transform.flip;
            observingPoint = flip.observePos;
            document.getElementById('flipObservePosLSConstrain').checked
                = constrainObservePosLocalSymmetry = flip.observePosLSConstrain
            document.getElementById('flipObserveDirLSConstrain').checked
                = constrainObserveDirLocalSymmetry = flip.observeDirLSConstrain;

            // Êõ¥Êñ∞ÁøªËΩ¨Áü©ÈòµÊòæÁ§∫
            uiUpdateFlipMatrix();
            break;
        case TRANSFORM.SHEAR: const shear = selectedElement.transform.shear;
            observingPoint = shear.observePos;
            document.getElementById('shearObservePosLSConstrain').checked
                = constrainObservePosLocalSymmetry = shear.observePosLSConstrain;
            document.getElementById('shearObserveDirLSConstrain').checked
                = constrainObserveDirLocalSymmetry = shear.observeDirLSConstrain;
            break;
        case TRANSFORM.ROTATION: const rotation = selectedElement.transform.rotation;
            observingPoint = rotation.observePos;
            document.getElementById('rotationObservePosLSConstrain').checked
                = constrainObservePosLocalSymmetry = rotation.observePosLSConstrain;
            uiUpdateRotationMatrix();
            break;
        case TRANSFORM.SCALE: const scale = selectedElement.transform.scale;
            observingPoint = scale.observePos;
            document.getElementById('scaleObservePosLSConstrain').checked
                = constrainObservePosLocalSymmetry = scale.observePosLSConstrain;
            break;
        default: observingPointInScreen = observingPoint = null;
    }

    observingRelevant = null;
    if (observingPoint) {

        observingPointInScreen = mathToScreen(observingPoint[0], observingPoint[1]);

        const relativity = getObserveRelativity(observingPoint, selectedElement);
        if (relativity) { observingPoint[2] = relativity[2];
            if (observingPoint[2] > 0) observingRelevant = observeDirectionRangeForLocalSymmetry(observingPoint, selectedElement);
        }
    }

    // Ê†πÊçÆËßÇÊµãÁÇπÔºàÁöÑÁõ∏ÂØπÊÄßÔºâÔºåÊõ¥Êñ∞ËßÇÊµãÊñπÂêëÁöÑÂ±ÄÈÉ®ÂØπÁß∞Á∫¶ÊùüÁöÑÂèØÁî®ÊÄß
    uiUpdateObserveDirLocalSymmetryConstrainValid();
}

// Êõ¥Êñ∞ÁâπÊÄßÊòæÁ§∫
function uiUpdateProperties() {
    if (!selectedElement) return;
    const transform = selectedElement.transform;

    uiBuildParameters();
    uiUpdateCommonIntrinsics();
    uiBuildIntrinsics();
    uiBuildFeaturePoints();

    // ÁøªËΩ¨ÂèòÊç¢Â±ûÊÄß
    const flipObserveXInput = document.getElementById('flipObserveX');
    const flipObserveYInput = document.getElementById('flipObserveY');
    const flipObserveDirectionInput = document.getElementById('flipObserveD');
    const flipForwardYCheckbox = document.getElementById('flipForwardY');
    const flipSideXCheckbox = document.getElementById('flipSideX');

    uiInitInputValue(flipObserveXInput, transform.flip.observePos[0],
        uiEditingSaved1?.flip?.observePos?.[0]);
    uiInitInputValue(flipObserveYInput, transform.flip.observePos[1],
        uiEditingSaved1?.flip?.observePos?.[1]);
    uiInitObserveDirInputValue(flipObserveDirectionInput, transform.flip.observeDir,
        uiEditingSaved1?.flip?.observeDir);
    uiInitCheckboxValue(flipForwardYCheckbox, transform.flip.forwardY || false,
        uiEditingSaved1?.flip?.forwardY);
    uiInitCheckboxValue(flipSideXCheckbox, transform.flip.sideX || false,
        uiEditingSaved1?.flip?.sideX);

    // Êõ¥Êñ∞ÁøªËΩ¨Áü©ÈòµÊòæÁ§∫
    uiUpdateFlipMatrix();

    // Ââ™ÂàáÂèòÊç¢Â±ûÊÄß
    const shearObserveXInput = document.getElementById('shearObserveX');
    const shearObserveYInput = document.getElementById('shearObserveY');
    const shearObserveDirectionInput = document.getElementById('shearObserveD');
    const shearForwardYInput = document.getElementById('shearForwardY');
    const shearSideXInput = document.getElementById('shearSideX');

    uiInitInputValue(shearObserveXInput, transform.shear.observePos[0],
        uiEditingSaved1?.shear?.observePos?.[0]);
    uiInitInputValue(shearObserveYInput, transform.shear.observePos[1],
        uiEditingSaved1?.shear?.observePos?.[1]);
    uiInitObserveDirInputValue(shearObserveDirectionInput, transform.shear.observeDir,
        uiEditingSaved1?.shear?.observeDir);
    uiInitInputValue(shearForwardYInput, transform.shear.forwardY || 0,
        uiEditingSaved1?.shear?.forwardY);
    uiInitInputValue(shearSideXInput, transform.shear.sideX || 0,
        uiEditingSaved1?.shear?.sideX);

    // ÊóãËΩ¨ÂèòÊç¢Â±ûÊÄß
    const rotationObserveXInput = document.getElementById('rotationObserveX');
    const rotationObserveYInput = document.getElementById('rotationObserveY');
    const rotationAngleInput = document.getElementById('rotationAngle');

    uiInitInputValue(rotationObserveXInput, transform.rotation.observePos[0],
        uiEditingSaved1?.rotation?.observePos?.[0]);
    uiInitInputValue(rotationObserveYInput, transform.rotation.observePos[1],
        uiEditingSaved1?.rotation?.observePos?.[1]);
    uiInitInputValue(rotationAngleInput, transform.rotation.angle,
        uiEditingSaved1?.rotation?.angle, DECIMAL_PRECISION_ANGLE);

    // Áº©ÊîæÂèòÊç¢Â±ûÊÄß
    const scaleObserveXInput = document.getElementById('scaleObserveX');
    const scaleObserveYInput = document.getElementById('scaleObserveY');
    const scaleXInput = document.getElementById('scaleX');
    const scaleYInput = document.getElementById('scaleY');

    uiInitInputValue(scaleObserveXInput, transform.scale.observePos[0],
        uiEditingSaved1?.scale?.observePos?.[0]);
    uiInitInputValue(scaleObserveYInput, transform.scale.observePos[1],
        uiEditingSaved1?.scale?.observePos?.[1]);
    uiInitInputValue(scaleXInput, transform.scale.x,
        uiEditingSaved1?.scale?.x);
    uiInitInputValue(scaleYInput, transform.scale.y,
        uiEditingSaved1?.scale?.y);

    // Âπ≥ÁßªÂèòÊç¢Â±ûÊÄß
    const translationXInput = document.getElementById('translationX');
    const translationYInput = document.getElementById('translationY');

    uiInitInputValue(translationXInput, transform.translation[0],
        uiEditingSaved1?.translation?.[0]);
    uiInitInputValue(translationYInput, transform.translation[1],
        uiEditingSaved1?.translation?.[1]);

    // Êõ¥Êñ∞ËßÇÊµãÊñπÂêëÂ±ÄÂüüÂØπÁß∞ÊÄßcheckboxÁöÑÊòæÁ§∫Áä∂ÊÄÅ
    uiUpdateObserveDirLocalSymmetryConstrainValid();
}
// Êõ¥Êñ∞ÈÄöÁî®ÁâπÊÄß‰ø°ÊÅØ
function uiUpdateCommonIntrinsics() {
    if (!selectedElement) return;
    try {
        // Ëé∑ÂèñË°åÂÖÉÁ¥†
        const geometricCenterRow = document.getElementById('geometricCenterRow');
        const areaDimensionsRow = document.getElementById('areaDimensions');
        const boundingCenterRow = document.getElementById('boundingCenterRow');
        const boundingDimensionsRow = document.getElementById('boundingDimensions');

        // Point Âíå Func Á±ªÂûã‰∏çÊèê‰æõ box Âíå centroid ÂäüËÉΩ
        if (selectedElement.type === ElementTypes.POINT || selectedElement.type === ElementTypes.FUNCTION) {
            // ÈöêËóèÊâÄÊúâÁõ∏ÂÖ≥Ë°å
            if (geometricCenterRow) geometricCenterRow.style.display = 'none';
            if (areaDimensionsRow) areaDimensionsRow.style.display = 'none';
            if (boundingCenterRow) boundingCenterRow.style.display = 'none';
            if (boundingDimensionsRow) boundingDimensionsRow.style.display = 'none';
            return;
        }

        // Ê£ÄÊü•ÊòØÂê¶Êúâ centroid
        const hasCentroid = selectedElement.props.centroid !== undefined;
        if (geometricCenterRow) {
            geometricCenterRow.style.display = hasCentroid ? 'flex' : 'none';
        }

        // Ê£ÄÊü•ÊòØÂê¶Êúâ box
        const hasBox = selectedElement.props.box !== undefined;
        if (boundingCenterRow) {
            boundingCenterRow.style.display = hasBox ? 'flex' : 'none';
        }

        // ËÆ°ÁÆóÂá†‰Ωï‰∏≠ÂøÉÔºàË¥®ÂøÉÔºâ
        if (hasCentroid) {
            const geometricCenter = selectedElement.props.centroid;
            const geometricCenterElement = document.getElementById('geometricCenter');
            if (geometricCenterElement && geometricCenter) {
                const x = isFinite(geometricCenter[0]) ? geometricCenter[0] : 0;
                const y = isFinite(geometricCenter[1]) ? geometricCenter[1] : 0;
                geometricCenterElement.textContent = `(${x.toFixed(2)}, ${y.toFixed(2)})`;
            }
        }

        // ËÆ°ÁÆóÂ§ñÊé•Áü©ÂΩ¢‰ø°ÊÅØ
        if (hasBox) {
            const box = selectedElement.props.box;

            const boundingCenterElement = document.getElementById('boundingCenter');
            if (boundingCenterElement) {
                const x = isFinite(box[2]) ? box[2] : 0;
                const y = isFinite(box[3]) ? box[3] : 0;
                boundingCenterElement.textContent = `(${x.toFixed(2)}, ${y.toFixed(2)})`;
            }

            // Êõ¥Êñ∞Â§ñÊé•Áü©ÂΩ¢Â∞∫ÂØ∏ÔºàÂ¶ÇÊûúÊòæÁ§∫Ôºâ
            const boundingSizeElement = document.getElementById('boundingSize');
            if (boundingSizeElement) {
                const width = Math.abs(box[4] - box[2]); // right - left
                const height = Math.abs(box[3] - box[5]); // top - bottom
                boundingSizeElement.textContent = `${width.toFixed(2)} √ó ${height.toFixed(2)}`;
            }
        }

        // Êõ¥Êñ∞Èù¢ÁßØÊï∞ÂÄºÔºàÂ¶ÇÊûúÊòæÁ§∫Ôºâ
        if (hasCentroid) {
            const areaElement = document.getElementById('areaValue');
            if (areaElement && selectedElement.props.centroid && selectedElement.props.centroid[2] !== undefined) {
                areaElement.textContent = selectedElement.props.centroid[2].toFixed(2);
            }
        }

    } catch (error) {
        console.error('Error updating feature info:', error);
        // ÈöêËóèÊâÄÊúâË°å
        const geometricCenterRow = document.getElementById('geometricCenterRow');
        const areaDimensionsRow = document.getElementById('areaDimensions');
        const boundingCenterRow = document.getElementById('boundingCenterRow');
        const boundingDimensionsRow = document.getElementById('boundingDimensions');
        if (geometricCenterRow) geometricCenterRow.style.display = 'none';
        if (areaDimensionsRow) areaDimensionsRow.style.display = 'none';
        if (boundingCenterRow) boundingCenterRow.style.display = 'none';
        if (boundingDimensionsRow) boundingDimensionsRow.style.display = 'none';
    }
}
// Êõ¥Êñ∞ÁøªËΩ¨Áü©ÈòµÊòæÁ§∫
function uiUpdateFlipMatrix() {
    if (!selectedElement) return;

    // Êõ¥Êñ∞ÊúùÂêëÁøªËΩ¨Áü©ÈòµÊòæÁ§∫ [1 0; 0 ¬±1]
    const flipForwardYValue = document.getElementById('flipForwardYValue');
    if (flipForwardYValue) {
        flipForwardYValue.textContent = selectedElement.transform.flip.forwardY ? '-1' : '1';
    }

    // Êõ¥Êñ∞ÂùêÂêëÁøªËΩ¨Áü©ÈòµÊòæÁ§∫ [¬±1 0; 0 1]
    const flipSideXValue = document.getElementById('flipSideXValue');
    if (flipSideXValue) {
        flipSideXValue.textContent = selectedElement.transform.flip.sideX ? '-1' : '1';
    }
}
// Êõ¥Êñ∞ÊóãËΩ¨Áü©ÈòµÊòæÁ§∫
function uiUpdateRotationMatrix() {
    const angle = parseFloat(document.getElementById('rotationAngle').value) || 0;
    const radians = angle * D2R;

    const cos = Math.cos(radians);
    const sin = Math.sin(radians);

    // Êõ¥Êñ∞Áü©ÈòµÂÖÉÁ¥†ÊòæÁ§∫
    document.getElementById('rotationCos').textContent = cos.toFixed(3);
    document.getElementById('rotationNegSin').textContent = (-sin).toFixed(3);
    document.getElementById('rotationSin').textContent = sin.toFixed(3);
    document.getElementById('rotationCos2').textContent = cos.toFixed(3);
}
// Êõ¥Êñ∞ÊòØÂê¶ÂèØ‰ª•ÂØπËßÇÊµãÊñπÂêëËøõË°åÂ±ÄÂüüÂØπÁß∞ÊÄßÁ∫¶ÊùüÔºàÊ†πÊçÆËßÇÊµãÁÇπÁöÑÁõ∏ÂØπÊÄßÔºâ
function uiUpdateObserveDirLocalSymmetryConstrainValid() {
    if (!selectedElement) return;

    // Ê†πÊçÆÂΩìÂâçÊ¥ªË∑ÉÂèòÊç¢Á±ªÂûãÊõ¥Êñ∞ÂØπÂ∫îÁöÑUI
    let ls_div, ls_checkbox;
    if (activeTransform === TRANSFORM.FLIP) {
        ls_div = document.getElementById('flipObserveDirLSConstrainFrame');
        ls_checkbox = document.getElementById('flipObserveDirLSConstrain');
    } else if (activeTransform === TRANSFORM.SHEAR) {
        ls_div = document.getElementById('shearObserveDirLSConstrainFrame');
        ls_checkbox = document.getElementById('shearObserveDirLSConstrain');
    } else return;

    // Âú®ÂÜÖÈÉ®Êó∂ÔºåËßÇÊµãÊñπÂêëËÇØÂÆöÈÉΩÊòØÂ±ÄÂüüÂØπÁß∞ÁöÑÔºåÂõ†Ê≠§ÈöêËóè/Á¶ÅÁî®ËØ•ÈÄâÈ°π
    // + Ê≥®ÊÑèÔºåËßÇÊµãÊñπÂêëÂ±ÄÂüüÂØπÁß∞ÊÄßÊ≤°ÊúâÊÑè‰πâÔºå‰∏ç‰ª£Ë°®ÂØπÂÆÉÁöÑÊìç‰ΩúÁ∫¶ÊùüÈÄâÈ°π‰ºöÂ§±ÊïàÔºå
    //   Âç≥‰∏çÈúÄË¶ÅÊ∏ÖÈô§ÂÖ∂ flipCheckbox ÁöÑÈÄâ‰∏≠Áä∂ÊÄÅ„ÄÅ‰ª•Âèä constrainObserveDirLocalSymmetry ÂèòÈáè
    //   Âõ†‰∏∫ÔºåÂΩìËßÇÊµãÁÇπÁßªÂà∞Â§ñÈÉ®Êó∂ÔºåËøô‰∫õÈÄâÈ°πÁä∂ÊÄÅ‰æùÁÑ∂ÊúâÊïà
    const relative = observingPoint && observingPoint[2] <= 0;
    ls_checkbox.disabled = relative;
    ls_div.style.display = relative ? 'none' : 'block';
}

// ÁâπÊÄßË°®ÂçïÈ°πÂèòÊõ¥Â§ÑÁêÜ
function uiPropertyModified(base, input, dataType, property, nested) {
    if (!selectedElement) return false;

    let value;
    if (dataType >= DATA_TYPES.F) {
        dataType -= DATA_TYPES.F;
        if (dataType <= 0) dataType = DECIMAL_PRECISION_DEFAULT;
        value = parseFloat(input.value);
        if (isNaN(value)) return false;
        input.value = value.toFixed(dataType);
    }
    else if (dataType === DATA_TYPES.I) {
        if (!input.value) return false;
        value = parseInt(input.value) || 0;
    }
    else value = dataType === DATA_TYPES.B ? input.checked : input.value;

    // Â§ÑÁêÜË∑ØÂæÑÂΩ¢ÂºèÁöÑÂ±ûÊÄßÔºàÂ¶Ç "coords[0]", "ft[0][0]", "box[2]" Á≠âÔºâ
    if (nested) {
        // Â∞Ü [idx] ÂΩ¢ÂºèËΩ¨Êç¢‰∏∫ .idx ÂΩ¢ÂºèÔºåÁÑ∂ÂêéÊãÜÂàÜ
        const keys = property.replace(/\[(\w+)]/g, '.$1').split('.');

        for (let i = 0; i < keys.length - 1; i++) {
            const key = keys[i];
            if (!(key in base)) base[key] = {};
            base = base[key];
        }
        base[keys[keys.length - 1]] = value;
    }
    // ArcÂÖÉÁ¥†ÁöÑËßíÂ∫¶ÁâπÊÆäÂ§ÑÁêÜÔºöstartAngle, endAngle (Â∫¶) ‚Üí startRad, endRad (ÂºßÂ∫¶)
    else if (selectedElement.type === ElementTypes.ARC && (property === 'startAngle' || property === 'endAngle')) {
        if (property === 'startAngle') {
            base.startRad = value * D2R;
        } else if (property === 'endAngle') {
            base.endRad = value * D2R;
        }
    }
    // ÊôÆÈÄöÂ±ûÊÄßÔºàÂ¶Ç radius, closed, easeGroup, easeType, expression, xMin, xMax, samples Á≠âÔºâ
    else {
        base[property] = value;
    }
    return true;
}
function uiActParametersModified(input, dataType, property, nested) {

    const props = selectedElement.props;
    if (!uiPropertyModified(props, input, dataType, property, nested)) return;

    // Ê†πÊçÆÂÖÉÁ¥†Á±ªÂûãË∞ÉÁî®ÂØπÂ∫îÁöÑÈáçÂª∫ÂáΩÊï∞
    switch(selectedElement.type) {
        case ElementTypes.SEG: SegRebuild(props); break;
        case ElementTypes.RECTANGLE: RectangleRebuild(props); break;
        case ElementTypes.CIRCLE: CircleRebuild(props); break;
        case ElementTypes.ARC: ArcRebuild(props); break;
        case ElementTypes.POLYGON: PolygonRebuild(props); break;
        case ElementTypes.EASE: EaseRebuild(props); break;
        case ElementTypes.BEZIER: BezierRebuild(props); break;
    }

    // ÈáçÊñ∞ËÆ°ÁÆóÂíåÊòæÁ§∫Â±ûÊÄß„ÄÅÁâπÂæÅÁÇπ
    uiUpdateCommonIntrinsics();
    uiBuildIntrinsics();
    uiBuildFeaturePoints();

    // ÈáçÁªòÁîªÂ∏É
    draw();
}
function uiActTransformModified(input, dataType, property, nested) {

    if (!uiPropertyModified(selectedElement.transform, input, dataType, property, nested)) return;

    // Êõ¥Êñ∞ÂΩìÂâçÊøÄÊ¥ªÁöÑÂèòÊç¢Á±ªÂûã
    uiActiveTransform(activeTransform);

    // ÈáçÁªòÁîªÂ∏É
    draw();
}

// Â§ÑÁêÜËßÇÊµãÊñπÂêëËæìÂÖ•ÁöÑÂèòÂåñ
function uiActObserveDirModified(input, transformType) {
    if (!selectedElement || !selectedElement.transform) return;

    const transform = selectedElement.transform[transformType];
    if (!transform) return; // Âè™ÊîØÊåÅ flip Âíå shear

    // Á©∫ÂÄºË°®Á§∫ nullÔºàËá™Âä®ËÆ°ÁÆóÔºâ
    if (input.value === '' || input.value === null || input.value === undefined) {
        transform.observeDir = null;
    } else {
        const value = parseFloat(input.value);
        if (!isNaN(value)) {
            transform.observeDir = value;
        } else {
            transform.observeDir = null;
            input.value = ''; // Êó†ÊïàËæìÂÖ•Êó∂Ê∏ÖÁ©∫
        }
    }

    // ÂáΩÊï∞ÁªòÂà∂ÊòØÈÄöËøá getObserveDirection Êù•Áõ¥Êé•Ëé∑ÂèñËßÇÊµãÊñπÂêëÁöÑÔºåÂõ†Ê≠§‰∏çÈúÄË¶ÅÈ¢ùÂ§ñÊõ¥Êñ∞ÂΩìÂâçÊøÄÊ¥ªÁöÑËßíÂ∫¶

    // ÈáçÁªòÁîªÂ∏É
    draw();
}

// ÂàáÊç¢ÊòØÂê¶ÊòæÁ§∫Èù¢ÁßØ
function uiActToggleAreaVisible(input) {

    const areaDimensions = document.getElementById('areaDimensions');
    if (areaDimensions) {
        areaDimensions.style.display = input.checked ? 'flex' : 'none';
    }

    // Êõ¥Êñ∞Èù¢ÁßØÊï∞ÂÄº
    if (input.checked && selectedElement && selectedElement.props.centroid) {
        const areaElement = document.getElementById('areaValue');
        if (areaElement && selectedElement.props.centroid[2] !== undefined) {
            areaElement.textContent = selectedElement.props.centroid[2].toFixed(2);
        }
    }

    draw();
}
// ÂàáÊç¢ÊòØÂê¶ÊòæÁ§∫ÂåÖÂõ¥ÁõíËæπÊ°Ü
function uiActToggleBoundingRectVisible(input) {

    const boundingDimensions = document.getElementById('boundingDimensions');
    if (boundingDimensions) {
        boundingDimensions.style.display = input.checked ? 'flex' : 'none';
    }

    draw();
}
// ÂàáÊç¢ÊòØÂê¶ÂØπËßÇÊµã‰ΩçÁΩÆ/ÊñπÂêëËøõË°åÂ±ÄÂüüÂØπÁß∞ÊÄßÁ∫¶Êùü
function uiActToggleLocalSymmetryConstrain(input, toPosOrDir) {
    console.assert(selectedElement && observingPoint);

    // ÁÇπÂáªÁöÑÊòØËßÇÊµãÁÇπ
    if (toPosOrDir) {

        // Â¶ÇÊûúÂêØÂä®Â±ÄÂüüÂØπÁß∞ÊÄßÁ∫¶Êùü
        if ((constrainObservePosLocalSymmetry = input.checked)) {

            const relativity = getObserveRelativity(observingPoint, selectedElement);
            if (relativity[2] > 0) {

                // Á∫¶ÊùüÂà∞ËæπÁºò
                observingPoint[0] = relativity[0];
                observingPoint[1] = relativity[1];
                observingPoint[2] = 0;
                observingPointInScreen = mathToScreen(observingPoint[0], observingPoint[1]);

                // Êõ¥Êñ∞Âà∞ÁïåÈù¢
                switch (activeTransform) {
                    case TRANSFORM.FLIP:
                        uiInitInputValue(document.getElementById('flipObserveX'), observingPoint[0],
                            uiEditingSaved1?.flip?.observePos?.[0]);
                        uiInitInputValue(document.getElementById('flipObserveY'), observingPoint[1],
                            uiEditingSaved1?.flip?.observePos?.[1]);
                        break;
                    case TRANSFORM.SHEAR:
                        uiInitInputValue(document.getElementById('shearObserveX'), observingPoint[0],
                            uiEditingSaved1?.shear?.observePos?.[0]);
                        uiInitInputValue(document.getElementById('shearObserveY'), observingPoint[1],
                            uiEditingSaved1?.shear?.observePos?.[1]);
                        break;
                    case TRANSFORM.ROTATION:
                        uiInitInputValue(document.getElementById('rotationObserveX'), observingPoint[0],
                            uiEditingSaved1?.rotation?.observePos?.[0]);
                        uiInitInputValue(document.getElementById('rotationObserveY'), observingPoint[1],
                            uiEditingSaved1?.rotation?.observePos?.[1]);
                        break;
                    case TRANSFORM.SCALE:
                        uiInitInputValue(document.getElementById('scaleObserveX'), observingPoint[0],
                            uiEditingSaved1?.scale?.observePos?.[0]);
                        uiInitInputValue(document.getElementById('scaleObserveY'), observingPoint[1],
                            uiEditingSaved1?.scale?.observePos?.[1]);
                        break;
                }

                observingRelevant = null;

                applyTransformToElement(selectedElement);

                draw();
            }
        }

        // Êõ¥Êñ∞ËßÇÊµãÊñπÂêëÂ±ÄÂüüÂØπÁß∞ÊÄßcheckboxÁöÑÊòæÁ§∫Áä∂ÊÄÅ
        uiUpdateObserveDirLocalSymmetryConstrainValid();
    }
    // ÁÇπÂáªÁöÑÊòØËßÇÊµãÊñπÂêë
    else {

        constrainObserveDirLocalSymmetry = input.checked;

        if (input.checked && selectedElement && activeTransform) {

            let transform = null, dirInput, origVal;
            if (activeTransform === TRANSFORM.FLIP) {
                transform = selectedElement.transform.flip;
                dirInput = document.getElementById('flipObserveD');
                origVal = uiEditingSaved1?.flip?.observeDir;
            } else if (activeTransform === TRANSFORM.SHEAR) {
                transform = selectedElement.transform.shear;
                dirInput = document.getElementById('shearObserveD');
                origVal = uiEditingSaved1?.shear?.observeDir;
            }

            if (transform) {
                const angle = getObserveDirection(transform);
                const constrained = observeDirectionConstrain(angle);
                if (constrained !== angle) {
                    transform.observeDir = constrained;
                    uiInitObserveDirInputValue(dirInput, constrained, origVal);
                    draw();
                }
            }
        }
    }
}

//------------------------------------

// ÊãñÊãΩ‰∫ã‰ª∂
const uploadDropZone = document.getElementById('uploadDropZone');
uploadDropZone.addEventListener('dragover', function(e) {
    e.preventDefault();
    uploadDropZone.classList.add('dragover');
});
uploadDropZone.addEventListener('dragleave', function(e) {
    e.preventDefault();
    uploadDropZone.classList.remove('dragover');
});
uploadDropZone.addEventListener('drop', function(e) {
    e.preventDefault();
    uploadDropZone.classList.remove('dragover');

    const files = e.dataTransfer.files;
    if (files.length > 0) {
        const file = files[0];
        if (file.type === 'application/json' || file.name.endsWith('.json')) {
            loadElementsFromJSON(file);
        } else {
            alert('ËØ∑‰∏ä‰º† JSON Êñá‰ª∂');
        }
    }
});
// ÁÇπÂáªÊµèËßàÊåâÈíÆ
const uploadBrowseBtn = document.getElementById('uploadBrowseBtn');
uploadBrowseBtn.addEventListener('click', function(e) {
    e.stopPropagation();
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'application/json,.json';
    input.onchange = function(e) {
        const file = e.target.files[0];
        if (file) {
            loadElementsFromJSON(file);
        }
    };
    input.click();
});

// ÁªëÂÆöÊñá‰ª∂‰∏ä‰º†ÂØπËØùÊ°Ü‰∫ã‰ª∂
document.getElementById('uploadOverlay').addEventListener('click', function(e) {
    if (e.target === this) {
        UIHideUploadDialog();
    }
});

function UIShowUploadDialog() {
    const overlay = document.getElementById('uploadOverlay');
    overlay.classList.add('show');
    uiUploadShown = true;

    // Êõ¥Êñ∞ÊñáÊú¨
    const lang = LANG;
    document.querySelector('.upload-title').textContent = LangText.UPLOAD_TITLE[lang];
    document.querySelector('.upload-text').textContent = LangText.UPLOAD_DROP_TEXT[lang];
    document.querySelector('.upload-subtext').textContent = LangText.UPLOAD_DROP_SUBTEXT[lang];
    document.querySelector('.upload-browse-btn').textContent = LangText.UPLOAD_BROWSE_BTN[lang];
    document.querySelector('.upload-hint').textContent = LangText.UPLOAD_HINT[lang];
}
function UIHideUploadDialog() {
    document.getElementById('uploadOverlay').classList.remove('show');
    uiUploadShown = false;
}

//------------------------------------

window.UIShowHelpDialog = UIShowHelpDialog;
window.UIHideHelpDialog = UIHideHelpDialog;
window.UIShowElementsPanel = UIShowElementsPanel;
window.UIHideElementsPanel = UIHideElementsPanel;
window.UIToggleElementsPanel = UIToggleElementsPanel;
window.UIOpenFunctionDialog = UIOpenFunctionDialog;
window.UICloseFunctionDialog = UICloseFunctionDialog;
window.UIOpenAttributes = UIOpenAttributes;
window.UICloseAttributes = UICloseAttributes;
window.UIShowPropertyPanel = UIShowPropertyPanel;
window.UIHidePropertyPanel = UIHidePropertyPanel;

/* ================================ */
/* Âá†‰ΩïÂùêÊ†áÁ≥ª */
/* ================================ */

// ÁªòÂà∂ÂùêÊ†áÁ≥ª

//------------------
// ÁªòÂà∂ÂùêÊ†áÁ≥ªËÉåÊôØÂà∞ÁºìÂ≠òÔºàÈùôÊÄÅÈÉ®ÂàÜÔºöÁΩëÊ†º„ÄÅËΩ¥Á∫øÔºâ
//------------------

function drawCoordinateBackground(targetCtx, targetWidth, targetHeight) {
    // Ê≠§ÂáΩÊï∞ÁªòÂà∂ÂùêÊ†áÁ≥ªÁöÑÈùôÊÄÅËÉåÊôØÔºàÁΩëÊ†ºÁÇπ„ÄÅÁΩëÊ†ºÁ∫ø„ÄÅÂùêÊ†áËΩ¥Ôºâ
    // ÂèÇÊï∞Ôºö
    //   targetCtx: ÁõÆÊ†áÁªòÂà∂‰∏ä‰∏ãÊñáÔºàÂèØ‰ª•ÊòØ‰∏ªCanvasÊàñÁ¶ªÂ±èCanvasÔºâ
    //   targetWidth, targetHeight: ÁõÆÊ†áCanvasÁöÑÂ∞∫ÂØ∏
    
    // Ê≥®ÊÑèÔºöÊ≠§ÂáΩÊï∞ÂÅáÂÆöÂ∑≤ÁªèÂ∫îÁî®‰∫ÜÂùêÊ†áÁ≥ªÂèòÊç¢ (translate + scale)

    // Ëé∑ÂèñÂä®ÊÄÅÁΩëÊ†ºÈó¥Èöî
    const { gridStep, labelStep } = calculateGridSpacing(scale);

    // ËÆ°ÁÆóÂèØËßÅËåÉÂõ¥
    const minX = Math.floor((-offsetX) / (UNIT_SIZE * scale)) - 1;
    const maxX = Math.ceil((targetWidth - offsetX) / (UNIT_SIZE * scale)) + 1;
    const minY = Math.floor((offsetY) / (UNIT_SIZE * scale)) - 1;
    const maxY = Math.ceil((targetHeight + offsetY) / (UNIT_SIZE * scale)) + 1;

    // Ëé∑ÂèñÂΩìÂâç‰∏ªÈ¢òÁöÑÈ¢úËâ≤
    const gridDotColor = THEME ? '#2e2e2e' : '#ddd';
    const gridLineColor = THEME ? '#2a2a2a' : '#e0e0e0';
    const axisColor = THEME ? '#b0b0b0' : '#333';
    const originColor = THEME ? '#ff5555' : '#ff0000';

    // Ê£ÄÊü•ÁúüÂÆûÂùêÊ†áËΩ¥ÊòØÂê¶Â∫îËØ•ÊòæÁ§∫
    const virtualAxisMarginLeft = INITIAL_OFFSET_X;
    const virtualAxisMarginRight = INITIAL_OFFSET_X * 1.5;
    const virtualAxisMarginBottom = -INITIAL_OFFSET_Y;
    const virtualAxisMarginTop = -INITIAL_OFFSET_Y;
    
    const virtualXAxisYBottom = targetHeight - virtualAxisMarginBottom;
    const virtualXAxisYTop = virtualAxisMarginTop;
    const virtualYAxisXLeft = virtualAxisMarginLeft;
    const virtualYAxisXRight = targetWidth - virtualAxisMarginRight;
    
    const originScreenX = offsetX;
    const originScreenY = targetHeight + offsetY;
    
    let xAxisInView, yAxisInView;
    if (CURRENT_VIRTUAL_AXIS_MODE === VIRTUAL_AXIS_MODE.SEAMLESS) {
        xAxisInView = originScreenY <= virtualXAxisYBottom && originScreenY >= virtualXAxisYTop;
        yAxisInView = originScreenX >= virtualYAxisXLeft && originScreenX <= virtualYAxisXRight;
    } else {
        xAxisInView = originScreenY >= 0 && originScreenY <= targetHeight;
        yAxisInView = originScreenX >= 0 && originScreenX <= targetWidth;
    }

    // ÁªòÂà∂ÁΩëÊ†ºÁÇπ
    targetCtx.fillStyle = gridDotColor;
    for (let x = Math.floor(minX / gridStep) * gridStep; x <= maxX; x += gridStep) {
        for (let y = Math.floor(minY / gridStep) * gridStep; y <= maxY; y += gridStep) {
            const pixelX = x * UNIT_SIZE;
            const pixelY = y * UNIT_SIZE;
            targetCtx.beginPath();
            targetCtx.arc(pixelX, pixelY, 1 / scale, 0, PI2);
            targetCtx.fill();
        }
    }

    // ÁªòÂà∂ÁΩëÊ†ºÁ∫ø
    targetCtx.strokeStyle = gridLineColor;
    targetCtx.lineWidth = 0.5 / scale;
    for (let x = Math.floor(minX / gridStep) * gridStep; x <= maxX; x += gridStep) {
        if (x === 0) continue;
        const pixelX = x * UNIT_SIZE;
        targetCtx.beginPath();
        targetCtx.moveTo(pixelX, minY * UNIT_SIZE);
        targetCtx.lineTo(pixelX, maxY * UNIT_SIZE);
        targetCtx.stroke();
    }
    for (let y = Math.floor(minY / gridStep) * gridStep; y <= maxY; y += gridStep) {
        if (y === 0) continue;
        const pixelY = y * UNIT_SIZE;
        targetCtx.beginPath();
        targetCtx.moveTo(minX * UNIT_SIZE, pixelY);
        targetCtx.lineTo(maxX * UNIT_SIZE, pixelY);
        targetCtx.stroke();
    }

    // ÁªòÂà∂ÂùêÊ†áËΩ¥ÔºàÂ∏¶Èò¥ÂΩ±Ôºâ
    targetCtx.shadowColor = THEME ? 'rgba(0, 0, 0, 0.4)' : 'rgba(0, 0, 0, 0.15)';
    targetCtx.shadowBlur = 2 / scale;
    targetCtx.shadowOffsetX = 1 / scale;
    targetCtx.shadowOffsetY = 1 / scale;
    
    targetCtx.strokeStyle = axisColor;
    targetCtx.lineWidth = 1 / scale;
    
    if (xAxisInView) {
        targetCtx.beginPath();
        targetCtx.moveTo(minX * UNIT_SIZE, 0);
        targetCtx.lineTo(maxX * UNIT_SIZE, 0);
        targetCtx.stroke();
    }
    
    if (yAxisInView) {
        targetCtx.beginPath();
        targetCtx.moveTo(0, minY * UNIT_SIZE);
        targetCtx.lineTo(0, maxY * UNIT_SIZE);
        targetCtx.stroke();
    }
    
    // Ê∏ÖÈô§Èò¥ÂΩ±
    targetCtx.shadowColor = 'transparent';
    targetCtx.shadowBlur = 0;
    targetCtx.shadowOffsetX = 0;
    targetCtx.shadowOffsetY = 0;
    
    // ÁªòÂà∂ÂéüÁÇπ
    if (xAxisInView && yAxisInView) {
        targetCtx.fillStyle = originColor;
        targetCtx.beginPath();
        targetCtx.arc(0, 0, 3 / scale, 0, PI2);
        targetCtx.fill();
    }

    // ÁªòÂà∂ËôöÊãüÂùêÊ†áËΩ¥ÔºàÈúÄË¶ÅÂàáÊç¢Âà∞Â±èÂπïÂùêÊ†áÁ≥ªÔºâ
    targetCtx.save();
    targetCtx.setTransform(1, 0, 0, 1, 0, 0); // ÈáçÁΩÆ‰∏∫Â±èÂπïÂùêÊ†áÁ≥ª

    const virtualAxisColor = THEME ? 'rgba(176, 176, 176, 0.4)' : 'rgba(51, 51, 51, 0.4)';
    
    if (!xAxisInView) {
        // XËΩ¥Ë∂ÖËøáËôöÊãü‰ΩçÁΩÆÔºåÁªòÂà∂ËôöÊãüXËΩ¥
        targetCtx.strokeStyle = virtualAxisColor;
        targetCtx.lineWidth = 0.5;
        // Ê†πÊçÆÈÖçÁΩÆËÆæÁΩÆÁ∫øÂûã
        if (CURRENT_VIRTUAL_AXIS_LINE_STYLE === VIRTUAL_AXIS_LINE_STYLE.DASHED) {
            targetCtx.setLineDash([5, 5]); // ËôöÁ∫ø
        }
        
        // Âà§Êñ≠Â∫îËØ•ÊòæÁ§∫Â∫ïÈÉ®ËøòÊòØÈ°∂ÈÉ®ËôöÊãüXËΩ¥ÔºàÊàñ‰∏§ËÄÖÈÉΩÊòæÁ§∫Ôºâ
        if (originScreenY > virtualXAxisYBottom) {
            // ÁúüÂÆûXËΩ¥Âú®Â∫ïÈÉ®ËôöÊãü‰ΩçÁΩÆ‰∏ãÊñπÔºåÊòæÁ§∫Â∫ïÈÉ®ËôöÊãüXËΩ¥
            targetCtx.beginPath();
            targetCtx.moveTo(0, virtualXAxisYBottom);
            targetCtx.lineTo(targetWidth, virtualXAxisYBottom);
            targetCtx.stroke();
        }
        if (originScreenY < virtualXAxisYTop) {
            // ÁúüÂÆûXËΩ¥Âú®È°∂ÈÉ®ËôöÊãü‰ΩçÁΩÆ‰∏äÊñπÔºåÊòæÁ§∫È°∂ÈÉ®ËôöÊãüXËΩ¥
            targetCtx.beginPath();
            targetCtx.moveTo(0, virtualXAxisYTop);
            targetCtx.lineTo(targetWidth, virtualXAxisYTop);
            targetCtx.stroke();
        }
        
        targetCtx.setLineDash([]); // ÊÅ¢Â§çÂÆûÁ∫ø
    }
    
    if (!yAxisInView) {
        // YËΩ¥Ë∂ÖËøáËôöÊãü‰ΩçÁΩÆÔºåÁªòÂà∂ËôöÊãüYËΩ¥
        targetCtx.strokeStyle = virtualAxisColor;
        targetCtx.lineWidth = 0.5;
        // Ê†πÊçÆÈÖçÁΩÆËÆæÁΩÆÁ∫øÂûã
        if (CURRENT_VIRTUAL_AXIS_LINE_STYLE === VIRTUAL_AXIS_LINE_STYLE.DASHED) {
            targetCtx.setLineDash([5, 5]); // ËôöÁ∫ø
        }
        
        // Âà§Êñ≠Â∫îËØ•ÊòæÁ§∫Â∑¶‰æßËøòÊòØÂè≥‰æßËôöÊãüYËΩ¥ÔºàÊàñ‰∏§ËÄÖÈÉΩÊòæÁ§∫Ôºâ
        if (originScreenX < virtualYAxisXLeft) {
            // ÁúüÂÆûYËΩ¥Âú®Â∑¶‰æßËôöÊãü‰ΩçÁΩÆÂ∑¶ËæπÔºåÊòæÁ§∫Â∑¶‰æßËôöÊãüYËΩ¥
            targetCtx.beginPath();
            targetCtx.moveTo(virtualYAxisXLeft, 0);
            targetCtx.lineTo(virtualYAxisXLeft, targetHeight);
            targetCtx.stroke();
        }
        if (originScreenX > virtualYAxisXRight) {
            // ÁúüÂÆûYËΩ¥Âú®Âè≥‰æßËôöÊãü‰ΩçÁΩÆÂè≥ËæπÔºåÊòæÁ§∫Âè≥‰æßËôöÊãüYËΩ¥
            targetCtx.beginPath();
            targetCtx.moveTo(virtualYAxisXRight, 0);
            targetCtx.lineTo(virtualYAxisXRight, targetHeight);
            targetCtx.stroke();
        }
        
        targetCtx.setLineDash([]); // ÊÅ¢Â§çÂÆûÁ∫ø
    }

    targetCtx.restore();
}

//------------------
// ÁªòÂà∂ÂùêÊ†áÁ≥ªÔºà‰∏ªÂáΩÊï∞Ôºö‰ΩøÁî®ÁºìÂ≠ò + ÁªòÂà∂Âä®ÊÄÅÂÜÖÂÆπÔºâ
//------------------

function drawCoordinate() {

    // 1. Ê£ÄÊü•ÊòØÂê¶ÈúÄË¶ÅÊõ¥Êñ∞ÁºìÂ≠ò
    if (coordinateCacheDirty) {
        // Á°Æ‰øùÁºìÂ≠òCanvasÂ∞∫ÂØ∏Ê≠£Á°Æ
        if (coordinateCache.width !== canvas.width || coordinateCache.height !== canvas.height) {
            coordinateCache.width = canvas.width;
            coordinateCache.height = canvas.height;
        }

        // Ê∏ÖÁ©∫ÁºìÂ≠òCanvas
        coordinateCacheCtx.clearRect(0, 0, coordinateCache.width, coordinateCache.height);
        
        // Â∫îÁî®ÂùêÊ†áÁ≥ªÂèòÊç¢Âà∞ÁºìÂ≠òCanvas
        coordinateCacheCtx.save();
        coordinateCacheCtx.translate(offsetX, canvas.height + offsetY);
        coordinateCacheCtx.scale(scale, -scale);
        
        // ÁªòÂà∂ÈùôÊÄÅËÉåÊôØÂà∞ÁºìÂ≠ò
        drawCoordinateBackground(coordinateCacheCtx, canvas.width, canvas.height);
        
        coordinateCacheCtx.restore();
        
        // Ê†áËÆ∞ÁºìÂ≠òÂ∑≤Êõ¥Êñ∞
        coordinateCacheDirty = false;
    }

    // 2. Â∞ÜÁºìÂ≠òÁöÑËÉåÊôØÂ§çÂà∂Âà∞‰∏ªCanvasÔºàÂú®ÂèòÊç¢ÂêéÁöÑÂùêÊ†áÁ≥ª‰∏≠ÊÅ¢Â§çÂ±èÂπïÂùêÊ†áÁ≥ªÊù•ÁªòÂà∂Ôºâ
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0); // ÈáçÁΩÆ‰∏∫Â±èÂπïÂùêÊ†áÁ≥ª
    ctx.drawImage(coordinateCache, 0, 0);
    ctx.restore();

    // 3. ÁªòÂà∂Âä®ÊÄÅÂÜÖÂÆπÔºàËôöÊãüÂùêÊ†áËΩ¥„ÄÅÂàªÂ∫¶Ê†áÁ≠æ„ÄÅÂØπÈΩêÊåáÁ§∫Âô®Á≠âÔºâ
    // Ëøô‰∫õÈúÄË¶ÅÂÆûÊó∂Êõ¥Êñ∞Ôºå‰∏çËÉΩÁºìÂ≠ò
    
    // ÂàáÊç¢Âà∞Â±èÂπïÂùêÊ†áÁ≥ªÁªòÂà∂Âä®ÊÄÅÂÜÖÂÆπ
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);

    // ÈáçÊñ∞ËÆ°ÁÆóÈúÄË¶ÅÁöÑÂèÇÊï∞ÔºàÁî®‰∫éÂä®ÊÄÅÂÜÖÂÆπÔºâ
    const { gridStep, labelStep } = calculateGridSpacing(scale);
    const minX = Math.floor((-offsetX) / (UNIT_SIZE * scale)) - 1;
    const maxX = Math.ceil((canvas.width - offsetX) / (UNIT_SIZE * scale)) + 1;
    const minY = Math.floor((offsetY) / (UNIT_SIZE * scale)) - 1;
    const maxY = Math.ceil((canvas.height + offsetY) / (UNIT_SIZE * scale)) + 1;

    const virtualAxisMarginLeft = INITIAL_OFFSET_X;
    const virtualAxisMarginRight = INITIAL_OFFSET_X * 1.5;
    const virtualAxisMarginBottom = -INITIAL_OFFSET_Y;
    const virtualAxisMarginTop = -INITIAL_OFFSET_Y;
    
    const virtualXAxisYBottom = canvas.height - virtualAxisMarginBottom;
    const virtualXAxisYTop = virtualAxisMarginTop;
    const virtualYAxisXLeft = virtualAxisMarginLeft;
    const virtualYAxisXRight = canvas.width - virtualAxisMarginRight;
    
    const originScreenX = offsetX;
    const originScreenY = canvas.height + offsetY;
    
    let xAxisInView, yAxisInView;
    if (CURRENT_VIRTUAL_AXIS_MODE === VIRTUAL_AXIS_MODE.SEAMLESS) {
        xAxisInView = originScreenY <= virtualXAxisYBottom && originScreenY >= virtualXAxisYTop;
        yAxisInView = originScreenX >= virtualYAxisXLeft && originScreenX <= virtualYAxisXRight;
    } else {
        xAxisInView = originScreenY >= 0 && originScreenY <= canvas.height;
        yAxisInView = originScreenX >= 0 && originScreenX <= canvas.width;
    }

    // ÂÆö‰πâËôöÊãüÂùêÊ†áËΩ¥ÊñáÊú¨È¢úËâ≤ÔºàÁî®‰∫éÊ†áÁ≠æÔºâ
    const virtualTextColor = THEME ? 'rgba(224, 224, 224, 0.6)' : 'rgba(51, 51, 51, 0.6)';

    // ÁªòÂà∂ÂØπÈΩêÊåáÁ§∫Âô®ÔºàÂä®ÊÄÅÂÜÖÂÆπÔºâ
    if (isShiftPressed && mouseMath) {

        // ËÆ°ÁÆóÂØπÈΩê‰ΩçÁΩÆÂú®Â±èÂπï‰∏äÁöÑÂÉèÁ¥†ÂùêÊ†áÔºàmouseMath ÊòØÊï∞Â≠¶ÂùêÊ†áÁ≥ªÔºâ
        let [alignedScreenX, alignedScreenY] = mathToScreen(mouseMath[0], mouseMath[1]);
        
        // ÂÉèÁ¥†ÂØπÈΩêÔºöÂ∞ÜÂùêÊ†áÂØπÈΩêÂà∞Êï¥Êï∞ÂÉèÁ¥† + 0.5ÔºåËøôÊ†∑Â•áÊï∞ÂÆΩÂ∫¶ÁöÑÁ∫øÊù°‰ºöÁ≤æÁ°ÆËêΩÂú®ÂÉèÁ¥†‰∏ä
        // ÂØπ‰∫é 1px Á∫øÊù°ÔºåÂùêÊ†áÂ∫îËØ•Âú® x.5 ‰ΩçÁΩÆÔºõÂØπ‰∫é 3px Á∫øÊù°‰πü‰∏ÄÊ†∑
        alignedScreenX = Math.floor(alignedScreenX) + 0.5;
        alignedScreenY = Math.floor(alignedScreenY) + 0.5;

        const cross_sz = 8;

        // ÁªòÂà∂ÂØπÈΩêÂçÅÂ≠óÁ∫øÔºàÂÉèÁ¥†ÂØπÈΩê + ÂÖ≥Èó≠ÊäóÈîØÈΩø = ÂÆåÂÖ®Ê∏ÖÊô∞Ôºâ
        ctx.imageSmoothingEnabled = false;
        
        // Ê†πÊçÆ‰∏ªÈ¢òÈÄâÊã©ÊèèËæπÂíå‰∏ªÁ∫øÈ¢úËâ≤
        const strokeColor = THEME ? '#000000' : '#ffffff';  // ÈªëÂ§úÁî®ÈªëËâ≤ÊèèËæπÔºåÁôΩÂ§©Áî®ÁôΩËâ≤ÊèèËæπ
        const mainColor = '#ff4500';  // ‰∏ªÁ∫ø‰øùÊåÅÊ©ôËâ≤
        
        // 1. ÂÖàÁîªÊèèËæπ
        ctx.strokeStyle = strokeColor;
        ctx.lineWidth = 3;
        ctx.lineCap = 'butt';   // Á∫øÂ∏ΩÊ†∑Âºè‰∏∫Âπ≥Â§¥ÔºåÈÅøÂÖçÁ∫øÊù°Á´ØÁÇπÂúÜËßíÂØºËá¥ÁöÑÊ®°Á≥ä
        ctx.beginPath();
        // Ê®™Á∫øÔºàÂÆåÊï¥Ë¥ØÁ©øÔºâ
        ctx.moveTo(alignedScreenX - cross_sz, alignedScreenY);
        ctx.lineTo(alignedScreenX + cross_sz, alignedScreenY);
        // Á´ñÁ∫øÔºàÂÆåÊï¥Ë¥ØÁ©øÔºâ
        ctx.moveTo(alignedScreenX, alignedScreenY - cross_sz);
        ctx.lineTo(alignedScreenX, alignedScreenY + cross_sz);
        ctx.stroke();

        // 2. ÂÜçÁîªÊ©ôËâ≤ÁªÜÁ∫ø‰Ωú‰∏∫‰∏ª‰Ωì
        ctx.strokeStyle = mainColor;
        ctx.lineWidth = 1;
        ctx.lineCap = 'butt';
        ctx.beginPath();
        // Ê®™Á∫øÔºàÂÆåÊï¥Ë¥ØÁ©øÔºâ
        ctx.moveTo(alignedScreenX - cross_sz + 2, alignedScreenY);
        ctx.lineTo(alignedScreenX + cross_sz - 2, alignedScreenY);
        // Á´ñÁ∫øÔºàÂÆåÊï¥Ë¥ØÁ©øÔºâ
        ctx.moveTo(alignedScreenX, alignedScreenY - cross_sz + 2);
        ctx.lineTo(alignedScreenX, alignedScreenY + cross_sz - 2);
        ctx.stroke();
        
        // ÊÅ¢Â§çÊäóÈîØÈΩø
        ctx.imageSmoothingEnabled = true;
    }

    ctx.fillStyle = THEME ? '#e0e0e0' : '#333';
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';

    // XËΩ¥Ê†áÁ≠æÔºà‰ΩøÁî®Âä®ÊÄÅÈó¥ÈöîÔºâ
    if (xAxisInView) {
        // ÁúüÂÆûXËΩ¥Âú®ËôöÊãü‰ΩçÁΩÆËåÉÂõ¥ÂÜÖÔºåÂú®ÁúüÂÆûXËΩ¥‰∏äÊòæÁ§∫ÂàªÂ∫¶
        // Ê†πÊçÆ X ËΩ¥‰ΩçÁΩÆÂÜ≥ÂÆöÊòæÁ§∫Âú®‰∏ãÊñπËøòÊòØ‰∏äÊñπ
        let screenY, textBaseline;
        if (originScreenY > canvas.height / 2) {
            // X ËΩ¥Ë∂ÖËøáËßÜÂè£‰∏≠Á∫øÔºàÈù†‰∏ãÔºâÔºåÂàªÂ∫¶ÊòæÁ§∫Âú®‰∏ãÊñπ
            screenY = canvas.height + offsetY + 5;
            textBaseline = 'top';
        } else {
            // X ËΩ¥Âú®ËßÜÂè£‰∏≠Á∫ø‰∏äÊñπÔºåÂàªÂ∫¶ÊòæÁ§∫Âú®‰∏äÊñπ
            screenY = canvas.height + offsetY - 5;
            textBaseline = 'bottom';
        }
        ctx.textBaseline = textBaseline;
        
        for (let x = Math.floor(minX / labelStep) * labelStep; x <= maxX; x += labelStep) {
            if (x === 0) continue; // Ë∑≥ËøáÂéüÁÇπ
            const screenX = offsetX + x * UNIT_SIZE * scale;

            if (screenX >= 0 && screenX <= canvas.width) {
                ctx.fillText(x.toString(), screenX, screenY);
            }
        }
    } else {
        // XËΩ¥Ë∂ÖËøáËôöÊãü‰ΩçÁΩÆÔºåÂú®ËôöÊãüXËΩ¥‰∏äÊòæÁ§∫ÂàªÂ∫¶
        ctx.fillStyle = virtualTextColor;
        
        // Âà§Êñ≠ÊòæÁ§∫Âú®Â∫ïÈÉ®ËøòÊòØÈ°∂ÈÉ®ËôöÊãüXËΩ¥
        let virtualXAxisY, textOffset;
        if (originScreenY > virtualXAxisYBottom) {
            // ÊòæÁ§∫Âú®Â∫ïÈÉ®
            virtualXAxisY = virtualXAxisYBottom;
            textOffset = 5;
            ctx.textBaseline = 'top';
        } else {
            // ÊòæÁ§∫Âú®È°∂ÈÉ®
            virtualXAxisY = virtualXAxisYTop;
            textOffset = -5;
            ctx.textBaseline = 'bottom';
        }
        
        for (let x = Math.floor(minX / labelStep) * labelStep; x <= maxX; x += labelStep) {
            const screenX = offsetX + x * UNIT_SIZE * scale;
            if (screenX >= 0 && screenX <= canvas.width) {
                ctx.fillText(x.toString(), screenX, virtualXAxisY + textOffset);
            }
        }
        ctx.fillStyle = THEME ? '#e0e0e0' : '#333'; // ÊÅ¢Â§çÈ¢úËâ≤
        ctx.textBaseline = 'top'; // ÊÅ¢Â§çÈªòËÆ§
    }
    
    // YËΩ¥Ê†áÁ≠æÔºà‰ΩøÁî®Âä®ÊÄÅÈó¥ÈöîÔºâ
    ctx.textBaseline = 'middle';
    if (yAxisInView) {
        // ÁúüÂÆûYËΩ¥Âú®ËôöÊãü‰ΩçÁΩÆËåÉÂõ¥ÂÜÖÔºåÂú®ÁúüÂÆûYËΩ¥‰∏äÊòæÁ§∫ÂàªÂ∫¶
        // Ê†πÊçÆ Y ËΩ¥‰ΩçÁΩÆÂÜ≥ÂÆöÊòæÁ§∫Âú®Â∑¶‰æßËøòÊòØÂè≥‰æß
        let screenX, textAlign;
        if (originScreenX > canvas.width / 2) {
            // Y ËΩ¥Ë∂ÖËøáËßÜÂè£‰∏≠Á∫øÔºåÂàªÂ∫¶ÊòæÁ§∫Âú®Âè≥‰æß
            screenX = offsetX + 5;
            textAlign = 'left';
        } else {
            // Y ËΩ¥Âú®ËßÜÂè£‰∏≠Á∫øÂ∑¶‰æßÔºåÂàªÂ∫¶ÊòæÁ§∫Âú®Â∑¶‰æßÔºàÈªòËÆ§Ôºâ
            screenX = offsetX - 5;
            textAlign = 'right';
        }
        ctx.textAlign = textAlign;
        
        for (let y = Math.floor(minY / labelStep) * labelStep; y <= maxY; y += labelStep) {
            if (y === 0) continue; // Ë∑≥ËøáÂéüÁÇπ
            const screenY = canvas.height + offsetY - y * UNIT_SIZE * scale;

            if (screenY >= 0 && screenY <= canvas.height) {
                ctx.fillText(y.toString(), screenX, screenY);
            }
        }
    } else {
        // YËΩ¥Ë∂ÖËøáËôöÊãü‰ΩçÁΩÆÔºåÂú®ËôöÊãüYËΩ¥‰∏äÊòæÁ§∫ÂàªÂ∫¶
        ctx.fillStyle = virtualTextColor;
        
        // Âà§Êñ≠ÊòæÁ§∫Âú®Â∑¶‰æßËøòÊòØÂè≥‰æßËôöÊãüYËΩ¥
        let virtualYAxisX, textOffset;
        if (originScreenX < virtualYAxisXLeft) {
            // ÊòæÁ§∫Âú®Â∑¶‰æß
            virtualYAxisX = virtualYAxisXLeft;
            textOffset = -5;
            ctx.textAlign = 'right';
        } else {
            // ÊòæÁ§∫Âú®Âè≥‰æß
            virtualYAxisX = virtualYAxisXRight;
            textOffset = 5;
            ctx.textAlign = 'left';
        }
        
        for (let y = Math.floor(minY / labelStep) * labelStep; y <= maxY; y += labelStep) {
            const screenY = canvas.height + offsetY - y * UNIT_SIZE * scale;
            if (screenY >= 0 && screenY <= canvas.height) {
                ctx.fillText(y.toString(), virtualYAxisX + textOffset, screenY);
            }
        }
        ctx.fillStyle = THEME ? '#e0e0e0' : '#333'; // ÊÅ¢Â§çÈ¢úËâ≤
        ctx.textAlign = 'right'; // ÊÅ¢Â§çÈªòËÆ§
    }

    // ÊòæÁ§∫ÂùêÊ†áÂíåÁº©Êîæ‰ø°ÊÅØÂú®‰∏ÄË°åÔºàÈÅøÂºÄÂùêÊ†áËΩ¥Ôºâ
    ctx.fillStyle = THEME ? '#a0a0a0' : '#888';
    ctx.font = '11px Monaco, "SF Mono", Consolas, monospace';
    ctx.textBaseline = 'top';
    
    // Ê†πÊçÆ Y ËΩ¥‰ΩçÁΩÆÂÜ≥ÂÆöÂ∑¶ÂØπÈΩêËøòÊòØÂè≥ÂØπÈΩêÔºàÈïúÂÉèÂØπÁß∞Ôºâ
    let infoX, infoY;
    if (originScreenX > canvas.width / 2) {
        // Y ËΩ¥Ë∂ÖËøáËßÜÂè£‰∏≠Á∫øÔºå‰ΩøÁî®Âè≥ÂØπÈΩêÊ®°Âºè
        ctx.textAlign = 'right';
        if (yAxisInView) {
            // Y ËΩ¥Âú®ËßÜÂè£ÂÜÖÔºå‰ø°ÊÅØË¥¥ÁùÄ Y ËΩ¥Â∑¶‰æß
            infoX = originScreenX - 10;
        } else {
            // Y ËΩ¥ÁßªÂá∫Âè≥‰æßÔºå‰ø°ÊÅØË¥¥ÁùÄÂè≥ËæπÁºò
            infoX = canvas.width - 60;
        }
    } else {
        // Y ËΩ¥Âú®ËßÜÂè£‰∏≠Á∫øÂ∑¶‰æßÔºå‰ΩøÁî®Â∑¶ÂØπÈΩêÊ®°ÂºèÔºàÈªòËÆ§Ôºâ
        ctx.textAlign = 'left';
        if (yAxisInView) {
            // Y ËΩ¥Âú®ËßÜÂè£ÂÜÖÔºå‰ø°ÊÅØË¥¥ÁùÄ Y ËΩ¥Âè≥‰æß
            infoX = originScreenX + 10;
        } else {
            // Y ËΩ¥ÁßªÂá∫Â∑¶‰æßÔºå‰ø°ÊÅØË¥¥ÁùÄÂ∑¶ËæπÁºò
            infoX = 60;
        }
    }

    // Ê†πÊçÆ X ËΩ¥‰ΩçÁΩÆÂÜ≥ÂÆöÁä∂ÊÄÅ‰ø°ÊÅØÊòæÁ§∫Âú®‰∏äËæπÁºòËøòÊòØ‰∏ãËæπÁºòÔºà‰∏ä‰∏ãÈïúÂÉèÂØπÁß∞Ôºâ
    const PADDING_TOP = 5;
    if (originScreenY < canvas.height / 2) {
        // X ËΩ¥ÁßªÂä®Âà∞ËßÜÂè£‰∏≠Á∫ø‰∏äÂçäÈÉ®ÂàÜÔºå‰ø°ÊÅØÊòæÁ§∫Âú®‰∏ãËæπÁºò
        infoY = canvas.height - PADDING_TOP - 40; // ÁïôÂá∫Ë∂≥Â§üÁ©∫Èó¥ÊòæÁ§∫‰∏§Ë°å‰ø°ÊÅØ
        ctx.textBaseline = 'top';
    } else {
        // X ËΩ¥Âú®ËßÜÂè£‰∏≠Á∫ø‰∏ãÂçäÈÉ®ÂàÜÔºàÂåÖÊã¨ÂàùÂßã‰ΩçÁΩÆÔºâÔºå‰ø°ÊÅØÊòæÁ§∫Âú®‰∏äËæπÁºòÔºàÈªòËÆ§Ôºâ
        infoY = PADDING_TOP;
        ctx.textBaseline = 'top';
    }

    // ÊòæÁ§∫Èº†Ê†áÂùêÊ†áÔºàÂßãÁªàÊòæÁ§∫ÔºåÊ≤°ÊúâÈº†Ê†áÊó∂ÊòæÁ§∫0,0ÔºåË∑üË∏™Ê®°Âºè‰∏ã‰∏çÊòæÁ§∫ÂØπÈΩêÔºâ
    let xStr, yStr, altHint = '';
    if (mouseMath && !selectedElement) {
        xStr = isShiftPressed ? mouseMath[0].toString() : mouseMath[0].toFixed(1);
        yStr = isShiftPressed ? mouseMath[1].toString() : mouseMath[1].toFixed(1);
        altHint = isShiftPressed ? ' snap' : '';
    } else if (mouseMath && selectedElement) {
        // Ë∑üË∏™Ê®°Âºè‰∏ãÊòæÁ§∫ÂéüÂßãÂùêÊ†áÔºå‰∏çÊòæÁ§∫ÂØπÈΩê
        xStr = mouseMath[0].toFixed(1);
        yStr = mouseMath[1].toFixed(1);
        altHint = '';
    } else {
        xStr = '0.0';
        yStr = '0.0';
    }

    // È¶ñË°åÊòæÁ§∫ÔºöÂùêÊ†áÂú®ÂâçÔºåÁº©ÊîæÂú®Âêé
    ctx.fillText(`(${xStr}, ${yStr})${altHint}  ${scale.toFixed(2)}√ó`, infoX, infoY);

    // ‰øùÂ≠òÂØπÈΩêÊñπÂºèÔºåÂú® restore ‰πãÂâç
    const currentTextAlign = ctx.textAlign;

    ctx.restore();

    // ËøîÂõû‰ΩçÁΩÆÂíåÂØπÈΩêÊñπÂºèÔºå‰æõ drawStatus ‰ΩøÁî®
    return [ infoX, infoY + 18, currentTextAlign ];
}

// ÁªòÂà∂Áä∂ÊÄÅ‰ø°ÊÅØ
function drawStatus(offset) {

    // Á°Æ‰øù‰ΩøÁî®Á∫ØÂ±èÂπïÂùêÊ†áÁ≥ª
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0); // ÈáçÁΩÆ‰∏∫Â±èÂπïÂùêÊ†áÁ≥ª

    let status;
    switch (drawing) {
        case DRAWING.POLYGON:
            status = `${LangText.STATUS_POLYGON[LANG]} (${drawingPolygon.length} ${LangText.POINTS[LANG]} „Äê${LangText.CLICK_ADD[LANG]}, ${LangText.RELEASE_COMPLETE[LANG]}„Äë`;
            ctx.fillStyle = '#ff6600';
            break;
        case DRAWING.ARC:
            if (isShiftPressed && isPerpendicularLocked) {
                status = `${LangText.STATUS_ARC_PERP[LANG]} „Äê${LangText.MOVE_ON_NORMAL[LANG]}, ${LangText.CLICK_COMPLETE[LANG]}„Äë`;
                ctx.fillStyle = '#ff6600';
            } else {
                status = `${LangText.STATUS_ARC_NORMAL[LANG]} „Äê${LangText.MOVE_ADJUST[LANG]}, ${LangText.CLICK_COMPLETE[LANG]}, ${LangText.PRESS_ALT_PERP[LANG]}„Äë`;
                ctx.fillStyle = '#9932cc';
            }
            break;
        case DRAWING.EASE:
            const easeTypeText = `${getEaseTypeText(currentEaseType)} ${getEaseProcText(currentEaseProc)}`;
            status = `${easeTypeText} ${LangText.DRAWING[LANG]} „Äê${LangText.PRESS_CMD_SWITCH_FUNC[LANG]}; ${LangText.PRESS_ALT_SWITCH_PROC[LANG]}; ${LangText.CLICK_CONFIRM[LANG]}„Äë`;
            ctx.fillStyle = EASE_GROUP_COLORS[currentEaseType] || EASE_GROUP_COLORS['sine'];
            break;
        case DRAWING.BEZIER:
            const bezierTypeText = getBezierTypeText(bezierControlPointCount+2);
            status = `${bezierTypeText} ${LangText.DRAWING[LANG]} „Äê${LangText.CLICK_NEXT_CONTROL[LANG]}, ${LangText.PRESS_CMD_SWITCH_ORDER[LANG]}„Äë`;
            ctx.fillStyle = '#e67e22';
            break;
        default:
            status = LangText.STATUS_HELP[LANG];
            // ÁôΩÂ§©Ê®°ÂºèÁî®Ê∑±ÁÅ∞Ëâ≤Ôºà#888ÔºâÔºåÈªëÂ§úÊ®°ÂºèÁî®ÊµÖÁÅ∞Ëâ≤Ôºà#cccÔºâ
            ctx.fillStyle = THEME ? '#ccc' : '#888';
    }

    ctx.font = '14px Arial';
    // ‰ΩøÁî®‰º†ÂÖ•ÁöÑÂØπÈΩêÊñπÂºèÔºàoffset[2]Ôºâ
    ctx.textAlign = offset[2] || 'left';
    ctx.fillText(status, offset[0], offset[1]);
    ctx.fillStyle = DEFAULT_LINE_COLOR;

    ctx.restore(); // ÊÅ¢Â§ç‰πãÂâçÁöÑÂùêÊ†áÁ≥ªÁä∂ÊÄÅ
}

// ‰∏ªÁªòÂà∂ÂáΩÊï∞
function draw() {

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // ËÆæÁΩÆÊñáÂ≠óÂü∫Á∫ø‰∏∫È°∂ÈÉ®ÂØπÈΩê
    // + Ê≥®ÊÑèÔºåÈªòËÆ§Âü∫Á∫ø alphabeticÔºåÂç≥Â∞Ü y ‰Ωú‰∏∫Â≠óÊØçÁöÑ‰∏ãÁºòÁ∫øÂØπÈΩêÁöÑÔºå
    //   ‰ΩÜ‰Ωú‰∏∫Á∫ØÁªòÂà∂Á≥ªÁªüÔºåÂíåË°åÂ∏ÉÂ±ÄÁ≥ªÁªü‰∏çÂêåÔºåÂç≥Ê≤°Êúâ line-height ÁöÑÊ¶ÇÂøµÔºå
    //   ÊâÄ‰ª•ÂΩì‰ª• y = 0 Êó∂Ôºåalphabetic ‰ºöÂØºËá¥ÊñáÂ≠óÊòæÁ§∫Âú®Â±èÂπïÂ§ñÔºåÂç≥ y = 0 ÊòØÂ≠óÊØçÁöÑ‰∏ãÁºòÁ∫ø
    ctx.textBaseline = 'top';

    ctx.save();

    // Áªü‰∏ÄÂ∫îÁî®ÂùêÊ†áÁ≥ªÂèòÊç¢
    ctx.translate(offsetX, canvas.height + offsetY);
    ctx.scale(scale, -scale); // Y ËΩ¥ÁøªËΩ¨ÔºåÂç≥‰∏ãÊñπ‰ª£Ë°®ÂùêÊ†áÁ≥ª Y ËΩ¥ÁöÑË¥üËΩ¥

    // ÁªòÂà∂ÂùêÊ†áÁ≥ª
    const infoOffset = drawCoordinate();

    // ÁªòÂà∂ÊâÄÊúâÂá†‰ΩïÂÖÉÁ¥†
    elements.forEach(element => {
        drawElement(element);
    });

    if (selectedElement) {

        // ÔºàÈô§‰∫ÜÁÇπÂÖÉÁ¥†ÔºâÁªòÂà∂ÁâπÂæÅÁÇπ
        if (selectedElement.type !== ElementTypes.POINT) {
            drawFeaturePoints();
        }

        // Â¶ÇÊûúÊâìÂºÄ‰∫ÜÂ±ûÊÄßÈù¢Êùø
        if (uiPropertyPanelShown) {

            if (observingPoint) {

                // ÁªòÂà∂ËßÇÊµãÊñπÂêëËæÖÂä©Á∫øÔºàÂú®ËßÇÊµãÁÇπ‰πãÂâçÁªòÂà∂Ôºå‰Ωú‰∏∫ËÉåÊôØÔºâ
                if (observingRelevant) {
                    drawObserveDirectionGuideLine();
                }

                // ÁªòÂà∂ËßÇÊµãÁÇπÔºàÂú®ËæÖÂä©Á∫ø‰πãÂêéÁªòÂà∂ÔºåÁ°Æ‰øùÂú®‰∏äÂ±ÇÔºâ
                drawObservePoints();
            }
        }

        // ÁªòÂà∂ÈÄâ‰∏≠ÂÖÉÁ¥†ÁöÑË∑üË∏™ÁÇπÔºà‰ªÖÂú®ÁâπÂæÅ tab ‰∏ãÔºâ
        if (projectingPoint && !drawing) {

            if (!uiPropertyPanelShown || uiPropertyCurrentTab === 'props') {
                drawTrackingPoint();
            }
        }
    }

    // ÁªòÂà∂‰∫§‰∫íËßÜËßâÂÖÉÁ¥†
    switch (drawing) {
        case DRAWING.POLYGON: if (drawingPolygon.length > 0) drawPolygonPreview(); break;
        case DRAWING.ARC: if (arcStartPoint && arcEndPoint) drawArcCurvaturePreview(); break;
        case DRAWING.EASE: if (easeStartPoint && easeEndPoint) drawEasePreview(); break;
        case DRAWING.BEZIER: if (bezierStartPoint && bezierEndPoint) drawBezierPreview(); break;
        default: {
            //--------------

            // ÁªòÂà∂ËæÖÂä©Á∫ø
            if (drawing === DRAWING.AUX_LINE || drawing === DRAWING.AUX_MENU) {
                drawAuxiliaryLine();
            }
        }
    }

    // ÊÅ¢Â§çÂà∞Â±èÂπïÂùêÊ†áÁ≥ª
    ctx.restore();

    // ÁªòÂà∂ÂΩìÂâçÁä∂ÊÄÅ‰ø°ÊÅØ
    drawStatus(infoOffset);
}

// ÈáçÊñ∞ÁîüÊàêÈúÄË¶ÅÁºìÂ≠òÁöÑÂõæÂΩ¢ÁÇπÊï∞ÊçÆÔºàÂú®Áº©Êîæ„ÄÅÁßªÂä®„ÄÅÁ™óÂè£ÂèòÂåñÁ≠âÊìç‰ΩúÂêéË∞ÉÁî®Ôºâ
function invalidateDrawCache(rescale = false) {

    let needsRedraw = false;

    elements.forEach(element => {

        // ÂØπ‰∫éÂáΩÊï∞ÔºåÂèØËÉΩÂ≠òÂú®Êó†Á©∑ÂÄºÔºåÈúÄË¶Å ROI Êú∫Âà∂ÔºåÂõ†Ê≠§‰ªª‰ΩïËßÜÂè£ÂèòÂåñÈÉΩÈúÄË¶ÅÈáçÊñ∞ÁîüÊàêÁÇπ
        if (element.type === ElementTypes.FUNCTION) {

            // ‰ΩøÁî®Áî®Êà∑ËÆæÂÆöÁöÑÂÆö‰πâÂüüÔºåpixelEvalÂÜÖÈÉ®‰ºöËá™Âä®‰∏éÂΩìÂâçROIÂèñ‰∫§ÈõÜ
            element.props.points = pixelEval((x) => evalExpr(element.props.expr, x),
                element.props.range);
            needsRedraw = true;
        }

        // Ease Êõ≤Á∫øÔºöÂú® rescale Êó∂ÈáçÊñ∞ÁîüÊàêÁÇπÔºàÊèêÈ´òÊòæÁ§∫Á≤æÂ∫¶Ôºâ
        if (rescale && element.type === ElementTypes.EASE) {
            const props = element.props;
            element.props.points = pixelEval((t) => props.func(t,
                props.ft[0], props.ft[1], props.amp, props.aux), false);
            needsRedraw = true;
        }

        // Ë¥ùÂ°ûÂ∞îÊõ≤Á∫øÔºöÂú® rescale Êó∂ÈáçÊñ∞ÁîüÊàêÁÇπÔºàÊèêÈ´òÊòæÁ§∫Á≤æÂ∫¶Ôºâ
        if (rescale && element.type === ElementTypes.BEZIER) {
            element.props.points = pixelEval((t) => bezier(t, element.props.controls), false);
            needsRedraw = true;
        }
    });

    if (needsRedraw) draw();
}

// Âà§Êñ≠ÂΩìÂâçÂùêÊ†áÁ≥ªÊòØÂê¶‰∏∫ÂàùÂßãÁä∂ÊÄÅ
function isInitialState() {
    const eps = 0.01; // ÂÆπÂ∑ÆÂÄºÔºåÂ§ÑÁêÜÊµÆÁÇπÊï∞ËØØÂ∑Æ
    return Math.abs(scale - 1.0) < eps &&
        Math.abs(offsetX - INITIAL_OFFSET_X) < eps &&
        Math.abs(offsetY - INITIAL_OFFSET_Y) < eps;
}
// Âà§Êñ≠ÂΩìÂâçÂùêÊ†áÁ≥ªÊòØÂê¶‰∏∫‰∏ã‰∏≠Áä∂ÊÄÅ
function isBottomCenterState() {
    const eps = 0.01;
    const centerX = canvas.width / 2;
    // ÂøÖÈ°ªÂíå setBottomCenterState ÂÆåÂÖ®‰∏ÄËá¥
    return Math.abs(scale - 1.0) < eps &&
        Math.abs(offsetX - centerX) < eps &&
        Math.abs(offsetY - INITIAL_OFFSET_Y) < eps;
}
// Âà§Êñ≠ÂΩìÂâçÂùêÊ†áÁ≥ªÊòØÂê¶‰∏∫Â±Ö‰∏≠Áä∂ÊÄÅ
function isCenteredState() {
    const eps = 0.01;
    const centerX = canvas.width / 2;
    const centerY = -canvas.height / 2; // Ê≥®ÊÑèÔºöÁî±‰∫éYËΩ¥ÁøªËΩ¨ÔºåÈúÄË¶Å‰ΩøÁî®Ë¥üÂÄº
    // ÂøÖÈ°ªÂíå setCenteredState ÂÆåÂÖ®‰∏ÄËá¥
    return Math.abs(scale - 1.0) < eps &&
        Math.abs(offsetX - centerX) < eps &&
        Math.abs(offsetY - centerY) < eps;
}

// ËÆæÁΩÆÂùêÊ†áÁ≥ª‰∏∫ÂàùÂßãÁä∂ÊÄÅ
function setInitialState() {
    scale = 1.0;
    offsetX = INITIAL_OFFSET_X;
    offsetY = INITIAL_OFFSET_Y;
    coordinateState = COORDINATE_STATES.INITIAL;
    syncScreenCoords();
    updatePanelPosition();
    invalidateCoordinateCache();
    invalidateDrawCache(true);
    draw();
}
// ËÆæÁΩÆÂùêÊ†áÁ≥ª‰∏∫‰∏ã‰∏≠Áä∂ÊÄÅ
function setBottomCenterState() {
    scale = 1.0;
    offsetX = canvas.width / 2;
    offsetY = INITIAL_OFFSET_Y;
    coordinateState = COORDINATE_STATES.BOTTOM_CENTER;
    syncScreenCoords();
    updatePanelPosition();
    invalidateCoordinateCache();
    invalidateDrawCache(true);
    draw();
}
// ËÆæÁΩÆÂùêÊ†áÁ≥ª‰∏∫Â±Ö‰∏≠Áä∂ÊÄÅ
function setCenteredState() {
    scale = 1.0;
    offsetX = canvas.width / 2;
    offsetY = -canvas.height / 2; // Ê≥®ÊÑèÔºöÁî±‰∫éYËΩ¥ÁøªËΩ¨ÔºåÈúÄË¶Å‰ΩøÁî®Ë¥üÂÄº
    coordinateState = COORDINATE_STATES.CENTERED;
    syncScreenCoords();
    updatePanelPosition();
    invalidateCoordinateCache();
    invalidateDrawCache(true);
    draw();
}

// ËΩÆËØ¢ÂàáÊç¢ÂùêÊ†áÁ≥ªÁä∂ÊÄÅÔºà‰∏âÊÄÅÂæ™ÁéØÔºöÂ∑¶‰∏ã‚Üí‰∏ã‰∏≠‚Üí‰∏≠ÂøÉÔºâ
function cycleCoordinateSystem() {
    if (isInitialState()) {
        setBottomCenterState();
    } else if (isBottomCenterState()) {
        setCenteredState();
    } else if (isCenteredState()) {
        setInitialState();
    } else {
        setInitialState();
    }
}

// Ëé∑ÂèñÂΩìÂâçËßÜÂè£ÁöÑÊï∞Â≠¶ÂùêÊ†áËåÉÂõ¥
function getViewportRange() {
    let leftX, rightX, topY, bottomY;

    if (coordinateState === COORDINATE_STATES.CENTERED) {
        // ÂéüÁÇπÂ±Ö‰∏≠Ê®°ÂºèÔºöÂéüÁÇπÂú®Â±èÂπï‰∏≠ÂøÉ
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        leftX = -centerX / (UNIT_SIZE * scale);
        rightX = centerX / (UNIT_SIZE * scale);
        bottomY = -centerY / (UNIT_SIZE * scale);
        topY = centerY / (UNIT_SIZE * scale);
    } else if (coordinateState === COORDINATE_STATES.BOTTOM_CENTER) {
        // ÂéüÁÇπÂú®Â±èÂπï‰∏ãÊñπ‰∏≠Èó¥Ôºåy ÊñπÂêëÂíåÂ∑¶‰∏ãËßí‰∏ÄËá¥
        const centerX = canvas.width / 2;
        leftX = -centerX / (UNIT_SIZE * scale);
        rightX = centerX / (UNIT_SIZE * scale);
        topY = (canvas.height + offsetY) / (UNIT_SIZE * scale);
        bottomY = offsetY / (UNIT_SIZE * scale);
    } else {
        // ÂéüÁÇπÂ∑¶‰∏ãÊ®°ÂºèÔºö‰ΩøÁî®offsetËÆ°ÁÆó
        leftX = -offsetX / (UNIT_SIZE * scale);
        rightX = (canvas.width - offsetX) / (UNIT_SIZE * scale);
        topY = (canvas.height + offsetY) / (UNIT_SIZE * scale);
        bottomY = offsetY / (UNIT_SIZE * scale);
    }

    // Ê∑ªÂä†‰∏Ä‰∫õÁºìÂÜ≤Âå∫Âüü‰ª•Á°Æ‰øùÂú®ËæπÁïåÂ§Ñ‰πüÊúâÊõ≤Á∫ø
    const bufferX = (rightX - leftX) * 0.1; // 10% ÁºìÂÜ≤

    return {
        xMin: leftX - bufferX,
        xMax: rightX + bufferX,
        yMin: bottomY,
        yMax: topY
    };
}

// Âä®ÊÄÅËÆ°ÁÆóÁΩëÊ†ºÈó¥ÈöîÂíåÊñáÂ≠óÈó¥Èöî
function calculateGridSpacing(scale) {

    // Âü∫Á°ÄÈó¥Èöî‰∏∫1ÔºåÊ†πÊçÆÁº©ÊîæË∞ÉÊï¥
    let gridStep = 1;           // ÊØè‰∏™ÁΩëÁªúË°®Á§∫ 1 ‰∏™Âçï‰Ωç
    let labelStep = 5;          // ÊØè 5 ‰∏™Âçï‰ΩçÊòæÁ§∫‰∏Ä‰∏™Ê†áÁ≠æ

    // Áº©Â∞èÂæàÂ§öÊó∂ÔºåÁΩëÊ†ºÈó¥ÈöîÂèòÂ§ßÔºåÊ†áÁ≠æÈó¥Èöî‰πüÂèòÂ§ß
    if (scale < 0.5) {
        gridStep = Math.ceil(2 / scale);
        labelStep = Math.ceil(10 / scale);
    }
    // ËΩªÂæÆÁº©Â∞èÊó∂ÔºåÈÄÇÂ∫¶Ë∞ÉÊï¥
    else if (scale < 1) {
        gridStep = Math.ceil(1 / scale);
        labelStep = Math.ceil(5 / scale);
    }
    // ÊîæÂ§ßÊó∂ÔºåÂèØ‰ª•ÊòæÁ§∫Êõ¥ÂØÜÈõÜÁöÑÁΩëÊ†º
    else if (scale > 2) {
        gridStep = 1;
        labelStep = Math.max(1, Math.floor(5 / scale));
    }

    return { gridStep, labelStep };
}

window.cycleCoordinateSystem = cycleCoordinateSystem;

/* ================================ */
/* ÂÖÉÁ¥†ÁªòÂà∂Á≥ªÁªü */
/* ================================ */

// ÁªòÂà∂ËæÖÂä©Á∫øÂáΩÊï∞Ôºà‰ª•Èº†Ê†áÊåâ‰∏ã‰Ωú‰∏∫Ëµ∑ÁÇπÔºåÈº†Ê†áÊä¨Ëµ∑‰Ωú‰∏∫ÁªàÁÇπÂπ∂ÂºπÂá∫ËèúÂçïÔºåÈº†Ê†áÊãñÂä®ËøáÁ®ã‰∏≠ÁªòÂà∂ÁöÑÁ∫øÔºâ
function drawAuxiliaryLine() {
    if (!drawStart) return;

    // ÂÜ≥ÂÆö‰ΩøÁî®Âì™‰∏™ÁªàÁÇπÔºöÂõ∫ÂÆöÊ®°Âºè‰ΩøÁî®endPointÔºåÂä®ÊÄÅÊ®°Âºè‰ΩøÁî®currentMousePoint
    let targetPoint;
    if (drawing === DRAWING.AUX_MENU && drawEnd)
        targetPoint = drawEnd; // ‰ΩøÁî®Âõ∫ÂÆöÁöÑÁªàÁÇπ
    else if (mouseMath)
        targetPoint = mouseMath; // ‰ΩøÁî®Âä®ÊÄÅÈº†Ê†á‰ΩçÁΩÆ
    else return; // Ê≤°ÊúâÂèØÁî®ÁöÑÁªàÁÇπ

    ctx.save();

    // ËÆæÁΩÆËæÖÂä©Á∫øÊ†∑Âºè
    ctx.strokeStyle = 'rgba(128, 128, 128, 0.8)'; // ÁÅ∞Ëâ≤ÔºåÂçäÈÄèÊòé
    ctx.lineWidth = 1 / scale;
    ctx.setLineDash([5 / scale, 5 / scale]); // ËôöÁ∫øÊ†∑Âºè

    // ÁªòÂà∂ËæÖÂä©Á∫ø
    ctx.beginPath();
    ctx.moveTo(drawStart[0] * UNIT_SIZE, drawStart[1] * UNIT_SIZE);
    ctx.lineTo(targetPoint[0] * UNIT_SIZE, targetPoint[1] * UNIT_SIZE);
    ctx.stroke();

    // ËÆ°ÁÆóÈïøÂ∫¶
    const length = Math.sqrt((targetPoint[0] - drawStart[0]) ** 2 + (targetPoint[1] - drawStart[1]) ** 2);
    
    // ËÆ°ÁÆóÊñπÂêëËßíÔºà‰ªéËµ∑ÁÇπÂà∞ÁªàÁÇπÔºâ
    const angle = Math.atan2(targetPoint[1] - drawStart[1], targetPoint[0] - drawStart[0]) * 180 / Math.PI;
    
    // ËÆ°ÁÆó‰∏≠ÁÇπÔºàÊòæÁ§∫ÈïøÂ∫¶Ôºâ
    const midX = (drawStart[0] + targetPoint[0]) / 2;
    const midY = (drawStart[1] + targetPoint[1]) / 2;
    
    ctx.restore();
    
    // Âú®Â±èÂπïÂùêÊ†áÁ≥ª‰∏ãÁªòÂà∂ÊñáÊú¨
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0); // ÈáçÁΩÆ‰∏∫Â±èÂπïÂùêÊ†áÁ≥ª
    ctx.font = '11px Arial';
    ctx.fillStyle = 'rgba(128, 128, 128, 0.8)'; // ÂíåËæÖÂä©Á∫øÂêåËâ≤
    
    // ÊòæÁ§∫ÈïøÂ∫¶Ôºà‰∏≠Â§ÆÔºåÁ∫øÁöÑ‰∏äÈù¢Ôºâ
    const [midScreenX, midScreenY] = mathToScreen(midX, midY);
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.fillText(`${length.toFixed(2)}`, midScreenX, midScreenY - 5);
    
    // ÊòæÁ§∫ÊñπÂêëËßíÔºàËµ∑ÁÇπÈôÑËøëÔºâ
    // Ê†πÊçÆËæÖÂä©Á∫øÊñπÂêëÂÜ≥ÂÆöÊñáÊú¨‰ΩçÁΩÆÔºöÂêë‰∏äÊó∂Âú®‰∏ãÊñπÔºåÂêë‰∏ãÊó∂Âú®‰∏äÊñπ
    const [startScreenX, startScreenY] = mathToScreen(drawStart[0], drawStart[1]);
    ctx.textAlign = 'center';
    const dy = targetPoint[1] - drawStart[1];
    if (dy >= 0) {
        // ËæÖÂä©Á∫øÂêë‰∏äÔºåÊñáÊú¨Âú®‰∏ãÊñπ
        ctx.textBaseline = 'top';
        ctx.fillText(`${angle.toFixed(1)}¬∞`, startScreenX, startScreenY + 5);
    } else {
        // ËæÖÂä©Á∫øÂêë‰∏ãÔºåÊñáÊú¨Âú®‰∏äÊñπ
        ctx.textBaseline = 'bottom';
        ctx.fillText(`${angle.toFixed(1)}¬∞`, startScreenX, startScreenY - 5);
    }
    
    ctx.restore();
}

// ÁªòÂà∂Âçï‰∏™Âá†‰ΩïÂÖÉÁ¥† - Ê†πÊçÆÂÖÉÁ¥†Á±ªÂûãÁªòÂà∂ÂØπÂ∫îÁöÑÂá†‰ΩïÂõæÂΩ¢
function drawElement(element) {
    if (!element.visible) return;

    // Ê†πÊçÆÂèòÊç¢Èù¢ÊùøÁä∂ÊÄÅÂÜ≥ÂÆöÂ∫îÁî®ÁöÑÂèòÊç¢
    let transformedElement;
    if (element === selectedElement) {
        // ÂèòÊç¢Èù¢ÊùøÊâìÂºÄ‰∏îÊòØÂΩìÂâçÁºñËæëÁöÑÂÖÉÁ¥†ÔºöÂè™Â∫îÁî®ÂΩìÂâçÊ†áÁ≠æÈ°µÁöÑÂèòÊç¢
        transformedElement = applyCurrentTabTransform(element);

        // ÁªòÂà∂Âº±ÂåñÁöÑÂÆåÊï¥ÂèòÊç¢È¢ÑËßà
        drawTransformPreview(element);
    } else {
        // Ê≠£Â∏∏ÁªòÂà∂ÔºöÂ∫îÁî®ÂÆåÊï¥ÂèòÊç¢
        transformedElement = applyTransformToElement(element);
    }

    ctx.save();

    // Âà§Êñ≠ÊòØÂê¶È´ò‰∫ÆÂΩìÂâçÂèòÊç¢ÂÖÉÁ¥†
    const isHighlight = element === selectedElement;

    const [props, attrs] = [transformedElement.props, transformedElement.attrs || {}];
    switch (transformedElement.type) {
        case ElementTypes.POINT:
            drawPoint(props, attrs, isHighlight);
            break;
        case ElementTypes.SEG:
            drawSeg(props, attrs, isHighlight);
            break;
        case ElementTypes.RECTANGLE:
            drawRectangle(props, attrs, isHighlight);
            break;
        case ElementTypes.CIRCLE:
            drawCircle(props, attrs, isHighlight);
            break;
        case ElementTypes.ARC:
            drawArc(props, attrs, isHighlight);
            break;
        case ElementTypes.POLYGON:
            drawPolygon(props, attrs, isHighlight);
            break;
        case ElementTypes.EASE:
            drawEase(props, attrs, isHighlight);
            break;
        case ElementTypes.BEZIER:
            drawBezier(props, attrs, isHighlight);
            break;
        case ElementTypes.FUNCTION:
            drawFunction(props, attrs, isHighlight);
            break;
    }

    ctx.restore();
}

// ÂÖ∑‰ΩìÁöÑÁªòÂà∂ÂáΩÊï∞
function drawPoint(props, attrs) {
    const isHighlight = arguments[1] === true;
    ctx.save();
    if (isHighlight) {
        ctx.shadowColor = HIGHLIGHT_COLOR;
        ctx.shadowBlur = HIGHLIGHT_SHADOW_BLUR * scale;
        ctx.fillStyle = HIGHLIGHT_COLOR;
    } else {
        ctx.fillStyle = resolveColor(attrs.color || DEFAULT_LINE_COLOR);
    }
    // ÁÇπÁöÑÂ§ßÂ∞è‰ΩøÁî® attrs.widthÔºåËøôÊ†∑ÂèØ‰ª•Âú®Â±ûÊÄßÈù¢Êùø‰∏≠Ë∞ÉÊï¥
    // ‰∏∫‰∫ÜËßÜËßâ‰∏äÊõ¥ÊòéÊòæÔºåÁÇπÁöÑÂçäÂæÑËÆæ‰∏∫Á∫øÂÆΩÔºàÂç≥Áõ¥ÂæÑÁ≠â‰∫éÁ∫øÂÆΩÁöÑ2ÂÄçÔºâ
    const pointSize = attrs.width || POINT_DEFAULT_SIZE;
    const halfSize = pointSize / scale; // ÂçäÂæÑ = Á∫øÂÆΩÔºåÊâÄ‰ª•Áõ¥ÂæÑ = Á∫øÂÆΩ * 2
    const style = props.style || POINT_DEFAULT_STYLE;
    if (style === POINT_STYLES.CIRCLE) {
        ctx.beginPath();
        ctx.arc(props.coords[0] * UNIT_SIZE, props.coords[1] * UNIT_SIZE, halfSize, 0, PI2);
        ctx.fill();
    } else if (style === POINT_STYLES.SQUARE) {
        ctx.fillRect(
            props.coords[0] * UNIT_SIZE - halfSize,
            props.coords[1] * UNIT_SIZE - halfSize,
            halfSize * 2,
            halfSize * 2
        );
    }
    ctx.restore();
}
function drawSeg(props, attrs) {
    const isHighlight = arguments[2] === true;
    ctx.save();
    if (isHighlight) {
        ctx.shadowColor = HIGHLIGHT_COLOR;
        ctx.shadowBlur = HIGHLIGHT_SHADOW_BLUR * scale;
        ctx.strokeStyle = HIGHLIGHT_COLOR;
        ctx.lineWidth = Math.max(HIGHLIGHT_LINE_WIDTH_MIN, (attrs.width || DEFAULT_LINE_WIDTH) * HIGHLIGHT_LINE_WIDTH_FACTOR) / scale;
    } else {
        ctx.strokeStyle = resolveColor(attrs.color || DEFAULT_LINE_COLOR);
        ctx.lineWidth = (attrs.width || DEFAULT_LINE_WIDTH) / scale;
    }
    ctx.beginPath();
    ctx.moveTo(props.ft[0][0] * UNIT_SIZE, props.ft[0][1] * UNIT_SIZE);
    ctx.lineTo(props.ft[1][0] * UNIT_SIZE, props.ft[1][1] * UNIT_SIZE);
    ctx.stroke();
    ctx.restore();
}
function drawCircle(props, attrs) {
    const isHighlight = arguments[2] === true;
    ctx.save();

    // Ê£ÄÊü•ÊòØÂê¶ÈúÄË¶ÅÊòæÁ§∫Èù¢ÁßØÂ°´ÂÖÖÔºàÂè™ÂØπÂΩìÂâçÈÄâ‰∏≠ÂÖÉÁ¥†Ôºâ
    const showAreaCheckbox = document.getElementById('showArea');
    const shouldFillArea = showAreaCheckbox && showAreaCheckbox.checked && isHighlight;

    if (isHighlight) {
        ctx.shadowColor = HIGHLIGHT_COLOR;
        ctx.shadowBlur = HIGHLIGHT_SHADOW_BLUR * scale;
        ctx.strokeStyle = HIGHLIGHT_COLOR;
        ctx.lineWidth = Math.max(HIGHLIGHT_LINE_WIDTH_MIN, (attrs.width || DEFAULT_LINE_WIDTH) * HIGHLIGHT_LINE_WIDTH_FACTOR) / scale;
    } else {
        ctx.strokeStyle = resolveColor(attrs.color || DEFAULT_LINE_COLOR);
        ctx.lineWidth = (attrs.width || DEFAULT_LINE_WIDTH) / scale;
    }

    ctx.beginPath();
    ctx.arc(props.centroid[0] * UNIT_SIZE, props.centroid[1] * UNIT_SIZE, props.radius * UNIT_SIZE, 0, PI2);

    // Â¶ÇÊûúÈúÄË¶ÅÊòæÁ§∫Èù¢ÁßØÔºåÂÖàÂ°´ÂÖÖÂêéÊèèËæπ
    if (shouldFillArea) {
        ctx.fillStyle = 'rgba(135, 206, 250, 0.2)'; // Ê∑°ËìùËâ≤Â°´ÂÖÖÔºå20%ÈÄèÊòéÂ∫¶
        ctx.fill();
    }

    ctx.stroke();
    ctx.restore();
}
function drawRectangle(props, attrs) {
    const isHighlight = arguments[2] === true;
    ctx.save();

    // Ê£ÄÊü•ÊòØÂê¶ÈúÄË¶ÅÊòæÁ§∫Èù¢ÁßØÂ°´ÂÖÖÔºàÂè™ÂØπÂΩìÂâçÈÄâ‰∏≠ÂÖÉÁ¥†Ôºâ
    const showAreaCheckbox = document.getElementById('showArea');
    const shouldFillArea = showAreaCheckbox && showAreaCheckbox.checked && isHighlight;

    if (isHighlight) {
        ctx.shadowColor = HIGHLIGHT_COLOR;
        ctx.shadowBlur = HIGHLIGHT_SHADOW_BLUR * scale;
        ctx.strokeStyle = HIGHLIGHT_COLOR;
        ctx.lineWidth = Math.max(HIGHLIGHT_LINE_WIDTH_MIN, (attrs.width || DEFAULT_LINE_WIDTH) * HIGHLIGHT_LINE_WIDTH_FACTOR) / scale;
    } else {
        ctx.strokeStyle = resolveColor(attrs.color || DEFAULT_LINE_COLOR);
        ctx.lineWidth = (attrs.width || DEFAULT_LINE_WIDTH) / scale;
    }
    const x = props.box[2] * UNIT_SIZE;  // left
    const y = props.box[5] * UNIT_SIZE;  // bottom ‰Ωú‰∏∫Ëµ∑ÂßãYÂùêÊ†á
    const width = (props.box[4] - props.box[2]) * UNIT_SIZE;  // right - left
    const height = (props.box[3] - props.box[5]) * UNIT_SIZE; // top - bottom
    ctx.beginPath();
    ctx.rect(x, y, width, height);

    // Â¶ÇÊûúÈúÄË¶ÅÊòæÁ§∫Èù¢ÁßØÔºåÂÖàÂ°´ÂÖÖÂêéÊèèËæπ
    if (shouldFillArea) {
        ctx.fillStyle = 'rgba(144, 238, 144, 0.25)'; // Ê∑°ÁªøËâ≤Â°´ÂÖÖÔºå25%ÈÄèÊòéÂ∫¶
        ctx.fill();
    }

    ctx.stroke();
    ctx.restore();
}
function drawPolygon(props, attrs) {

    if (!props.ft || props.ft.length < 2) return;

    // ÊîØÊåÅÈ´ò‰∫ÆÂèÇÊï∞
    const isHighlight = arguments[2] === true;
    ctx.save();
    ctx.beginPath();

    const firstPoint = props.ft[0];
    ctx.moveTo(firstPoint[0] * UNIT_SIZE, firstPoint[1] * UNIT_SIZE);

    for (let i = 1; i < props.ft.length; i++) {
        const point = props.ft[i];
        ctx.lineTo(point[0] * UNIT_SIZE, point[1] * UNIT_SIZE);
    }

    if (props.closed) {
        ctx.closePath();
    }

    // Ê£ÄÊü•ÊòØÂê¶ÈúÄË¶ÅÊòæÁ§∫Èù¢ÁßØÂ°´ÂÖÖÔºàÂè™ÂØπÂΩìÂâçÈÄâ‰∏≠ÁöÑÂ∞ÅÈó≠Â§öËæπÂΩ¢Â°´ÂÖÖÔºâ
    const showAreaCheckbox = document.getElementById('showArea');
    const shouldFillArea = showAreaCheckbox && showAreaCheckbox.checked && props.closed && isHighlight;

    // Â¶ÇÊûúÈúÄË¶ÅÊòæÁ§∫Èù¢ÁßØÔºåÂÖàÂ°´ÂÖÖ
    if (shouldFillArea) {
        ctx.fillStyle = 'rgba(255, 192, 203, 0.3)'; // Ê∑°Á≤âËâ≤Â°´ÂÖÖÔºå30%ÈÄèÊòéÂ∫¶
        ctx.fill();
    }

    // È´ò‰∫ÆÊó∂‰ΩøÁî®ÁâπÊÆäÊèèËæπ
    if (isHighlight) {
        ctx.shadowColor = HIGHLIGHT_COLOR;
        ctx.shadowBlur = HIGHLIGHT_SHADOW_BLUR * scale;
        ctx.strokeStyle = HIGHLIGHT_COLOR;
        ctx.lineWidth = Math.max(HIGHLIGHT_LINE_WIDTH_MIN, (attrs.width || DEFAULT_LINE_WIDTH) * HIGHLIGHT_LINE_WIDTH_FACTOR) / scale;
    } else {
        ctx.strokeStyle = resolveColor(attrs.color || DEFAULT_LINE_COLOR);
        ctx.lineWidth = (attrs.width || DEFAULT_LINE_WIDTH) / scale;
    }

    ctx.stroke();
    ctx.restore();

    // Âè™Âú®ÈÄâ‰∏≠Êó∂ÁªòÂà∂ÊØè‰∏™È°∂ÁÇπÁöÑÂ∞èËßíÂºßÂíåËßíÂ∫¶Ê†áÊ≥®ÔºåÁü©ÂΩ¢Ôºà4ËæπÂΩ¢Ôºâ‰∏çÊòæÁ§∫ËßíÂ∫¶
    if (props.ft.length >= 3 && isHighlight && props.ft.length !== 4) {
        const n = props.ft.length;
        // ËÆ∞ÂΩï‰∏ä‰∏Ä‰∏™ËßíÂ∫¶ÊñáÂ≠óÁöÑ‰ΩçÁΩÆ
        let lastLabelX = null, lastLabelY = null;
        const minTextDist = 18 / scale; // ÊúÄÂ∞èË∑ùÁ¶ªÔºåÈò≤Ê≠¢ÈáçÂè†
        const minArcTextDist = 10; // ÊñáÂ≠ó‰∏éÂºßÁ∫øÊúÄÂ∞èÂÆâÂÖ®Ë∑ùÁ¶ª
        const maxArcTextDist = 28; // ÊñáÂ≠ó‰∏éÂºßÁ∫øÊúÄÂ§ßÂÆâÂÖ®Ë∑ùÁ¶ª
        for (let i = 0; i < n; i++) {
            const prev = props.ft[(i - 1 + n) % n];
            const curr = props.ft[i];
            const next = props.ft[(i + 1) % n];

            // ÂêëÈáè
            const v1x = prev[0] - curr[0];
            const v1y = prev[1] - curr[1];
            const v2x = next[0] - curr[0];
            const v2y = next[1] - curr[1];

            // ËÆ°ÁÆóÂêëÈáèÂ§πËßí
            let angle1 = Math.atan2(v1y, v1x);
            let angle2 = Math.atan2(v2y, v2x);
            let angle = angle2 - angle1;
            // ‰øùËØÅÊòØÂ∞è‰∫éœÄÁöÑÂ∞èËßí
            if (angle <= 0) angle += PI2;
            if (angle > Math.PI) {
                // ÂèñË°•ËßíÔºåÂèçÂêëÁîªÂºß
                angle = PI2 - angle;
                let tmp = angle1;
                angle1 = angle2;
                angle2 = tmp;
            }

            // Â§πËßíÂºßÂçäÂæÑÔºàÊõ¥Â∞èÔºåÊõ¥Ë¥¥ËøëÈ°∂ÁÇπÔºâ
            const len1 = Math.sqrt(v1x * v1x + v1y * v1y);
            const len2 = Math.sqrt(v2x * v2x + v2y * v2y);
            let arcRadius = Math.min(len1, len2) * UNIT_SIZE;
            if (arcRadius > 5) arcRadius = 10 / scale;

            // Âà§Êñ≠ÊòØÂê¶ÁîªÂ§ñ‰æßÂºßÁ∫ø
            let drawOuterArc = (angle * R2D) < 45;
            let arcStart = angle1, arcEnd = angle2, arcSweep = false;
            let arcLabelAngle, arcLabelRadius;
            if (drawOuterArc) {
                arcStart = angle2;
                arcEnd = angle1 + 2 * Math.PI;
                arcSweep = false;
                arcLabelAngle = (arcStart + arcEnd) / 2;
                arcLabelRadius = arcRadius + 14;
            } else {
                arcStart = angle1;
                arcEnd = angle2;
                arcSweep = false;
                arcLabelAngle = (arcStart + arcEnd) / 2;
                arcLabelRadius = arcRadius + 14;
            }
            // Âä®ÊÄÅË∞ÉÊï¥labelRadiusÔºå‰øùËØÅ‰∏éÂºßÁ∫øÊó¢‰∏çÈáçÂè†‰πü‰∏çËøáËøú
            if (arcLabelRadius - arcRadius < minArcTextDist) {
                arcLabelRadius = arcRadius + minArcTextDist;
            } else if (arcLabelRadius - arcRadius > maxArcTextDist) {
                arcLabelRadius = arcRadius + maxArcTextDist;
            }
            // Êô∫ËÉΩÈÅøËÆ©ÔºöÂ¶Ç‰∏é‰∏ä‰∏Ä‰∏™ËßíÂ∫¶ÊñáÂ≠óË∑ùÁ¶ªËøáËøëÔºåÂàôÂä†Â§ßÊú¨È°∂ÁÇπÊñáÂ≠óÂçäÂæÑ
            let labelX = curr[0] * UNIT_SIZE + arcLabelRadius * Math.cos(arcLabelAngle);
            let labelY = curr[1] * UNIT_SIZE + arcLabelRadius * Math.sin(arcLabelAngle);
            if (lastLabelX !== null && lastLabelY !== null) {
                let dist = Math.sqrt((labelX - lastLabelX) ** 2 + (labelY - lastLabelY) ** 2);
                if (dist < minTextDist) {
                    arcLabelRadius += minTextDist;
                    labelX = curr[0] * UNIT_SIZE + arcLabelRadius * Math.cos(arcLabelAngle);
                    labelY = curr[1] * UNIT_SIZE + arcLabelRadius * Math.sin(arcLabelAngle);
                }
            }
            lastLabelX = labelX;
            lastLabelY = labelY;

            // ÁîªÂºß
            ctx.save();
            ctx.beginPath();
            ctx.strokeStyle = '#ffa500';
            ctx.lineWidth = 1.5 / scale;
            ctx.arc(
                curr[0] * UNIT_SIZE,
                curr[1] * UNIT_SIZE,
                arcRadius,
                arcStart,
                arcEnd,
                arcSweep
            );
            ctx.stroke();
            ctx.restore();

            // Ê†áÊ≥®ËßíÂ∫¶
            ctx.save();
            ctx.font = `${12 / scale}px Arial`;
            ctx.fillStyle = '#d2691e';
            // ËæπÊ°ÜÈ¢úËâ≤‰∏é‰∏ªÈ¢òËÉåÊôØ‰∏ÄËá¥ÔºöÁôΩÂ§©ÈªëËæπÔºåÈªëÂ§úÁôΩËæπ
            ctx.strokeStyle = THEME ? '#000000' : '#ffffff';
            ctx.lineWidth = 3.2 / scale;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.translate(labelX, labelY);
            ctx.scale(1, -1);
            const deg = (angle * 180 / Math.PI).toFixed(1);
            ctx.strokeText(`${deg}¬∞`, 0, 0);
            ctx.fillText(`${deg}¬∞`, 0, 0);
            ctx.restore();
        }
    }
}
function drawArc(props, attrs) {
    const isHighlight = arguments[2] === true;
    ctx.save();

    // Ê£ÄÊü•ÊòØÂê¶ÈúÄË¶ÅÊòæÁ§∫Èù¢ÁßØÂ°´ÂÖÖÔºàÂè™ÂØπÂΩìÂâçÈÄâ‰∏≠ÂÖÉÁ¥†Ôºâ
    const showAreaCheckbox = document.getElementById('showArea');
    const shouldFillArea = showAreaCheckbox && showAreaCheckbox.checked && isHighlight;

    if (isHighlight) {
        ctx.shadowColor = HIGHLIGHT_COLOR;
        ctx.shadowBlur = HIGHLIGHT_SHADOW_BLUR * scale;
        ctx.strokeStyle = HIGHLIGHT_COLOR;
        ctx.lineWidth = Math.max(HIGHLIGHT_LINE_WIDTH_MIN, (attrs.width || DEFAULT_LINE_WIDTH) * HIGHLIGHT_LINE_WIDTH_FACTOR) / scale;
    } else {
        ctx.strokeStyle = resolveColor(attrs.color || DEFAULT_LINE_COLOR);
        ctx.lineWidth = (attrs.width || DEFAULT_LINE_WIDTH) / scale;
    }

    const centerX = props.ft[0][0] * UNIT_SIZE;
    const centerY = props.ft[0][1] * UNIT_SIZE;
    const radius = props.radius * UNIT_SIZE;

    // Â¶ÇÊûúÈúÄË¶ÅÊòæÁ§∫Èù¢ÁßØÔºåÂÖàÁªòÂà∂ÂºìÂΩ¢Â°´ÂÖÖÔºàÂºßÁ∫ø‰∏éÂº¶Âõ¥ÊàêÁöÑÂå∫ÂüüÔºâ
    if (shouldFillArea) {
        ctx.beginPath();
        // ËÆ°ÁÆóÂºßÁöÑËµ∑ÁÇπÂíåÁªàÁÇπÂùêÊ†á
        const startX = centerX + radius * Math.cos(props.startRad);
        const startY = centerY + radius * Math.sin(props.startRad);
        //const endX = centerX + radius * Math.cos(props.endRad);
        //const endY = centerY + radius * Math.sin(props.endRad);

        // ÁßªÂä®Âà∞ÂºßÁöÑËµ∑ÁÇπ
        ctx.moveTo(startX, startY);
        // ÁªòÂà∂ÂºßÁ∫ø
        ctx.arc(centerX, centerY, radius, props.startRad, props.endRad);
        // ÁªòÂà∂Âº¶Á∫øÂõûÂà∞Ëµ∑ÁÇπÔºåÂΩ¢ÊàêÂºìÂΩ¢
        ctx.lineTo(startX, startY);
        ctx.closePath();

        ctx.fillStyle = 'rgba(255, 215, 0, 0.25)'; // Ê∑°ÈáëËâ≤Â°´ÂÖÖÔºå25%ÈÄèÊòéÂ∫¶
        ctx.fill();
    }

    // ÁªòÂà∂ÂºßÁ∫ø
    ctx.beginPath();
    ctx.arc(centerX, centerY, radius, props.startRad, props.endRad);
    ctx.stroke();
    ctx.restore();
}
function drawEase(props, attrs) {
    const isHighlight = arguments[2] === true;
    ctx.save();

    // Ê£ÄÊü•ÊòØÂê¶ÈúÄË¶ÅÊòæÁ§∫Èù¢ÁßØÂ°´ÂÖÖÔºàÂè™ÂØπÂΩìÂâçÈÄâ‰∏≠ÂÖÉÁ¥†Ôºå‰ΩøÁî®Âá∏ÂåÖÔºâ
    const showAreaCheckbox = document.getElementById('showArea');
    const shouldFillArea = showAreaCheckbox && showAreaCheckbox.checked && isHighlight && props.convex;

    if (isHighlight) {
        ctx.shadowColor = HIGHLIGHT_COLOR;
        ctx.shadowBlur = HIGHLIGHT_SHADOW_BLUR * scale;
        ctx.strokeStyle = HIGHLIGHT_COLOR;
        ctx.lineWidth = HIGHLIGHT_LINE_WIDTH_MIN / scale;
    } else {
        ctx.strokeStyle = resolveColor(attrs.color || DEFAULT_LINE_COLOR);
        ctx.lineWidth = (attrs.width || DEFAULT_LINE_WIDTH) / scale;
    }

    // Â¶ÇÊûúÈúÄË¶ÅÊòæÁ§∫Èù¢ÁßØÔºåÂÖàÁªòÂà∂Âá∏ÂåÖÂ°´ÂÖÖ
    if (shouldFillArea) {
        ctx.beginPath();
        if (props.convex.length > 0) {
            ctx.moveTo(props.convex[0][0] * UNIT_SIZE, props.convex[0][1] * UNIT_SIZE);
            for (let i = 1; i < props.convex.length; i++) {
                ctx.lineTo(props.convex[i][0] * UNIT_SIZE, props.convex[i][1] * UNIT_SIZE);
            }
            ctx.closePath();
            ctx.fillStyle = 'rgba(147, 112, 219, 0.2)'; // Ê∑°Á¥´Ëâ≤Â°´ÂÖÖÔºå20%ÈÄèÊòéÂ∫¶
            ctx.fill();
        }
    }

    // ÁªòÂà∂easeÊõ≤Á∫ø
    ctx.beginPath();
    ctx.moveTo(props.ft[0][0] * UNIT_SIZE, props.ft[0][1] * UNIT_SIZE);
    const points = props.points;
    for (let i = 1; i < points.length; i++) {
        ctx.lineTo(points[i][0] * UNIT_SIZE, points[i][1] * UNIT_SIZE);
    }
    ctx.stroke();
    ctx.restore();
}
function drawBezier(props, attrs) {
    const isHighlight = arguments[2] === true;
    ctx.save();

    // Ê£ÄÊü•ÊòØÂê¶ÈúÄË¶ÅÊòæÁ§∫Èù¢ÁßØÂ°´ÂÖÖÔºàÂè™ÂØπÂΩìÂâçÈÄâ‰∏≠ÂÖÉÁ¥†Ôºå‰ΩøÁî®Âá∏ÂåÖÔºâ
    const showAreaCheckbox = document.getElementById('showArea');
    const shouldFillArea = showAreaCheckbox && showAreaCheckbox.checked && isHighlight && props.convex;

    if (isHighlight) {
        ctx.shadowColor = HIGHLIGHT_COLOR;
        ctx.shadowBlur = HIGHLIGHT_SHADOW_BLUR * scale;
        ctx.strokeStyle = HIGHLIGHT_COLOR;
        ctx.lineWidth = Math.max(HIGHLIGHT_LINE_WIDTH_MIN, (attrs.width || DEFAULT_LINE_WIDTH) * HIGHLIGHT_LINE_WIDTH_FACTOR) / scale;
    } else {
        ctx.strokeStyle = resolveColor(attrs.color || DEFAULT_LINE_COLOR);
        ctx.lineWidth = (attrs.width || DEFAULT_LINE_WIDTH) / scale;
    }

    // Â¶ÇÊûúÈúÄË¶ÅÊòæÁ§∫Èù¢ÁßØÔºåÂÖàÁªòÂà∂Âá∏ÂåÖÂ°´ÂÖÖ
    if (shouldFillArea) {
        ctx.beginPath();
        if (props.convex.length > 0) {
            ctx.moveTo(props.convex[0][0] * UNIT_SIZE, props.convex[0][1] * UNIT_SIZE);
            for (let i = 1; i < props.convex.length; i++) {
                ctx.lineTo(props.convex[i][0] * UNIT_SIZE, props.convex[i][1] * UNIT_SIZE);
            }
            ctx.closePath();
            ctx.fillStyle = 'rgba(255, 182, 193, 0.3)'; // Ê∑°Á≤âÁ∫¢Ëâ≤Â°´ÂÖÖÔºå30%ÈÄèÊòéÂ∫¶
            ctx.fill();
        }
    }

    ctx.beginPath();

    // ÂéüÁîüË¥ùÂ°ûÂ∞îÊñπÊ≥ïÔºà‰ªÖÊîØÊåÅ‰∏âÊ¨°Ôºå4‰∏™ÊéßÂà∂ÁÇπË¥ùÂ°ûÂ∞îÊõ≤Á∫øÔºå‰ΩÜÁ°¨‰ª∂Âä†ÈÄüÔºåÊÄßËÉΩÊúÄ‰ºòÔºåGPUÊ∏≤ÊüìÔºâ
    if (props.controls && props.controls.length === 4) {
        const [start, cp1, cp2, end] = props.controls;
        ctx.moveTo(start[0] * UNIT_SIZE, start[1] * UNIT_SIZE);
        ctx.bezierCurveTo(
            cp1[0] * UNIT_SIZE, cp1[1] * UNIT_SIZE,
            cp2[0] * UNIT_SIZE, cp2[1] * UNIT_SIZE,
            end[0] * UNIT_SIZE, end[1] * UNIT_SIZE
        );
    }
    // ‰ΩøÁî®È¢ÑËÆ°ÁÆóÁöÑÁºìÂ≠òÁÇπÁªòÂà∂Ë¥ùÂ°ûÂ∞îÊõ≤Á∫ø
    else {
        ctx.moveTo(props.points[0][0] * UNIT_SIZE, props.points[0][1] * UNIT_SIZE);
        for (let i = 1; i < props.points.length; i++) {
            ctx.lineTo(props.points[i][0] * UNIT_SIZE, props.points[i][1] * UNIT_SIZE);
        }
    }
    ctx.stroke();
    ctx.restore();
}
function drawFunction(props, attrs) {
    const isHighlight = arguments[2] === true;
    ctx.save();
    if (isHighlight) {
        ctx.shadowColor = HIGHLIGHT_COLOR;
        ctx.shadowBlur = HIGHLIGHT_SHADOW_BLUR * scale;
        ctx.strokeStyle = HIGHLIGHT_COLOR;
        ctx.lineWidth = HIGHLIGHT_LINE_WIDTH_MIN / scale;
    } else {
        ctx.strokeStyle = attrs.color || DEFAULT_LINE_COLOR;
        ctx.lineWidth = (attrs.width || DEFAULT_LINE_WIDTH) / scale;
    }
    ctx.beginPath();
    for (const points of props.points) {
        let once = true;
        for (const point of points) {
            const x = point[0] * UNIT_SIZE;
            const y = point[1] * UNIT_SIZE;
            if (once) { once = false;
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        }
    }
    ctx.stroke();
    ctx.restore();
}

// ÁªòÂà∂Ë∑üË∏™ÁÇπÂáΩÊï∞
function drawTrackingPoint() {
    console.assert(selectedElement && projectingPoint);

    // Ëé∑ÂèñÈÄâ‰∏≠ÂÖÉÁ¥†ÁöÑÈ¢úËâ≤ÔºåÁî®‰∫éË∑üË∏™ÁÇπÂíåÊñáÊú¨Ôºà‰ΩøÁî®‰∏éÁ∫øÊù°Áõ∏ÂêåÁöÑÈ¢úËâ≤ÈÄªËæëÔºâ
    const elementColor = resolveColor(selectedElement.attrs.color || DEFAULT_LINE_COLOR);

    // Âú®Êï∞Â≠¶ÂùêÊ†áÁ≥ª‰∏≠ÁªòÂà∂Ë∑üË∏™ÁÇπ
    ctx.save();

    // Â¶ÇÊûúÊåâ‰∏ãAÊàñSÈîÆ‰∏îÊúâÂàáÁ∫ø‰ø°ÊÅØÔºåÁªòÂà∂ÂàáÁ∫øÊàñÊ≥ïÁ∫øÔºà‰∏çÈúÄË¶ÅCommandÈîÆÂêåÊó∂Êåâ‰∏ãÔºâ
    // Âè™Âú®ÁâπÂæÅ tab ‰∏ãÁªòÂà∂ÂàáÁ∫ø/Ê≥ïÁ∫ø
    if ((isKeyAPressed || isKeySPressed) &&
        (!uiPropertyPanelShown || uiPropertyCurrentTab === 'props') &&
        projectionTangent !== null && projectionTangent !== undefined && !isNaN(projectionTangent)) {
        
        const slope = projectionTangent;

        // ‰ΩøÁî®ÁÆÄÂåñÁöÑÊñπÊ≥ïÔºöËÆ°ÁÆó‰∏Ä‰∏™Ë∂≥Â§üÈïøÁöÑÁ∫ø
        const screenSize = Math.max(canvas.width, canvas.height);
        const lineLength = screenSize / (scale * UNIT_SIZE) * 2; // Á°Æ‰øùË∂≥Â§üÈïø

        // ÁªòÂà∂ÂàáÁ∫øÔºàCommand+AÔºâ
        if (isKeyAPressed) {
            ctx.strokeStyle = '#ff6b35'; // Ê©ôËâ≤ÂàáÁ∫ø
            ctx.lineWidth = 2 / scale;
            ctx.setLineDash([5 / scale, 5 / scale]); // ËôöÁ∫ø

            let x1, y1, x2, y2;

            if (Math.abs(slope) < 100) { // ÈùûÂûÇÁõ¥Á∫ø
                // ‰ΩøÁî®ÊñúÁéáËÆ°ÁÆóÂàáÁ∫øÁ´ØÁÇπ
                const dx = lineLength / Math.sqrt(1 + slope * slope);
                const dy = slope * dx;

                x1 = projectingPoint[0] - dx;
                y1 = projectingPoint[1] - dy;
                x2 = projectingPoint[0] + dx;
                y2 = projectingPoint[1] + dy;
            } else {
                // ÂûÇÁõ¥ÊàñÊé•ËøëÂûÇÁõ¥ÁöÑÁ∫ø
                x1 = projectingPoint[0];
                y1 = projectingPoint[1] - lineLength;
                x2 = projectingPoint[0];
                y2 = projectingPoint[1] + lineLength;
            }

            ctx.beginPath();
            ctx.moveTo(x1 * UNIT_SIZE, y1 * UNIT_SIZE);
            ctx.lineTo(x2 * UNIT_SIZE, y2 * UNIT_SIZE);
            ctx.stroke();
            ctx.setLineDash([]); // ÈáçÁΩÆËôöÁ∫ø
        }

        // ÁªòÂà∂Ê≥ïÁ∫øÔºàCommand+SÔºâ
        if (isKeySPressed) {
            ctx.strokeStyle = '#007bff'; // ËìùËâ≤Ê≥ïÁ∫øÔºå‰∏éÊ©ôËâ≤ÂàáÁ∫øÂΩ¢Êàê‰∫íË°•Ëâ≤ÂØπÊØî
            ctx.lineWidth = 1.5 / scale;
            ctx.setLineDash([3 / scale, 3 / scale]); // Áü≠ËôöÁ∫ø

            let normalX1, normalY1, normalX2, normalY2;

            if (Math.abs(slope) > 100) {
                // Â¶ÇÊûúÂàáÁ∫øÊé•ËøëÂûÇÁõ¥ÔºåÊ≥ïÁ∫øÊòØÊ∞¥Âπ≥ÁöÑ
                normalX1 = projectingPoint[0] - lineLength;
                normalY1 = projectingPoint[1];
                normalX2 = projectingPoint[0] + lineLength;
                normalY2 = projectingPoint[1];
            } else {
                // Ê≥ïÁ∫øÊñúÁéá = -1/ÂàáÁ∫øÊñúÁéá
                const normalSlope = slope === 0 ? 1000000 : -1 / slope;
                let ndx, ndy;

                if (Math.abs(normalSlope) < 100) {
                    ndx = lineLength / Math.sqrt(1 + normalSlope * normalSlope);
                    ndy = normalSlope * ndx;
                } else {
                    ndx = 0;
                    ndy = lineLength;
                }

                normalX1 = projectingPoint[0] - ndx;
                normalY1 = projectingPoint[1] - ndy;
                normalX2 = projectingPoint[0] + ndx;
                normalY2 = projectingPoint[1] + ndy;
            }

            ctx.beginPath();
            ctx.moveTo(normalX1 * UNIT_SIZE, normalY1 * UNIT_SIZE);
            ctx.lineTo(normalX2 * UNIT_SIZE, normalY2 * UNIT_SIZE);
            ctx.stroke();
            ctx.setLineDash([]); // ÈáçÁΩÆËôöÁ∫ø
        }
    }

    // Á°ÆÂÆöË∑üË∏™ÁÇπÈ¢úËâ≤Ôºö‰∏çÂèØÂØºÊó∂‰∏∫Á∫¢Ëâ≤ÔºåÂê¶Âàô‰∏∫ÂÖÉÁ¥†È¢úËâ≤
    let pointColor = elementColor;
    if ((isKeyAPressed || isKeySPressed) && isNaN(projectionTangent)) {
        pointColor = '#ff0000'; // Á∫¢Ëâ≤Ë°®Á§∫‰∏çÂèØÂØº
    }

    // ÁªòÂà∂ÊäïÂΩ±Ë∑üË∏™ÁÇπÔºà‰∏éÁ∫øÊù°ÂêåËâ≤ÔºåÂ∏¶ÂæÆÂ∞èËæπÊ°ÜÈÅøÂÖç‰∏éÁ∫øÊ∑∑Ê∑ÜÔºâ
    ctx.fillStyle = pointColor;
    // ËæπÊ°ÜÈ¢úËâ≤‰∏é‰∏ªÈ¢òËÉåÊôØ‰∏ÄËá¥ÔºöÁôΩÂ§©ÁôΩËæπÔºåÈªëÂ§úÈªëËæπ
    ctx.strokeStyle = THEME ? '#000000' : '#ffffff';
    ctx.lineWidth = 2 / scale; // Á®çÂæÆÊòéÊòæÁöÑËæπÊ°ÜÔºåÈÅøÂÖç‰∏éÁ∫øÊó†Ê≥ïÂå∫ÂàÜ

    ctx.beginPath();
    ctx.arc(projectingPoint[0] * UNIT_SIZE, projectingPoint[1] * UNIT_SIZE, 3 / scale, 0, PI2);
    ctx.fill();
    ctx.stroke();

    ctx.restore();

    // ÁªòÂà∂ÂùêÊ†áÊñáÊú¨ÔºàÂú®Â±èÂπïÂùêÊ†áÁ≥ª‰∏≠Ôºâ
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0); // ÈáçÁΩÆÂèòÊç¢Âà∞Â±èÂπïÂùêÊ†áÁ≥ª

    // Â∞ÜÊï∞Â≠¶ÂùêÊ†áËΩ¨Êç¢‰∏∫Â±èÂπïÂùêÊ†á
    const [screenX, screenY] = mathToScreen(projectingPoint[0], projectingPoint[1]);

    // Ê†ºÂºèÂåñÂùêÊ†áÊòæÁ§∫
    const xStr = projectingPoint[0].toFixed(2);
    const yStr = projectingPoint[1].toFixed(2);
    let coordsText = `(${xStr}, ${yStr})`;

    // Ê∑ªÂä†ÂàáÁ∫øÂíåÊ≥ïÁ∫ø‰ø°ÊÅØ
    if ((isKeyAPressed || isKeySPressed || isShiftPressed) && projectionTangent !== null) {
        if (projectionTangent !== undefined && !isNaN(projectionTangent)) {
            // ÂèØÂØºÔºåÊòæÁ§∫ÊñúÁéá‰ø°ÊÅØ
            const slope = projectionTangent;
            const slopeStr = isFinite(slope) ? slope.toFixed(3) : '‚àû';

            // Âà§Êñ≠ÊòØÂê¶‰ΩøÁî®Êï∞ÂÄºÂæÆÂàÜÔºàÊéíÈô§ÂèØËß£ÊûêÊ±ÇÂØºÁöÑÊõ≤Á∫øÔºâ
            const usesAnalyticalDiff = selectedElement && (
                selectedElement.type === ElementTypes.SEG ||
                selectedElement.type === ElementTypes.CIRCLE ||
                selectedElement.type === ElementTypes.ARC ||
                selectedElement.type === ElementTypes.POLYGON ||
                selectedElement.type === ElementTypes.RECTANGLE
            );
            const usesNumericalDiff = !usesAnalyticalDiff;
            const approxSymbol = usesNumericalDiff ? '‚âà' : ':';

            // ÊòæÁ§∫ÂàáÁ∫ø‰ø°ÊÅØÔºàAÈîÆÔºâ
            if (isKeyAPressed) {
                coordsText += ` | ${LangText.TANGENT_SLOPE[LANG]}${approxSymbol} ${slopeStr}`;
            }

            // ÊòæÁ§∫Ê≥ïÁ∫ø‰ø°ÊÅØÔºàSÈîÆÊàñAltÈîÆÔºâ
            if (isKeySPressed || isShiftPressed) {
                if (!isFinite(slope)) {
                    coordsText += ` | ${LangText.NORMAL_SLOPE[LANG]}${approxSymbol} 0`;
                } else if (slope === 0) {
                    coordsText += ` | ${LangText.NORMAL_SLOPE[LANG]}${approxSymbol} ‚àû`;
                } else {
                    const normalSlope = -1 / slope;
                    const normalSlopeStr = isFinite(normalSlope) ? normalSlope.toFixed(3) : '‚àû';
                    coordsText += ` | ${LangText.NORMAL_SLOPE[LANG]}${approxSymbol} ${normalSlopeStr}`;
                }
            }
        } else if (projectionTangent === undefined) { // ÁÇπÊó†Êïà
            coordsText += ` | ${LangText.INVALID_POINT[LANG]}`;
        } else if (isNaN(projectionTangent)) { // ‰∏çÂèØÂØº
            coordsText += ` | ${LangText.NON_DIFFERENTIABLE[LANG]}`;
        }
    }

    // ËÆæÁΩÆÊñáÊú¨Ê†∑Âºè
    ctx.font = '12px Arial';
    // Á°ÆÂÆöÊñáÊú¨È¢úËâ≤
    let textColor = elementColor;
    if ((isKeyAPressed || isKeySPressed || isShiftPressed) && projectionTangent === undefined) {
        textColor = '#999999'; // ÁÅ∞Ëâ≤Ë°®Á§∫ÁÇπÊó†Êïà
    } else if ((isKeyAPressed || isKeySPressed || isShiftPressed) && isNaN(projectionTangent)) {
        textColor = '#ff0000'; // Á∫¢Ëâ≤Ë°®Á§∫‰∏çÂèØÂØº
    } else if ((isKeyAPressed && isKeySPressed) && projectionTangent !== null && projectionTangent !== undefined && !isNaN(projectionTangent)) {
        // ÂêåÊó∂Êåâ‰∏ãAÂíåSÔºå‰ΩøÁî®Ê∑∑ÂêàÊèêÁ§∫Ëâ≤Êàñ‰øùÊåÅÂÖÉÁ¥†Ëâ≤
        textColor = elementColor;
    } else if (isKeyAPressed && projectionTangent !== null && projectionTangent !== undefined && !isNaN(projectionTangent)) {
        textColor = '#ff6b35'; // ÊòæÁ§∫ÂàáÁ∫øÊó∂‰ΩøÁî®Ê©ôËâ≤
    } else if ((isKeySPressed || isShiftPressed) && projectionTangent !== null && projectionTangent !== undefined && !isNaN(projectionTangent)) {
        textColor = '#007bff'; // ÊòæÁ§∫Ê≥ïÁ∫øÊó∂‰ΩøÁî®ËìùËâ≤
    }
    ctx.fillStyle = textColor;
    // ÊñáÊú¨ËæπÊ°ÜÈ¢úËâ≤‰∏é‰∏ªÈ¢òËÉåÊôØ‰∏ÄËá¥ÔºöÁôΩÂ§©ÁôΩËæπÔºåÈªëÂ§úÈªëËæπ
    ctx.strokeStyle = THEME ? '#000000' : '#ffffff';
    ctx.lineWidth = 2; // Á®çÁªÜ‰∏Ä‰∫õÁöÑÊñáÊú¨ËæπÊ°Ü

    // ËÆ°ÁÆóÊñáÊú¨‰ΩçÁΩÆÔºàÈÅøÂÖçË∂ÖÂá∫Â±èÂπïÔºâ
    const textWidth = ctx.measureText(coordsText).width;
    let textX = screenX + 10;
    let textY = screenY - 10;

    if (textX + textWidth > canvas.width) {
        textX = screenX - textWidth - 10;
    }
    if (textY < 16) {
        textY = screenY + 25;
    }

    // ÁªòÂà∂ÊñáÊú¨ÊèèËæπÂíåÂ°´ÂÖÖ
    ctx.strokeText(coordsText, textX, textY);
    ctx.fillText(coordsText, textX, textY);

    ctx.restore();
}

// ÁªòÂà∂ÁâπÂæÅÁÇπ
function drawFeaturePoints() {
    console.assert(selectedElement);

    ctx.save();

    // ÂáΩÊï∞ÂÖÉÁ¥†ÂíåÁÇπÂÖÉÁ¥†‰∏çÁªòÂà∂Âá†‰Ωï‰∏≠ÂøÉÂíåÂ§ñÊé•Áü©ÂΩ¢
    if (selectedElement.type === ElementTypes.FUNCTION || selectedElement.type === ElementTypes.POINT) {
        ctx.restore();
        return;
    }

    // ÁªòÂà∂Âá†‰Ωï‰∏≠ÂøÉÁÇπÔºàË¥®ÂøÉÔºâÔºåÂÖàÁªòÂà∂ÔºåÂú®‰∏ãÂ±ÇÔºå
    const centroid = selectedElement.props.centroid;
    if (centroid) {
        ctx.save();
        const rectSize = 8 / scale;     // ÊñπÂùóÂ§ßÂ∞è
        ctx.lineWidth = 1 / scale;      // Á≤æÁªÜËæπÊ°ÜÔºå1ÂÉèÁ¥†ÂÆΩÂ∫¶
        ctx.fillStyle = '#ffd700';
        // ËæπÊ°ÜÈ¢úËâ≤‰∏é‰∏ªÈ¢òËÉåÊôØ‰∏ÄËá¥ÔºöÁôΩÂ§©ÁôΩËæπÔºåÈªëÂ§úÈªëËæπ
        ctx.strokeStyle = THEME ? '#000000' : '#ffffff';
        ctx.fillRect(centroid[0] * UNIT_SIZE - rectSize/2, centroid[1] * UNIT_SIZE - rectSize/2, rectSize, rectSize);
        ctx.strokeRect(centroid[0] * UNIT_SIZE - rectSize/2, centroid[1] * UNIT_SIZE - rectSize/2, rectSize, rectSize);
        ctx.restore();
    }

    // ËÆ°ÁÆóÂπ∂ÁªòÂà∂Â§ñÊé•Áü©ÂΩ¢‰∏≠ÂøÉÁÇπ
    const box = selectedElement.props.box;
    if (box) {
        ctx.save();
        const pointSize = 4 / scale;    // ÂéüÁÇπÂ§ßÂ∞è
        ctx.lineWidth = 1 / scale;
        ctx.fillStyle = '#ff4444';
        // ËæπÊ°ÜÈ¢úËâ≤‰∏é‰∏ªÈ¢òËÉåÊôØ‰∏ÄËá¥ÔºöÁôΩÂ§©ÁôΩËæπÔºåÈªëÂ§úÈªëËæπ
        ctx.strokeStyle = THEME ? '#000000' : '#ffffff';
        ctx.beginPath();
        ctx.arc(box[0] * UNIT_SIZE, box[1] * UNIT_SIZE, pointSize/2, 0, PI2);
        ctx.fill();
        ctx.stroke();
        ctx.restore();
    }

    // ÁªòÂà∂Â§ñÊé•Áü©ÂΩ¢ÔºàÂ¶ÇÊûúÂ§çÈÄâÊ°ÜË¢´ÈÄâ‰∏≠Ôºâ
    const showBoundingRectCheckbox = document.getElementById('showBoundingRect');
    if (showBoundingRectCheckbox && showBoundingRectCheckbox.checked && box) {
        ctx.save();
        ctx.strokeStyle = '#888888';
        ctx.lineWidth = 1 / scale;
        ctx.setLineDash([4 / scale, 4 / scale]); // ËôöÁ∫øÊ†∑Âºè
        ctx.globalAlpha = 0.6; // Âº±ÊòæÁ§∫

        ctx.strokeRect(
            box[2] * UNIT_SIZE, // left
            box[5] * UNIT_SIZE, // bottom
            (box[4] - box[2]) * UNIT_SIZE,  // width
            (box[3] - box[5]) * UNIT_SIZE   // height
        );

        ctx.restore();
    }

    // ÁªòÂà∂ÂÖÉÁ¥†ÁöÑÁâπÂæÅÁÇπ
    if (selectedElement.props.ft) {

        selectedElement.props.ft.forEach(point => {
            ctx.save();
            // Ê†πÊçÆÁâπÂæÅÁÇπÁ±ªÂûãÁ°ÆÂÆöÈ¢úËâ≤
            const featureType = point.length > 2 ? point[2] : null;

            ctx.fillStyle = (featureType !== null && FeatureColors[featureType]) ? FeatureColors[featureType] : '#4444ff';
            // ËæπÊ°ÜÈ¢úËâ≤‰∏é‰∏ªÈ¢òËÉåÊôØ‰∏ÄËá¥ÔºöÁôΩÂ§©ÁôΩËæπÔºåÈªëÂ§úÈªëËæπ
            ctx.strokeStyle = THEME ? '#000000' : '#ffffff';
            ctx.lineWidth = 1 / scale;
            const pointSize = 4 / scale; // ÁâπÂæÅÁÇπÊØî‰∏≠ÂøÉÁÇπÂ∞è‰∏Ä‰∫õ

            // ÁªòÂà∂ÂúÜÂΩ¢ÁâπÂæÅÁÇπ
            ctx.beginPath();
            ctx.arc(point[0] * UNIT_SIZE, point[1] * UNIT_SIZE, pointSize/2, 0, PI2);
            ctx.fill();
            ctx.stroke();
            ctx.restore();
        });
    }

    // ÊÅ¢Â§çÂùêÊ†áÁ≥ªÂèòÊç¢
    ctx.restore();
}

// ÁªòÂà∂ËßÇÊµãÁÇπ
function drawObservePoints() {
    console.assert(selectedElement && observingPoint);

    ctx.save();

    // ÁªòÂà∂ËßÇÊµãÁÇπÔºàÂúÜÂΩ¢ÔºåÂ∏¶Èò¥ÂΩ±ÁöÑ‰∫§‰∫íÊÑüÔºâ
    const pointRadius = 4 / scale;  // ÁÇπÂçäÂæÑÈúÄË¶ÅÊ†πÊçÆÁº©ÊîæË∞ÉÊï¥
    const shadowBlur = 2 / scale;   // Èò¥ÂΩ±Ê®°Á≥äÂçäÂæÑ

    // ËÆæÁΩÆÈò¥ÂΩ±ÊïàÊûú
    ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
    ctx.shadowBlur = shadowBlur;
    ctx.shadowOffsetX = 1 / scale;
    ctx.shadowOffsetY = 1 / scale;

    // Ê†πÊçÆÊòØÂê¶Âú®ÂÜÖÈÉ®ÈÄâÊã©È¢úËâ≤ÔºöÂÜÖÈÉ®ËìùËâ≤ÔºåÂ§ñÈÉ®Á∫¢Ëâ≤
    ctx.fillStyle = observingPoint[2] <= 0 ? '#3498db' : '#e74c3c';
    // ËæπÊ°ÜÈ¢úËâ≤‰∏é‰∏ªÈ¢òËÉåÊôØ‰∏ÄËá¥ÔºöÁôΩÂ§©ÁôΩËæπÔºåÈªëÂ§úÈªëËæπ
    ctx.strokeStyle = THEME ? '#000000' : '#ffffff';
    ctx.lineWidth = 1 / scale; // Á≤æÁªÜËæπÊ°Ü

    ctx.beginPath();
    ctx.arc(
        observingPoint[0] * UNIT_SIZE,
        observingPoint[1] * UNIT_SIZE,
        pointRadius,
        0,
        2 * Math.PI
    );
    ctx.fill();
    ctx.stroke();

    ctx.restore();
}

// ÁªòÂà∂ËßÇÊµãÊñπÂêëËæÖÂä©Á∫ø
function drawObserveDirectionGuideLine() {
    console.assert(selectedElement && observingPoint && activeTransform && observingRelevant);

    const transform = selectedElement.transform;

    // Ê†πÊçÆÂΩìÂâç tab Ëé∑ÂèñËßÇÊµãËßíÂ∫¶
    let currentAngle = 0;
    if (activeTransform === TRANSFORM.FLIP) {
        currentAngle = getObserveDirection(transform.flip) * D2R;
    } else if (activeTransform === TRANSFORM.SHEAR) {
        currentAngle = getObserveDirection(transform.shear) * D2R;
    } else return;

    // ÁªòÂà∂Êó†ÈôêÈïøÁöÑËæÖÂä©Áõ¥Á∫ø
    ctx.save();

    // ËÆæÁΩÆËæÖÂä©Á∫øÊ†∑Âºè - Ê†πÊçÆCommandÈîÆÁä∂ÊÄÅË∞ÉÊï¥Ê†∑Âºè
    if (isAltPressed) {
        // CommandÈîÆÊåâ‰∏ãÔºö‰∫§‰∫íÁä∂ÊÄÅÔºåÊõ¥‰∫ÆÊõ¥ÊòéÊòæ
        ctx.strokeStyle = '#3498db';                // ËìùËâ≤
        ctx.lineWidth = 2 / scale;                  // Á®çÁ≤ó‰∏Ä‰∫õ
        ctx.setLineDash([8 / scale, 4 / scale]);    // ËôöÁ∫ø
        ctx.globalAlpha = 0.8;                      // ËæÉÈ´òÈÄèÊòéÂ∫¶
    } else {
        // ÈªòËÆ§Áä∂ÊÄÅÔºöËæÉÊ∑°ÔºåÊòæÁ§∫ÂΩìÂâçËÆæÁΩÆ
        ctx.strokeStyle = '#3498db';                // ÂêåÊ†∑ÁöÑËìùËâ≤
        ctx.lineWidth = 1 / scale;                  // ÁªÜÁ∫ø
        ctx.setLineDash([6 / scale, 6 / scale]);    // Êõ¥ÁªÜÁöÑËôöÁ∫ø
        ctx.globalAlpha = 0.5;                      // ËæÉ‰ΩéÈÄèÊòéÂ∫¶
    }

    // CommandÈîÆ Êåâ‰∏ãÊó∂ÔºåËßÜÁ∫øË∑üÈöèÈº†Ê†áÔºåÂç≥‰ΩøÁî®Èº†Ê†á‰ΩçÁΩÆËÆ°ÁÆóËßÇÊµãËßÜÁ∫øÁöÑÊñπÂêëËßí
    if (isAltPressed && mouseMath) {

        // ËÆ°ÁÆóËßÇÊµãÁÇπÂà∞Èº†Ê†áÁöÑÂêëÈáè
        const [dx, dy] = v2Sub(mouseScreenX, mouseScreenY, observingPointInScreen[0], observingPointInScreen[1]);
        // ÈÅøÂÖçÈõ∂ÂêëÈáè
        if (Math.abs(dx) > 0.1 || Math.abs(dy) > 0.1) {

            // Âú®ÁîªÂ∏ÉÂùêÊ†áÁ≥ª‰∏≠ËÆ°ÁÆóËßíÂ∫¶ÔºåÊ≥®ÊÑèYËΩ¥ÊñπÂêë
            let mouseAngle = Math.atan2(-dy, dx) * R2D; // Ë¥üdyÂõ†‰∏∫ÁîªÂ∏ÉYËΩ¥Âêë‰∏ã

            // Ê†πÊçÆÂ±ÄÂüüÂØπÁß∞ÊÄßÔºåÂØπÊñπÂêëËøõË°åÈôêÂà∂
            if (constrainObserveDirLocalSymmetry) {
                mouseAngle = observeDirectionConstrain(mouseAngle);
            }

            currentAngle = mouseAngle * D2R; // Êç¢ÁÆóÂõûÂºßÂ∫¶
        }
    }

    // Áé∞Âú®Âú®Áªü‰∏ÄÁöÑÊï∞Â≠¶ÂùêÊ†áÁ≥ª‰∏≠Ôºå‰ΩøÁî® UNIT_SIZE Áº©ÊîæÂùêÊ†á
    const lineLength = Math.max(canvas.width, canvas.height) / (UNIT_SIZE * scale);
    const cos = Math.cos(currentAngle);
    const sin = Math.sin(currentAngle);

    // ËæÖÂä©Á∫øÁöÑËµ∑ÁÇπÂíåÁªàÁÇπÔºå‰ª•ËßÇÊµãÁÇπ‰∏∫‰∏≠ÂøÉÔºå‰ΩøÁî® UNIT_SIZE Áº©Êîæ
    const x1 = (observingPoint[0] - lineLength * cos) * UNIT_SIZE;
    const y1 = (observingPoint[1] - lineLength * sin) * UNIT_SIZE;
    const x2 = (observingPoint[0] + lineLength * cos) * UNIT_SIZE;
    const y2 = (observingPoint[1] + lineLength * sin) * UNIT_SIZE;

    // ÁªòÂà∂‰∏ªËæÖÂä©Á∫øÔºàËßÇÊµãÁÇπÂà∞Èº†Ê†áÊàñÂΩìÂâçËßíÂ∫¶Ôºâ
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();

    // CommandÈîÆ Êåâ‰∏ãÊó∂ÔºåÂ¶ÇÊûúÊúâ observingRelevant ËåÉÂõ¥ÔºåÁªòÂà∂ËåÉÂõ¥ËæπÁïåËæÖÂä©Á∫ø
    if (isAltPressed && observingRelevant !== null) {
        const angle1Rad = observingRelevant[0] * D2R;
        const angle2Rad = observingRelevant[1] * D2R;

        // ËÆæÁΩÆËåÉÂõ¥ËæπÁïåÁ∫øÊ†∑ÂºèÔºàÁÅ∞Ëâ≤ÔºåÂº±ÂåñÔºâ
        ctx.strokeStyle = '#999999'; // ÁÅ∞Ëâ≤
        ctx.lineWidth = 1 / scale;
        ctx.setLineDash([4 / scale, 4 / scale]); // Áü≠ËôöÁ∫ø
        ctx.globalAlpha = 0.4; // ËæÉ‰ΩéÈÄèÊòéÂ∫¶ÔºåÂº±ÂåñÊòæÁ§∫

        // ÁªòÂà∂Á¨¨‰∏ÄÊù°ËåÉÂõ¥ËæπÁïåÁ∫ø
        const cos1 = Math.cos(angle1Rad);
        const sin1 = Math.sin(angle1Rad);
        const x1_bound1 = (observingPoint[0] - lineLength * cos1) * UNIT_SIZE;
        const y1_bound1 = (observingPoint[1] - lineLength * sin1) * UNIT_SIZE;
        const x2_bound1 = (observingPoint[0] + lineLength * cos1) * UNIT_SIZE;
        const y2_bound1 = (observingPoint[1] + lineLength * sin1) * UNIT_SIZE;

        ctx.beginPath();
        ctx.moveTo(x1_bound1, y1_bound1);
        ctx.lineTo(x2_bound1, y2_bound1);
        ctx.stroke();

        // ÁªòÂà∂Á¨¨‰∫åÊù°ËåÉÂõ¥ËæπÁïåÁ∫ø
        const cos2 = Math.cos(angle2Rad);
        const sin2 = Math.sin(angle2Rad);
        const x1_bound2 = (observingPoint[0] - lineLength * cos2) * UNIT_SIZE;
        const y1_bound2 = (observingPoint[1] - lineLength * sin2) * UNIT_SIZE;
        const x2_bound2 = (observingPoint[0] + lineLength * cos2) * UNIT_SIZE;
        const y2_bound2 = (observingPoint[1] + lineLength * sin2) * UNIT_SIZE;

        ctx.beginPath();
        ctx.moveTo(x1_bound2, y1_bound2);
        ctx.lineTo(x2_bound2, y2_bound2);
        ctx.stroke();
    }

    ctx.restore();
}

/* ================================ */
/* ÂÖÉÁ¥†ÂÆö‰πâ‰∏éÁÆ°ÁêÜ */
/* ================================ */

// ÁªòÂà∂ÂÖÉÁ¥†ÁÆ°ÁêÜÂáΩÊï∞
function addElement(type, props, attrs) {
    const element = Element(type, props, attrs);
    // ËÆæÁΩÆÊâÄÊúâÂèòÊç¢ÁöÑËßÇÊµãÁÇπ‰∏∫Âá†‰Ωï‰∏≠ÂøÉ
    let center;
    if (element.props.centroid) {
        center = element.props.centroid;
    } else if (element.props.coords) {
        center = element.props.coords;
    } else if (element.type === ElementTypes.FUNCTION && element.props.range) {
        // ÂáΩÊï∞ÂÖÉÁ¥†‰ΩøÁî®ÂÆö‰πâÂüü‰∏≠ÂøÉ
        center = [(element.props.range[0] + element.props.range[1]) / 2, 0];
    } else {
        // ÈªòËÆ§‰∏≠ÂøÉ
        center = [0, 0];
    }
    element.transform.flip.observePos = [center[0], center[1]];
    element.transform.shear.observePos = [center[0], center[1]];
    element.transform.rotation.observePos = [center[0], center[1]];
    element.transform.scale.observePos = [center[0], center[1]];
    elements.push(element);
    uiUpdateElementPanel();                     // Êõ¥Êñ∞Âè≥‰æßÈù¢Êùø
    UIShowElementsPanel();                      // ÊòæÁ§∫Âè≥‰æßÈù¢Êùø
    return element;
}
function removeElement(id) {
    const index = elements.findIndex(el => el.id === id);
    if (index !== -1) {
        elements.splice(index, 1);
        uiUpdateElementPanel(); // Êõ¥Êñ∞Âè≥‰æßÈù¢Êùø
        return true;
    }
    return false;
}
function clearElements() {
    elements = [];
    elementIdBase = 0;
    uiUpdateElementPanel(); // Êõ¥Êñ∞Âè≥‰æßÈù¢Êùø
    draw(); // ÈáçÁªòÁîªÂ∏É
}

function getElementPropsText(element) {
    const props = element.props;
    switch (element.type) {
        case ElementTypes.POINT :
            return `(${props.coords[0].toFixed(1)}, ${props.coords[1].toFixed(1)})`;
        case ElementTypes.SEG:
            return `(${props.ft[0][0].toFixed(1)}, ${props.ft[0][1].toFixed(1)}) ‚Üí (${props.ft[1][0].toFixed(1)}, ${props.ft[1][1].toFixed(1)})`;
        case ElementTypes.RECTANGLE :
            return `[${props.box[2].toFixed(1)}, ${props.box[3].toFixed(1)}] - [${props.box[4].toFixed(1)}, ${props.box[5].toFixed(1)}]`;
        case ElementTypes.CIRCLE :
            return `${LangText.CENTER[LANG]}: (${props.centroid[0].toFixed(1)}, ${props.centroid[1].toFixed(1)}), ${LangText.RADIUS[LANG]}: ${props.radius.toFixed(1)}`;
        case ElementTypes.ARC :
            return `${LangText.RANGE[LANG]}: (${props.aux.deg0.toFixed(1)}¬∞, ${props.aux.deg1.toFixed(1)}¬∞), ${LangText.RADIUS[LANG]}: ${props.radius.toFixed(1)}`;
        case ElementTypes.POLYGON :
            return `${LangText.VERTEX[LANG]}: ${props.ft.length || 0} , ${LangText.CENTROID[LANG]}: (${props.centroid[0].toFixed(1)}, ${props.centroid[1].toFixed(1)})`;
        case ElementTypes.EASE :
            return `${getEaseTypeText(props.type)} ${getEaseProcText(props.proc)} (${props.ft[0][0].toFixed(1)}, ${props.ft[0][1].toFixed(1)}) ‚Üí (${props.ft[1][0].toFixed(1)}, ${props.ft[1][1].toFixed(1)})`;
        case ElementTypes.BEZIER :
            return `${getBezierTypeText(props.controls.length)} (${props.ft[0][0].toFixed(1)}, ${props.ft[0][1].toFixed(1)}) ‚Üí (${props.ft[1][0].toFixed(1)}, ${props.ft[1][1].toFixed(1)})`;
        case ElementTypes.FUNCTION :
            return `y = ${props.expr}, x ‚àà [${props.range[0]}, ${props.range[1]}]`;
        default:
            return props ? JSON.stringify(props).substring(0, 50) + '...' : LangText.UNKNOWN[LANG] + LangText.ELEMENT[LANG];
    }
}

function moveElement(element, toX, toY) {

    if (element.type === ElementTypes.FUNCTION) {
        return;
    }
    const props = element.props; let dx, dy;
    if (element.type === ElementTypes.POINT) {
        dx = toX - props.coords[0]; dy = toY - props.coords[1];
        props.coords[0] = toX; props.coords[1] = toY;
    }
    else moveLocalElement(props, dx = toX - props.box[0], dy = toY - props.box[1]);
    
    const transform = element.transform;
    transform.flip.observePos[0] += dx; transform.flip.observePos[1] += dy;
    transform.shear.observePos[0] += dx; transform.shear.observePos[1] += dy;
    transform.rotation.observePos[0] += dx; transform.rotation.observePos[1] += dy;
    transform.scale.observePos[0] += dx; transform.scale.observePos[1] += dy;
    
    uiUpdateElementPanel();

    draw();
}

// ÂÖÉÁ¥†ÂØºËà™ÂäüËÉΩ
function selectFirstElement() {
    if (elements.length > 0) {
        const e = elements[0];
        if (e !== selectedElement) {
            uiSelectElement(e);
        }
    }
}
function navigateToElement(direction) {
    if (elements.length === 0 || !direction) return;

    let i = -1;
    if (selectedElement) {
        i = elements.findIndex(el => el === selectedElement);
    }

    i += direction;
    if (direction < 0) {
        while(i < 0) i += elements.length;
    } else {
        while(i >= elements.length) i -= elements.length;
    }

    // Ê≥®ÔºåÂΩì direction Ê≠£Â•ΩÂõûÂà∞ÂéüÂÖÉÁ¥†Êó∂Ôºå‰∏çË¶ÅËß¶ÂèëÈáçÊñ∞ÈÄâÊã©ÔºåÂê¶ÂàôÂ∞±ÂèòÊàê toggle ‰∫Ü
    const e = elements[i];
    if (e !== selectedElement) {
        uiSelectElement(e);
    }
}

// Âú®Èº†Ê†á‰ΩçÁΩÆËΩÆËØ¢ÈÄâÊã©ÈáçÂè†ÁöÑÂÖÉÁ¥†
function cycleUnderElement(mathX, mathY, isDoubleClick) {
// mathX, mathY: Êï∞Â≠¶ÂùêÊ†á
// isDoubleClick: ÊòØÂê¶‰∏∫ÂèåÂáª
// ËøîÂõûÂÄº: ÈÄâ‰∏≠ÁöÑÂÖÉÁ¥†ÔºåÂ¶ÇÊûúÊ≤°ÊúâÂàôËøîÂõû null

    // Êî∂ÈõÜÊâÄÊúâÂú®ÁÇπÂáª‰ΩçÁΩÆÁöÑÂÖÉÁ¥†Ôºà‰ªéÂêéÂæÄÂâçÔºåÂç≥‰ªé‰∏äÂ±ÇÂà∞‰∏ãÂ±ÇÔºâ
    const elementsAtPosition = [];
    for (let i = elements.length - 1; i >= 0; i--) {
        const element = elements[i];
        if (!element.visible) continue;
        
        // Â∫îÁî®ÂèòÊç¢ÂêéÁöÑÂÖÉÁ¥†
        const transformedElement = applyTransformToElement(element);
        
        // ËÆ°ÁÆóÂåÖÂõ¥Áõí
        let box = null;
        const props = transformedElement.props;
        
        switch (transformedElement.type) {
            case ElementTypes.POINT:
                // ÁÇπÁöÑÂåÖÂõ¥ÁõíÔºö‰ª•ÁÇπ‰∏∫‰∏≠ÂøÉÁöÑÂ∞èÊ≠£ÊñπÂΩ¢
                const pointRadius = 0.2; // ÁÇπÂáªÂÆπÂ∑Æ
                box = [props.coords[0], props.coords[1], 
                       props.coords[0] - pointRadius, props.coords[1] + pointRadius,
                       props.coords[0] + pointRadius, props.coords[1] - pointRadius];
                break;
            case ElementTypes.SEG:
                box = boxOfSeg(props.ft[0], props.ft[1]);
                // Êâ©Â±ïÁ∫øÊÆµÂåÖÂõ¥Áõí‰ª•Â¢ûÂä†ÁÇπÂáªÂÆπÂ∑Æ
                const segTolerance = 0.2;
                box[2] -= segTolerance;
                box[3] += segTolerance;
                box[4] += segTolerance;
                box[5] -= segTolerance;
                break;
            case ElementTypes.RECTANGLE:
                box = props.box;
                break;
            case ElementTypes.CIRCLE:
                box = boxOfCircle(props.centroid, props.radius);
                break;
            case ElementTypes.ARC:
                box = boxOfArc(props.ft[0], props.radius, props.startRad, props.endRad);
                break;
            case ElementTypes.POLYGON:
                box = boxOfPolygon(props.ft);
                break;
            case ElementTypes.EASE:
                box = props.box;
                break;
            case ElementTypes.BEZIER:
                box = props.box;
                break;
            case ElementTypes.FUNCTION:
                // ÂáΩÊï∞Êõ≤Á∫ø‰ΩøÁî®ÂÖ∂ÁÇπÈõÜËÆ°ÁÆóÂåÖÂõ¥Áõí
                if (props.points && props.points.length > 0) {
                    box = boxOfPolygon(props.points);
                }
                break;
        }
        
        // Ê£ÄÊµãÈº†Ê†áÊòØÂê¶Âú®ÂåÖÂõ¥ÁõíÂÜÖ
        if (box && mathX >= box[2] && mathX <= box[4] && mathY >= box[5] && mathY <= box[3]) {
            elementsAtPosition.push(element);
        }
    }
    
    // ÈÄâÊã©ÂÖÉÁ¥†
    let elementToSelect = null;
    
    if (elementsAtPosition.length > 0) {
        if (isDoubleClick && selectedElement && elementsAtPosition.includes(selectedElement)) {
            // ÂèåÂáª‰∏îÂΩìÂâçÈÄâ‰∏≠ÁöÑÂÖÉÁ¥†Âú®ÁÇπÂáª‰ΩçÁΩÆÔºöÈÄâÊã©‰∏ã‰∏Ä‰∏™ÈáçÂè†ÁöÑÂÖÉÁ¥†
            const currentIndex = elementsAtPosition.indexOf(selectedElement);
            const nextIndex = (currentIndex + 1) % elementsAtPosition.length;
            elementToSelect = elementsAtPosition[nextIndex];
        } else if (selectedElement && elementsAtPosition.includes(selectedElement)) {
            // ÂçïÂáª‰∏îÂΩìÂâçÈÄâ‰∏≠ÁöÑÂÖÉÁ¥†Âú®ÁÇπÂáª‰ΩçÁΩÆÔºö‰øùÊåÅÂΩìÂâçÈÄâÊã©
            elementToSelect = selectedElement;
        } else {
            // ÂçïÂáª‰∏îÂΩìÂâçÊ≤°ÊúâÈÄâ‰∏≠ÂÖÉÁ¥†ÊàñÈÄâ‰∏≠ÁöÑÂÖÉÁ¥†‰∏çÂú®ÁÇπÂáª‰ΩçÁΩÆÔºöÈÄâÊã©ÊúÄ‰∏äÂ±ÇÁöÑÂÖÉÁ¥†ÔºàÁ¨¨‰∏Ä‰∏™Ôºâ
            elementToSelect = elementsAtPosition[0];
        }
        
        // ÈÄâÊã©ÂÖÉÁ¥†
        if (selectedElement !== elementToSelect) {
            uiSelectElement(elementToSelect);
        }
    }
    
    return elementToSelect;
}

// ÂÖ®Â±ÄÂáΩÊï∞Ôºå‰æõÊéßÂà∂Âè∞Ë∞ÉÁî®
window.ElementTypes = ElementTypes;
window.addElement = addElement;
window.removeElement = removeElement;
window.clearElements = clearElements;
window.getElementTypeText = getElementTypeText;
window.getElementPropsText = getElementPropsText;

/* ================================ */
/* ÂÖÉÁ¥†ÁöÑÊñ∞Â¢ûÁªòÂà∂
/* ================================ */

// ÁªòÂà∂ÁÇπÂáΩÊï∞
function createPoint(mathX, mathY) {

    // Â¶ÇÊûúÂèòÊç¢Èù¢ÊùøÊâìÂºÄÔºåÁ¶ÅÊ≠¢ÂàõÂª∫Êñ∞ÁÇπ
    if (uiPropertyPanelShown) {
        return;
    }

    addElement(ElementTypes.POINT, Point([mathX, mathY]), Attributes(0));
}

window.createPoint = createPoint;

/**
 * Â§ÑÁêÜËæÖÂä©Á∫øÁªòÂà∂ÁªìÊùü
 * Ê£ÄÊü•Èº†Ê†áÊòØÂê¶ÁßªÂä®ÔºåÂ¶ÇÊûúÁßªÂä®ÂàôÂºπÂá∫ËèúÂçïÔºåÂê¶ÂàôÊ∏ÖÈô§ÁªòÂà∂Áä∂ÊÄÅ
 */
function handleAuxLineDrawingEnd(e) {
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    // Ê£ÄÊü•Èº†Ê†áÊòØÂê¶ËøòÂú® canvas ÂÜÖ
    const mouseInCanvas = mouseX >= 0 && mouseX <= canvas.width && 
                         mouseY >= 0 && mouseY <= canvas.height;
    
    // Ê£ÄÊü•Èº†Ê†áÊòØÂê¶ÁßªÂä®‰∫Ü
    const mouseMoved = drawDown && (
        Math.abs(mouseX - drawDown[0]) > DOUBLE_CLICK_THRESHOLD ||
        Math.abs(mouseY - drawDown[1]) > DOUBLE_CLICK_THRESHOLD
    );
    
    // Âè™ÊúâÂú®Èº†Ê†áÁßªÂä®‰∫Ü‰∏î‰ªçÂú® canvas ÂÜÖÊó∂ÊâçÂºπÂá∫ËèúÂçï
    if (mouseMoved && mouseInCanvas) {
        // ËÆ∞ÂΩïÁªàÁÇπÂùêÊ†á
        drawEnd = screenToMath(mouseX, mouseY);
        if (e.shiftKey) { drawEnd[0] |= 0; drawEnd[1] |= 0; }
        
        // ËæÖÂä©Á∫øÂõ∫ÂÆöÔºå‰∏çÂÜçË∑üÈöèÈº†Ê†áÁßªÂä®
        drawing = DRAWING.AUX_MENU;
        
        canvas.style.cursor = 'default';
        
        // ÂºπÂá∫ËèúÂçï
        UIShowGeometryMenu(rect.left + mouseX + 10, rect.top + mouseY + 10);
        
        // Ê†áËÆ∞ËèúÂçïÊ≠£Âú®ÂºπÂá∫ÔºåÈÅøÂÖçË¢´ÂêéÁª≠ÁöÑ click ‰∫ã‰ª∂ÈöêËóè
        uiMenuPopping = true;
        setTimeout(() => { uiMenuPopping = false; }, 100);
    } else {
        // Ê∏ÖÈô§ËæÖÂä©Á∫øÁä∂ÊÄÅÔºàÈº†Ê†áÊú™ÁßªÂä®ÊàñÂ∑≤Á¶ªÂºÄ canvasÔºâ
        drawing = 0;
    }
    
    stopMouseCapture();
    draw();
}

//------------------------------------
// Â§öËæπÂΩ¢ÁªòÂà∂Á≥ªÁªü

function handlePolygonDrawing(e) {

    // Â¶ÇÊûúÂèòÊç¢Èù¢ÊùøÊâìÂºÄÔºåÁ¶ÅÊ≠¢ÁªòÂà∂Â§öËæπÂΩ¢
    if (uiPropertyPanelShown) {
        return;
    }

    const rect = canvas.getBoundingClientRect();
    const mathP = screenToMath(e.clientX - rect.left, e.clientY - rect.top);
    if (e.shiftKey) { mathP[0] |= 0; mathP[1] |= 0; } // ÊîØÊåÅÊåâ‰Ωè Shift ÈîÆÁöÑÁΩëÊ†ºÂØπÈΩêÊú∫Âà∂

    // ÂºÄÂßãÁªòÂà∂Â§öËæπÂΩ¢
    if (drawing !== DRAWING.POLYGON) { drawing = DRAWING.POLYGON;
        drawingPolygon = [mathP];
    }
    else drawingPolygon.push(mathP);

    draw();
}
function resetPolygonDrawing() {
    if (drawing === DRAWING.POLYGON) drawing = 0;
    drawingPolygon = [];
    draw();
}
function finishPolygonDrawing() {
    if (drawing !== DRAWING.POLYGON || drawingPolygon.length <= 2) {

        resetPolygonDrawing();
        return;
    }

    // ÂàõÂª∫Â§öËæπÂΩ¢ÂÖÉÁ¥†
    addElement(ElementTypes.POLYGON, Polygon(drawingPolygon, true), Attributes());

    resetPolygonDrawing();
}
function drawPolygonPreview() {
    if (drawingPolygon.length === 0) return;

    ctx.save();

    // ÁªòÂà∂Â∑≤Á°ÆÂÆöÁöÑÁÇπ
    ctx.fillStyle = '#ff6600';
    drawingPolygon.forEach(point => {
        ctx.beginPath();
        ctx.arc(point[0] * UNIT_SIZE, point[1] * UNIT_SIZE, 3 / scale, 0, PI2);
        ctx.fill();
    });

    // ÁªòÂà∂Â§öËæπÂΩ¢ËæπÁ∫ø
    if (drawingPolygon.length > 1) {
        ctx.strokeStyle = 'rgba(255, 102, 0, 0.8)';
        ctx.lineWidth = 2 / scale;
        ctx.setLineDash([3 / scale, 3 / scale]);

        ctx.beginPath();
        const firstPoint = drawingPolygon[0];
        ctx.moveTo(firstPoint[0] * UNIT_SIZE, firstPoint[1] * UNIT_SIZE);

        for (let i = 1; i < drawingPolygon.length; i++) {
            const point = drawingPolygon[i];
            ctx.lineTo(point[0] * UNIT_SIZE, point[1] * UNIT_SIZE);
        }

        // Â¶ÇÊûúÊúâÂ§ö‰∫é2‰∏™ÁÇπÔºåÁªòÂà∂ÂõûÂà∞Ëµ∑ÁÇπÁöÑËôöÁ∫ø
        if (drawingPolygon.length > 2) {
            ctx.lineTo(firstPoint[0] * UNIT_SIZE, firstPoint[1] * UNIT_SIZE);
        }

        ctx.stroke();
        ctx.setLineDash([]); // ÈáçÁΩÆÁ∫øÊù°Ê†∑Âºè
    }

    // ÁªòÂà∂‰ªéÊúÄÂêé‰∏Ä‰∏™ÁÇπÂà∞ÂΩìÂâçÈº†Ê†á‰ΩçÁΩÆÁöÑÈ¢ÑËßàÁ∫ø
    if (drawingPolygon.length > 0 && mouseMath) {
        ctx.strokeStyle = 'rgba(255, 102, 0, 0.5)';
        ctx.lineWidth = 1 / scale;
        ctx.setLineDash([5 / scale, 5 / scale]);

        const lastPoint = drawingPolygon[drawingPolygon.length - 1];
        ctx.beginPath();
        ctx.moveTo(lastPoint[0] * UNIT_SIZE, lastPoint[1] * UNIT_SIZE);
        ctx.lineTo(mouseMath[0] * UNIT_SIZE, mouseMath[1] * UNIT_SIZE);
        ctx.stroke();

        ctx.setLineDash([]);
    }

    ctx.restore();
}

window.handlePolygonDrawing = handlePolygonDrawing;
window.resetPolygonDrawing = resetPolygonDrawing;
window.finishPolygonDrawing = finishPolygonDrawing;

//------------------------------------
// ÂºßÁ∫øÁªòÂà∂Á≥ªÁªü

function enterArcCurvatureMode() {
    if (drawing !== DRAWING.AUX_MENU || !drawStart || !drawEnd) return;

    drawing = DRAWING.ARC;
    arcStartPoint = drawStart;
    arcEndPoint = drawEnd;

    // ËÆ°ÁÆóÂº¶ÁöÑ‰∏≠ÁÇπÂíåÂûÇÁõ¥ÂêëÈáè
    chordMidPoint = [
        (arcStartPoint[0] + arcEndPoint[0]) / 2,
        (arcStartPoint[1] + arcEndPoint[1]) / 2
    ];

    const dx = arcEndPoint[0] - arcStartPoint[0];
    const dy = arcEndPoint[1] - arcStartPoint[1];
    const perpX = -dy; // ÂûÇÁõ¥ÂêëÈáè
    const perpY = dx;
    const perpLength = Math.sqrt(perpX * perpX + perpY * perpY);

    if (perpLength > 0) {
        perpVector = [
            perpX / perpLength,
            perpY / perpLength
        ];
        const offset = Math.max(1, perpLength / 4); // ÈªòËÆ§ÂÅèÁßªË∑ùÁ¶ª

        arcCenterPoint = [
            chordMidPoint[0] + perpVector[0] * offset,
            chordMidPoint[1] + perpVector[1] * offset
        ];
    } else {
        perpVector = [0, 1];
        arcCenterPoint = [chordMidPoint[0], chordMidPoint[1] + 1];
    }

    updateArcRadius();
    draw();
}
function resetArcDrawing() {
    if (drawing === DRAWING.ARC) drawing = 0;
    arcStartPoint = null;
    arcEndPoint = null;
    arcCenterPoint = null;
    arcRadius = 0;
    isPerpendicularLocked = false;
    chordMidPoint = null;
    perpVector = null;

    draw();
}
function completeArcDrawing() {
    if (!arcStartPoint || !arcEndPoint || !arcCenterPoint) return;

    // ÂàõÂª∫ÂºßÁ∫øÂÖÉÁ¥†
    addElement(ElementTypes.ARC, Arc(arcCenterPoint, arcRadius, arcStartPoint, arcEndPoint), Attributes());

    resetArcDrawing();
}
function drawArcCurvaturePreview() {
    if (!arcStartPoint || !arcEndPoint || !arcCenterPoint) return;

    ctx.save();

    // ÁªòÂà∂Âº¶Á∫øÔºàÊ∑°ÂåñÊòæÁ§∫Ôºâ
    ctx.strokeStyle = 'rgba(128, 128, 128, 0.5)';
    ctx.lineWidth = 1 / scale;
    ctx.setLineDash([3 / scale, 3 / scale]);
    ctx.beginPath();
    ctx.moveTo(arcStartPoint[0] * UNIT_SIZE, arcStartPoint[1] * UNIT_SIZE);
    ctx.lineTo(arcEndPoint[0] * UNIT_SIZE, arcEndPoint[1] * UNIT_SIZE);
    ctx.stroke();
    ctx.setLineDash([]);

    // ÁªòÂà∂Âº¶ÁöÑ‰∏≠ÁÇπ
    const midX = (arcStartPoint[0] + arcEndPoint[0]) / 2;
    const midY = (arcStartPoint[1] + arcEndPoint[1]) / 2;
    ctx.fillStyle = 'rgba(128, 128, 128, 0.7)';
    ctx.beginPath();
    ctx.arc(midX * UNIT_SIZE, midY * UNIT_SIZE, 2 / scale, 0, PI2);
    ctx.fill();

    // ÁªòÂà∂Ê≥ïÁ∫øÔºà‰ªéÂº¶‰∏≠ÁÇπÂà∞ÂúÜÂøÉÔºâ
    if (isPerpendicularLocked) {
        // ÂûÇÁõ¥ÈîÅÂÆöÊ®°ÂºèÔºöÁªòÂà∂ÂÆåÊï¥ÁöÑÂûÇÁõ¥Âπ≥ÂàÜÁ∫ø
        ctx.strokeStyle = 'rgba(255, 102, 0, 0.8)';
        ctx.lineWidth = 2 / scale;
        ctx.setLineDash([3 / scale, 3 / scale]);

        // ÁªòÂà∂‰ªéÂº¶‰∏≠ÁÇπÂêë‰∏§‰æßÂª∂‰º∏ÁöÑÂûÇÁõ¥Á∫ø
        const extendLength = Math.max(10, arcRadius * 2);
        ctx.beginPath();
        ctx.moveTo(
            (midX - perpVector[0] * extendLength) * UNIT_SIZE,
            (midY - perpVector[1] * extendLength) * UNIT_SIZE
        );
        ctx.lineTo(
            (midX + perpVector[0] * extendLength) * UNIT_SIZE,
            (midY + perpVector[1] * extendLength) * UNIT_SIZE
        );
        ctx.stroke();
        ctx.setLineDash([]);
    } else {
        // Ëá™Áî±Ê®°ÂºèÔºöÁªòÂà∂‰ªéÂº¶‰∏≠ÁÇπÂà∞ÂúÜÂøÉÁöÑÁ∫ø
        ctx.strokeStyle = 'rgba(153, 50, 204, 0.6)';
        ctx.lineWidth = 1 / scale;
        ctx.setLineDash([5 / scale, 3 / scale]);
        ctx.beginPath();
        ctx.moveTo(midX * UNIT_SIZE, midY * UNIT_SIZE);
        ctx.lineTo(arcCenterPoint[0] * UNIT_SIZE, arcCenterPoint[1] * UNIT_SIZE);
        ctx.stroke();
        ctx.setLineDash([]);
    }

    // ÁªòÂà∂ÂúÜÂøÉÁÇπ
    if (isPerpendicularLocked) {
        // ÈîÅÂÆöÊ®°ÂºèÔºö‰ΩøÁî®Ê©ôËâ≤ÊòæÁ§∫
        ctx.fillStyle = '#ff6600';
        ctx.strokeStyle = '#ff6600';
        ctx.lineWidth = 2 / scale;
        ctx.beginPath();
        ctx.arc(arcCenterPoint[0] * UNIT_SIZE, arcCenterPoint[1] * UNIT_SIZE, 4 / scale, 0, PI2);
        ctx.fill();
        ctx.stroke();
    } else {
        // Ëá™Áî±Ê®°ÂºèÔºö‰ΩøÁî®Á¥´Ëâ≤ÊòæÁ§∫
        ctx.fillStyle = '#9932cc';
        ctx.beginPath();
        ctx.arc(arcCenterPoint[0] * UNIT_SIZE, arcCenterPoint[1] * UNIT_SIZE, 3 / scale, 0, PI2);
        ctx.fill();
    }

    // ÁªòÂà∂ËæÖÂä©ÂúÜÔºàÊ∑°ÂåñÊòæÁ§∫Ôºâ
    ctx.strokeStyle = 'rgba(153, 50, 204, 0.3)';
    ctx.lineWidth = 1 / scale;
    ctx.beginPath();
    ctx.arc(arcCenterPoint[0] * UNIT_SIZE, arcCenterPoint[1] * UNIT_SIZE, arcRadius * UNIT_SIZE, 0, PI2);
    ctx.stroke();

    // ÁªòÂà∂È¢ÑËßàÂºßÁ∫ø
    const startAngle = Math.atan2(
        arcStartPoint[1] - arcCenterPoint[1],
        arcStartPoint[0] - arcCenterPoint[0]
    );
    const endAngle = Math.atan2(
        arcEndPoint[1] - arcCenterPoint[1],
        arcEndPoint[0] - arcCenterPoint[0]
    );

    // Á°Æ‰øùÂºßÁ∫øÁªòÂà∂ÊñπÂêëÊ≠£Á°ÆÔºà‰ªéËµ∑ÁÇπÂà∞ÁªàÁÇπÔºåÈÄÜÊó∂ÈíàÊñπÂêëÔºâ
    let adjustedEndAngle = endAngle;
    if (endAngle <= startAngle) {
        adjustedEndAngle = endAngle + 2 * Math.PI;
    }

    ctx.strokeStyle = '#9932cc';
    ctx.lineWidth = 2 / scale;
    ctx.beginPath();
    ctx.arc(
        arcCenterPoint[0] * UNIT_SIZE,
        arcCenterPoint[1] * UNIT_SIZE,
        arcRadius * UNIT_SIZE,
        startAngle,
        adjustedEndAngle
    );
    ctx.stroke();

    // ÁªòÂà∂Ëµ∑ÁÇπÂíåÁªàÁÇπ
    ctx.fillStyle = '#9932cc';
    ctx.beginPath();
    ctx.arc(arcStartPoint[0] * UNIT_SIZE, arcStartPoint[1] * UNIT_SIZE, 2 / scale, 0, PI2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(arcEndPoint[0] * UNIT_SIZE, arcEndPoint[1] * UNIT_SIZE, 2 / scale, 0, PI2);
    ctx.fill();

    ctx.restore();
}

// Êõ¥Êñ∞ÂºßÁ∫øÂèÇÊï∞
function updateArcRadius() {
    if (!arcCenterPoint || !arcStartPoint) return;

    arcRadius = Math.sqrt(
        Math.pow(arcStartPoint[0] - arcCenterPoint[0], 2) +
        Math.pow(arcStartPoint[1] - arcCenterPoint[1], 2)
    );
}
// Êõ¥Êñ∞ÂºßÁ∫øÂúÜÂøÉ‰ΩçÁΩÆÔºàÊîØÊåÅÂûÇÁõ¥ÈîÅÂÆöÊ®°ÂºèÔºâ
function updateArcCenterPosition(mouseX, mouseY, altPressed) {
    if (!arcStartPoint || !arcEndPoint || !chordMidPoint || !perpVector) return;

    // Êõ¥Êñ∞ÈîÅÂÆöÁä∂ÊÄÅ
    isPerpendicularLocked = altPressed;

    if (isPerpendicularLocked) {

        // ÂûÇÁõ¥ÈîÅÂÆöÊ®°ÂºèÔºöÂúÜÂøÉÂè™ËÉΩÂú®ÂûÇÁõ¥Âπ≥ÂàÜÁ∫ø‰∏äÁßªÂä®
        // ËÆ°ÁÆóÈº†Ê†á‰ΩçÁΩÆÂú®ÂûÇÁõ¥Âπ≥ÂàÜÁ∫ø‰∏äÁöÑÊäïÂΩ±
        const mouseToMidX = mouseX - chordMidPoint[0];
        const mouseToMidY = mouseY - chordMidPoint[1];

        // ËÆ°ÁÆóÊäïÂΩ±ÈïøÂ∫¶ÔºàÁÇπÁßØÔºâ
        const projectionLength = mouseToMidX * perpVector[0] + mouseToMidY * perpVector[1];

        // ÂúÜÂøÉ‰ΩçÁΩÆ = Âº¶‰∏≠ÁÇπ + ÊäïÂΩ±ÈïøÂ∫¶ * ÂûÇÁõ¥Âçï‰ΩçÂêëÈáè
        arcCenterPoint = [
            chordMidPoint[0] + projectionLength * perpVector[0],
            chordMidPoint[1] + projectionLength * perpVector[1]
        ];
    } else {
        // Ëá™Áî±Ê®°ÂºèÔºöÂúÜÂøÉÂèØ‰ª•ÈöèÊÑèÁßªÂä®
        arcCenterPoint = [mouseX, mouseY];
    }

    updateArcRadius();
}

window.enterArcCurvatureMode = enterArcCurvatureMode;
window.resetArcDrawing = resetArcDrawing;
window.completeArcDrawing = completeArcDrawing;
window.updateArcCenterPosition = updateArcCenterPosition;

//------------------------------------
// ease Êõ≤Á∫øÁªòÂà∂Á≥ªÁªü

function enterEaseMode() {
    if (drawing !== DRAWING.AUX_MENU || !drawStart || !drawEnd) return;

    drawing = DRAWING.EASE;
    easeStartPoint = drawStart;
    easeEndPoint = drawEnd;

    // ÂàùÂßãÂåñeaseÁ±ªÂûãÔºàÂ¶ÇÊûúÊú™ËÆæÁΩÆÔºâ
    if (currentEaseType < 0) currentEaseType = EASE_FUNC.SINE;
    if (currentEaseProc < 0) currentEaseProc = EASE_PROC.INOUT;

    draw();
}
function resetEaseDrawing() {
    if (drawing === DRAWING.EASE) drawing = 0;
    easeStartPoint = null;
    easeEndPoint = null;
    // ‰∏çÈáçÁΩÆÔºåÊñπ‰æøËøûÁª≠ÁªòÂà∂
    //currentEaseType = -1;
    //currentEaseProc = -1;
    draw();
}
function completeEaseDrawing() {
    if (!easeStartPoint || !easeEndPoint) return;

    // ÂàõÂª∫easeÊõ≤Á∫øÂÖÉÁ¥†
    addElement(ElementTypes.EASE, Ease(easeStartPoint, easeEndPoint, currentEaseType, currentEaseProc), Attributes());

    resetEaseDrawing();
}
function drawEasePreview() {
    if (!easeStartPoint || !easeEndPoint) return;

    ctx.save();

    // ÁªòÂà∂Ëµ∑ÁÇπÂíåÁªàÁÇπËøûÁ∫øÔºàÊ∑°ÂåñÊòæÁ§∫Ôºâ
    ctx.strokeStyle = 'rgba(128, 128, 128, 0.4)';
    ctx.lineWidth = 1 / scale;
    ctx.setLineDash([3 / scale, 3 / scale]);
    ctx.beginPath();
    ctx.moveTo(easeStartPoint[0] * UNIT_SIZE, easeStartPoint[1] * UNIT_SIZE);
    ctx.lineTo(easeEndPoint[0] * UNIT_SIZE, easeEndPoint[1] * UNIT_SIZE);
    ctx.stroke();
    ctx.setLineDash([]);

    // Ëé∑ÂèñÂΩìÂâçÂàÜÁªÑÁöÑÈ¢úËâ≤
    const currentGroupColor = EASE_GROUP_COLORS[currentEaseType] || 'sine';

    // ÂÆö‰πâ‰∏âÁßçÁ±ªÂûãÁöÑÊ†∑ÂºèÔºàÂΩìÂâçÈÄâ‰∏≠Á±ªÂûã‰ΩøÁî®ÂàÜÁªÑÈ¢úËâ≤ÔºåÂÖ∂‰ªñ‰ΩøÁî®Áªü‰∏ÄÁÅ∞Ëâ≤Ôºâ
    const typeStyles = [
        { type: EASE_PROC.IN, alpha: 0.6 },
        { type: EASE_PROC.OUT, alpha: 0.6 },
        { type: EASE_PROC.INOUT, alpha: 0.6 }
    ];

    // ÁªòÂà∂ÂΩìÂâçÂàÜÁªÑÁöÑÊâÄÊúâ‰∏âÁßçÁ±ªÂûãÁöÑeaseÊõ≤Á∫ø
    typeStyles.forEach(style => {
        const isCurrentType = style.type === currentEaseProc;
        // ËÆæÁΩÆÁ∫øÊù°Ê†∑ÂºèÔºàÂΩìÂâçÁ±ªÂûã‰ΩøÁî®ÂàÜÁªÑÈ¢úËâ≤ÔºåÂÖ∂‰ªñ‰ΩøÁî®Áªü‰∏ÄÁÅ∞Ëâ≤Ôºâ
        ctx.strokeStyle = isCurrentType ? currentGroupColor : `rgba(128, 128, 128, ${style.alpha})`;
        ctx.lineWidth = DEFAULT_LINE_WIDTH / scale;
        ctx.setLineDash(isCurrentType ? [] : [2 / scale, 2 / scale]); // ÂΩìÂâçÁ±ªÂûãÂÆûÁ∫øÔºåÂÖ∂‰ªñËôöÁ∫ø
        ctx.beginPath();
        ctx.moveTo(easeStartPoint[0] * UNIT_SIZE, easeStartPoint[1] * UNIT_SIZE);

        // ‰ΩøÁî®‰ºòÂåñÂêéÁöÑeaseÂáΩÊï∞ÁîüÊàêÊõ≤Á∫øÁÇπ
        const p1 = [easeStartPoint[0], easeStartPoint[1]];
        const p2 = [easeEndPoint[0], easeEndPoint[1]];
        const amp = 0.4; // ÂπÖÂ∫¶Á≥ªÊï∞

        // È¢ÑËÆ°ÁÆóÂá†‰ΩïÂèÇÊï∞‰ª•‰ºòÂåñÊÄßËÉΩ
        const dx = p2[0] - p1[0], dy = p2[1] - p1[1];
        const dist = Math.sqrt(dx*dx + dy*dy);
        const aux = { dx: dx, dy: dy, dist, norX: dy / dist, norY: -dx / dist };

        // ‰ΩøÁî®pixelEvalÁîüÊàê‰ºòÂåñÁöÑÈááÊ†∑ÁÇπ
        const points = pixelEval((t) => ease[currentEaseType + style.type](t, p1, p2, amp, aux), false);
        // ÁªòÂà∂easeÊõ≤Á∫ø
        for (let i = 1; i < points.length; i++) {
            ctx.lineTo(points[i][0] * UNIT_SIZE, points[i][1] * UNIT_SIZE);
        }
        ctx.stroke();
        ctx.setLineDash([]); // ÈáçÁΩÆËôöÁ∫ø
    });

    // ÁªòÂà∂Ëµ∑ÁÇπÂíåÁªàÁÇπ
    ctx.fillStyle = currentGroupColor;
    ctx.beginPath();
    ctx.arc(easeStartPoint[0] * UNIT_SIZE, easeStartPoint[1] * UNIT_SIZE, 3 / scale, 0, PI2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(easeEndPoint[0] * UNIT_SIZE, easeEndPoint[1] * UNIT_SIZE, 3 / scale, 0, PI2);
    ctx.fill();

    ctx.restore();
}

// ËæÖÂä©ÂáΩÊï∞ÔºöËé∑Âèñ ease Á±ªÂûãÊñáÊú¨
// Âæ™ÁéØ ease Á±ªÂûã
function cycleEaseType() {
    currentEaseType = (currentEaseType+=3) % EASE_FUNC.BOUNCE;
    currentEaseProc = EASE_PROC.INOUT; // ÈáçÁΩÆ‰∏∫ÈªòËÆ§Á±ªÂûã
    draw();
}
// Âæ™ÁéØ ease ËøáÁ®ã
function cycleEaseProc() {
    currentEaseProc = ++currentEaseProc % 3;
    draw();
}

// Êö¥Èú≤easeÊõ≤Á∫øÁªòÂà∂Áõ∏ÂÖ≥ÂáΩÊï∞Âà∞ÂÖ®Â±Ä
window.enterEaseMode = enterEaseMode;
window.resetEaseDrawing = resetEaseDrawing;
window.completeEaseDrawing = completeEaseDrawing;
window.getEaseTypeText = getEaseTypeText;
window.getEaseProcText = getEaseProcText;
window.cycleEaseType = cycleEaseType;
window.cycleEaseProc = cycleEaseProc;

//------------------------------------
// Ë¥ùÂ°ûÂ∞îÊõ≤Á∫øÁªòÂà∂Á≥ªÁªü

function enterBezierMode() {
    if (drawing !== DRAWING.AUX_MENU || !drawStart || !drawEnd) return;

    drawing = DRAWING.BEZIER;
    bezierStartPoint = drawStart;
    bezierEndPoint = drawEnd;
    currentBezierControlIndex = 0;

    // ÂàùÂßãÂåñÊéßÂà∂ÁÇπÊï∞ÁªÑ
    initializeBezierControlPoints();

    draw();
}
function resetBezierDrawing() {
    if (drawing === DRAWING.BEZIER) drawing = 0;

    bezierStartPoint = null;
    bezierEndPoint = null;
    bezierControlPoints = [];
    bezierControlPointCount = 2; // ÈáçÁΩÆ‰∏∫ÈªòËÆ§ÁöÑ‰∏âÊ¨°Ë¥ùÂ°ûÂ∞îÊõ≤Á∫ø
    currentBezierControlIndex = 0;

    draw();
}
function completeBezierDrawing() {
    if (!bezierStartPoint || !bezierEndPoint || bezierControlPoints.length === 0) return;

    addElement(ElementTypes.BEZIER, Bezier(bezierStartPoint, bezierEndPoint, bezierControlPoints), Attributes());

    resetBezierDrawing();
}
function drawBezierPreview() {
    if (!bezierStartPoint || !bezierEndPoint || bezierControlPoints.length === 0) return;

    ctx.save();

    // ÁªòÂà∂Ëµ∑ÁÇπÂíåÁªàÁÇπËøûÁ∫øÔºàÊ∑°ÂåñÊòæÁ§∫Ôºâ
    ctx.strokeStyle = 'rgba(128, 128, 128, 0.4)';
    ctx.lineWidth = 1 / scale;
    ctx.setLineDash([3 / scale, 3 / scale]);
    ctx.beginPath();
    ctx.moveTo(bezierStartPoint[0] * UNIT_SIZE, bezierStartPoint[1] * UNIT_SIZE);
    ctx.lineTo(bezierEndPoint[0] * UNIT_SIZE, bezierEndPoint[1] * UNIT_SIZE);
    ctx.stroke();
    ctx.setLineDash([]);

    // ÁªòÂà∂ÊéßÂà∂Á∫øÂíåÊéßÂà∂ÁÇπ
    bezierControlPoints.forEach((controlPoint, index) => {
        const isCurrent = index === currentBezierControlIndex;
        const color = isCurrent ? '#e67e22' : 'rgba(230, 126, 34, 0.6)';
        const size = isCurrent ? 4 / scale : 3 / scale;

        // ÁªòÂà∂ÊéßÂà∂Á∫øÔºà‰ªéËµ∑ÁÇπÊàñÁªàÁÇπÂà∞ÊéßÂà∂ÁÇπÔºâ
        ctx.strokeStyle = color;
        ctx.lineWidth = 1 / scale;
        ctx.setLineDash([2 / scale, 2 / scale]);
        ctx.beginPath();

        // Ê†πÊçÆÊéßÂà∂ÁÇπ‰ΩçÁΩÆÂÜ≥ÂÆöËøûÊé•Âà∞Ëµ∑ÁÇπËøòÊòØÁªàÁÇπ
        if (bezierControlPointCount === 1) {
            // ‰∫åÊ¨°Ë¥ùÂ°ûÂ∞îÊõ≤Á∫øÔºöÊéßÂà∂ÁÇπËøûÊé•Âà∞‰∏≠ÁÇπ
            const midX = (bezierStartPoint[0] + bezierEndPoint[0]) / 2;
            const midY = (bezierStartPoint[1] + bezierEndPoint[1]) / 2;
            ctx.moveTo(midX * UNIT_SIZE, midY * UNIT_SIZE);
        } else if (index < bezierControlPointCount / 2) {
            // ÂâçÂçäÈÉ®ÂàÜÊéßÂà∂ÁÇπËøûÊé•Âà∞Ëµ∑ÁÇπ
            ctx.moveTo(bezierStartPoint[0] * UNIT_SIZE, bezierStartPoint[1] * UNIT_SIZE);
        } else {
            // ÂêéÂçäÈÉ®ÂàÜÊéßÂà∂ÁÇπËøûÊé•Âà∞ÁªàÁÇπ
            ctx.moveTo(bezierEndPoint[0] * UNIT_SIZE, bezierEndPoint[1] * UNIT_SIZE);
        }

        ctx.lineTo(controlPoint[0] * UNIT_SIZE, controlPoint[1] * UNIT_SIZE);
        ctx.stroke();

        // ÁªòÂà∂ÊéßÂà∂ÁÇπ
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(controlPoint[0] * UNIT_SIZE, controlPoint[1] * UNIT_SIZE, size, 0, PI2);
        ctx.fill();
    });

    ctx.setLineDash([]);

    // ÁªòÂà∂È¢ÑËßàË¥ùÂ°ûÂ∞îÊõ≤Á∫ø
    ctx.strokeStyle = '#e67e22';
    ctx.lineWidth = 2 / scale;
    ctx.beginPath();
    ctx.moveTo(bezierStartPoint[0] * UNIT_SIZE, bezierStartPoint[1] * UNIT_SIZE);

    // ÁªòÂà∂Êõ≤Á∫ø
    const points = pixelEval((t) => bezier(t, [bezierStartPoint, ...bezierControlPoints, bezierEndPoint]), false);
    for (let i = 1; i < points.length; i++) {
        ctx.lineTo(points[i][0] * UNIT_SIZE, points[i][1] * UNIT_SIZE);
    }

    ctx.stroke();

    // ÁªòÂà∂Ëµ∑ÁÇπÂíåÁªàÁÇπ
    ctx.fillStyle = '#e67e22';
    ctx.beginPath();
    ctx.arc(bezierStartPoint[0] * UNIT_SIZE, bezierStartPoint[1] * UNIT_SIZE, 2 / scale, 0, PI2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(bezierEndPoint[0] * UNIT_SIZE, bezierEndPoint[1] * UNIT_SIZE, 2 / scale, 0, PI2);
    ctx.fill();

    ctx.restore();
}

// Êõ¥Êñ∞Ë¥ùÂ°ûÂ∞îÊõ≤Á∫øÊéßÂà∂ÁÇπ‰ΩçÁΩÆ
function updateBezierControlPoint(mouseX, mouseY, altPressed) {
    if (drawing !== DRAWING.BEZIER || currentBezierControlIndex >= bezierControlPoints.length) return;

    // Âú®Ë¥ùÂ°ûÂ∞îÊõ≤Á∫øËÆæÁΩÆÊ®°Âºè‰∏ãÔºåAltÈîÆÁî®‰∫éÂàáÊç¢Èò∂Êï∞Ôºå‰∏çÁî®‰∫éÁΩëÊ†ºÂØπÈΩê
    // ÁΩëÊ†ºÂØπÈΩêÊîπÁî±ÂÖ∂‰ªñÈîÆÂÆûÁé∞ÔºàÊöÇÊó∂Á¶ÅÁî®Ôºâ

    // Êõ¥Êñ∞ÂΩìÂâçÊ≠£Âú®ËÆæÁΩÆÁöÑÊéßÂà∂ÁÇπ
    bezierControlPoints[currentBezierControlIndex] = [mouseX, mouseY];
}
// Â§ÑÁêÜË¥ùÂ°ûÂ∞îÊõ≤Á∫øÊéßÂà∂ÁÇπÁÇπÂáª
function handleBezierControlClick() {
    if (drawing !== DRAWING.BEZIER) return;

    if (currentBezierControlIndex < bezierControlPointCount - 1) {
        // ËÆæÁΩÆ‰∏ã‰∏Ä‰∏™ÊéßÂà∂ÁÇπ
        currentBezierControlIndex++;

    } else {
        // ÊâÄÊúâÊéßÂà∂ÁÇπËÆæÁΩÆÂÆåÊàêÔºåÂàõÂª∫Ë¥ùÂ°ûÂ∞îÊõ≤Á∫ø
        completeBezierDrawing();
    }
}
// ËæÖÂä©ÂáΩÊï∞ÔºöÂàùÂßãÂåñÊéßÂà∂ÁÇπÊï∞ÁªÑ
function initializeBezierControlPoints() {
    bezierControlPoints = [];

    const midX = (bezierStartPoint[0] + bezierEndPoint[0]) / 2;
    const midY = (bezierStartPoint[1] + bezierEndPoint[1]) / 2;
    const dx = bezierEndPoint[0] - bezierStartPoint[0];
    const dy = bezierEndPoint[1] - bezierStartPoint[1];
    const length = Math.sqrt(dx * dx + dy * dy);
    const offset = Math.max(1, length / (bezierControlPointCount + 1));

    for (let i = 0; i < bezierControlPointCount; i++) {
        let controlPoint;

        if (bezierControlPointCount === 1) {
            // ‰∫åÊ¨°Ë¥ùÂ°ûÂ∞îÊõ≤Á∫øÔºö‰∏Ä‰∏™ÊéßÂà∂ÁÇπÂú®‰∏≠ÁÇπ‰∏äÊñπ
            controlPoint = [
                midX - dy / length * offset,
                midY + dx / length * offset
            ];
        } else if (bezierControlPointCount === 2) {
            // ‰∏âÊ¨°Ë¥ùÂ°ûÂ∞îÊõ≤Á∫øÔºö‰∏§‰∏™ÊéßÂà∂ÁÇπÂØπÁß∞ÂàÜÂ∏É
            const side = i === 0 ? -1 : 1;
            controlPoint = [
                midX + side * dy / length * offset,
                midY - side * dx / length * offset
            ];
        } else {
            // È´òÈò∂Ë¥ùÂ°ûÂ∞îÊõ≤Á∫øÔºöÊéßÂà∂ÁÇπÊ≤øÁùÄÂûÇÁõ¥ÊñπÂêëÂàÜÂ∏É
            const t = (i + 1) / (bezierControlPointCount + 1);
            const baseX = bezierStartPoint[0] + t * dx;
            const baseY = bezierStartPoint[1] + t * dy;
            const offsetMultiplier = Math.sin(Math.PI * t) * (i % 2 === 0 ? 1 : -1);

            controlPoint = [
                baseX - dy / length * offset * offsetMultiplier,
                baseY + dx / length * offset * offsetMultiplier
            ];
        }

        bezierControlPoints.push(controlPoint);
    }
}
// ËæÖÂä©ÂáΩÊï∞ÔºöÂàáÊç¢Ë¥ùÂ°ûÂ∞îÊõ≤Á∫øÊéßÂà∂ÁÇπÊï∞Èáè
function cycleBezierControlPointCount() {
    // Âú® 1, 2, 3, 4 ‰πãÈó¥Âæ™ÁéØ
    bezierControlPointCount = bezierControlPointCount % 4 + 1;
    currentBezierControlIndex = 0;

    // ÈáçÊñ∞ÂàùÂßãÂåñÊéßÂà∂ÁÇπ
    initializeBezierControlPoints();

    draw();
}

window.enterBezierControlMode = enterBezierMode;
window.resetBezierDrawing = resetBezierDrawing;
window.getBezierTypeText = getBezierTypeText;

/* ================================ */
/* ÂÖÉÁ¥†ÂèòÊç¢ */
/* ================================ */

function applyTransformToPoint(point, transform, elementCenter = [0, 0]) {
    let [ x, y ] = point;

    // 1. Âπ≥Áßª
    x += transform.translation[0];
    y += transform.translation[1];

    // 2. Áº©ÊîæÔºàÁõ∏ÂØπ‰∫éËßÇÊµãÁÇπÔºâ
    const scaleCenter = transform.scale.observePos;
    x = scaleCenter[0] + (x - scaleCenter[0]) * transform.scale.x;
    y = scaleCenter[1] + (y - scaleCenter[1]) * transform.scale.y;

    // 3. ÊóãËΩ¨ÔºàÁõ∏ÂØπ‰∫éËßÇÊµãÁÇπÔºåËßíÂ∫¶ËΩ¨ÂºßÂ∫¶Ôºâ
    if (transform.rotation.angle !== 0) {
        const rotationCenter = transform.rotation.observePos;
        const angleRad = transform.rotation.angle * Math.PI / 180;
        
        const cos = Math.cos(angleRad);
        const sin = Math.sin(angleRad);
        
        const dx = x - rotationCenter[0];
        const dy = y - rotationCenter[1];
        
        x = rotationCenter[0] + dx * cos - dy * sin;
        y = rotationCenter[1] + dx * sin + dy * cos;
    }

    // 4. Ââ™ÂàáÔºàÁõ∏ÂØπ‰∫éËßÇÊµãÁÇπÂíåËßÇÊµãÊñπÂêëÔºâ
    if (transform.shear.forwardY !== 0 || transform.shear.sideX !== 0) {
        const shearCenter = transform.shear.observePos;
        const observeDir = transform.shear.observeDir !== null ? transform.shear.observeDir : 0;
        const dirRad = observeDir * Math.PI / 180;
        
        // ËΩ¨Êç¢Âà∞ËßÇÊµãÂùêÊ†áÁ≥ª
        const dx = x - shearCenter[0];
        const dy = y - shearCenter[1];
        const cos = Math.cos(dirRad);
        const sin = Math.sin(dirRad);
        
        // ÊóãËΩ¨Âà∞ËßÇÊµãÊñπÂêë
        let localX = dx * cos + dy * sin;
        let localY = -dx * sin + dy * cos;
        
        // Â∫îÁî®Ââ™ÂàáÁü©Èòµ
        const newLocalX = localX + transform.shear.sideX * localY;
        const newLocalY = transform.shear.forwardY * localX + localY;
        
        // ÊóãËΩ¨ÂõûÂéüÂùêÊ†áÁ≥ª
        x = shearCenter[0] + newLocalX * cos - newLocalY * sin;
        y = shearCenter[1] + newLocalX * sin + newLocalY * cos;
    }

    // 5. ÁøªËΩ¨ÔºàÁõ∏ÂØπ‰∫éËßÇÊµãÁÇπÂíåËßÇÊµãÊñπÂêëÔºâ
    if (transform.flip.forwardY || transform.flip.sideX) {
        const flipCenter = transform.flip.observePos;
        const observeDir = transform.flip.observeDir !== null ? transform.flip.observeDir : 0;
        const dirRad = observeDir * Math.PI / 180;
        
        // ËΩ¨Êç¢Âà∞ËßÇÊµãÂùêÊ†áÁ≥ª
        const dx = x - flipCenter[0];
        const dy = y - flipCenter[1];
        const cos = Math.cos(dirRad);
        const sin = Math.sin(dirRad);
        
        // ÊóãËΩ¨Âà∞ËßÇÊµãÊñπÂêë
        let localX = dx * cos + dy * sin;
        let localY = -dx * sin + dy * cos;
        
        // Â∫îÁî®ÁøªËΩ¨
        if (transform.flip.sideX) localX = -localX;
        if (transform.flip.forwardY) localY = -localY;
        
        // ÊóãËΩ¨ÂõûÂéüÂùêÊ†áÁ≥ª
        x = flipCenter[0] + localX * cos - localY * sin;
        y = flipCenter[1] + localX * sin + localY * cos;
    }

    return [ x, y ];
}

function applyTransformToElement(element) {
    if (!element.transform) return element;

    const transform = element.transform;

    // Ê£ÄÊü•ÊòØÂê¶ÊúâÂÆûÈôÖÁöÑÂèòÊç¢ÈúÄË¶ÅÂ∫îÁî®
    const hasTranslation = transform.translation[0] !== 0 || transform.translation[1] !== 0;
    const hasFlip = transform.flip && (transform.flip.forwardY || transform.flip.sideX);
    const hasShear = transform.shear && (transform.shear.forwardY !== 0 || transform.shear.sideX !== 0);
    const hasRotation = transform.rotation && transform.rotation.angle !== 0;
    const hasScale = transform.scale && (transform.scale.x !== 1 || transform.scale.y !== 1);

    // Â¶ÇÊûúÊ≤°ÊúâÂÆûÈôÖÂèòÊç¢ÔºåÁõ¥Êé•ËøîÂõûÂéüÂßãÂÖÉÁ¥†
    if (!hasTranslation && !hasFlip && !hasShear && !hasRotation && !hasScale) {
        return element;
    }

    const transformedElement = JSON.parse(JSON.stringify(element));
    const props = element.props;
    switch (element.type) {
        case ElementTypes.POINT:
            const center = props.coords; // ÁÇπÁöÑ‰∏≠ÂøÉÂ∞±ÊòØÁÇπÊú¨Ë∫´
            const transformedPoint = applyTransformToPoint(
                props.coords,
                transform,
                center
            );
            transformedElement.props.coords = transformedPoint;
            break;

        case ElementTypes.SEG:
            const lineCenter = props.centroid;
            const startPoint = applyTransformToPoint(
                props.ft[0],
                transform,
                lineCenter
            );
            const endPoint = applyTransformToPoint(
                props.ft[1],
                transform,
                lineCenter
            );
            transformedElement.props.ft[0] = startPoint;
            transformedElement.props.ft[1] = endPoint;
            // ÈáçÂª∫ËæÖÂä©Êï∞ÊçÆ
            SegRebuild(transformedElement.props);
            break;

        case ElementTypes.RECTANGLE:
            const rect_center = props.centroid;
            const corners = [
                [ props.box[2], props.box[3] ], // left, top
                [ props.box[4], props.box[3] ], // right, top
                [ props.box[4], props.box[5] ], // right, bottom
                [ props.box[2], props.box[5] ]  // left, bottom
            ];
            const transformedCorners = corners.map(corner => applyTransformToPoint(corner, transform, rect_center));

            // Â∞ÜÂèòÊç¢ÂêéÁöÑÁü©ÂΩ¢ËΩ¨Êç¢‰∏∫Â§öËæπÂΩ¢
            transformedElement.type = ElementTypes.POLYGON;
            transformedElement.props = Polygon(transformedCorners, true);
            break;

        case ElementTypes.CIRCLE:
            transformedElement.props.centroid = applyTransformToPoint(props.centroid, transform, props.centroid);
            // Â∫îÁî®Áº©ÊîæÂà∞ÂçäÂæÑÔºà‰ΩøÁî®Áº©ÊîæÁöÑÂπ≥ÂùáÂÄºÔºâ
            transformedElement.props.radius = props.radius * Math.sqrt(transform.scale.x * transform.scale.y);
            // ÈáçÂª∫ËæÖÂä©Êï∞ÊçÆ
            CircleRebuild(transformedElement.props);
            break;

        case ElementTypes.ARC:
            // ÂúÜÂºßÔºöÂèòÊç¢ÊâÄÊúâÁâπÂæÅÁÇπ
            const arcCenterRef = props.centroid;
            transformedElement.props.ft = props.ft.map(point =>
                applyTransformToPoint(point, transform, arcCenterRef)
            );
            // Áº©ÊîæÂçäÂæÑÂíåËßíÂ∫¶
            const avgScale = Math.sqrt(transform.scale.x * transform.scale.y);
            transformedElement.props.radius = props.radius * avgScale;
            transformedElement.props.startRad = props.startRad;
            transformedElement.props.endRad = props.endRad;
            // ÈáçÂª∫ËæÖÂä©Êï∞ÊçÆ
            ArcRebuild(transformedElement.props);
            break;

        case ElementTypes.POLYGON:
            const polygonCenter = props.centroid;
            transformedElement.props.ft = props.ft.map(point =>
                applyTransformToPoint(point, transform, polygonCenter)
            );
            // ÈáçÂª∫ËæÖÂä©Êï∞ÊçÆ
            PolygonRebuild(transformedElement.props);
            break;

        case ElementTypes.EASE:
            const easeCenter = props.centroid;
            transformedElement.props.ft = props.ft.map(point =>
                applyTransformToPoint(point, transform, easeCenter)
            );
            // ÈáçÂª∫ËæÖÂä©Êï∞ÊçÆÂíåÈááÊ†∑ÁÇπ
            EaseRebuild(transformedElement.props);
            break;

        case ElementTypes.BEZIER:
            const bezierCenter = props.centroid;
            transformedElement.props.controls = props.controls.map(point =>
                applyTransformToPoint(point, transform, bezierCenter)
            );
            transformedElement.props.ft = props.ft.map(point =>
                applyTransformToPoint(point, transform, bezierCenter)
            );
            // ÈáçÂª∫ËæÖÂä©Êï∞ÊçÆ
            BezierRebuild(transformedElement.props);
            break;

        case ElementTypes.FUNCTION:
            // ÂáΩÊï∞ÂÖÉÁ¥†ÔºöËÆ°ÁÆóËåÉÂõ¥‰∏≠ÂøÉ‰Ωú‰∏∫Âá†‰Ωï‰∏≠ÂøÉ
            const funcCenter = [(props.range[0] + props.range[1]) / 2, 0];
            // ÂèòÊç¢ÊâÄÊúâÈááÊ†∑ÁÇπ
            transformedElement.props.points = props.points.map(point =>
                applyTransformToPoint(point, transform, funcCenter)
            );
            break;

        default:
            break;
    }

    return transformedElement;
}

// Ê†πÊçÆÂΩìÂâçÊ†áÁ≠æÈ°µÂ∫îÁî®ÈÉ®ÂàÜÂèòÊç¢
function applyCurrentTabTransform(element) {
    if (!element.transform || !uiPropertyCurrentTab) return element;

    // ÂàõÂª∫ÈªòËÆ§ÁöÑÂÆåÊï¥ÂèòÊç¢ÁªìÊûÑ
    const partialTransform = {
        flip: {
            observePos: [0, 0],
            observeDir: null,
            observePosLSConstrain: false,
            observeDirLSConstrain: false,
            forwardY: false,
            sideX: false
        },
        shear: {
            observePos: [0, 0],
            observeDir: null,
            observePosLSConstrain: false,
            observeDirLSConstrain: false,
            angleX: 0,
            angleY: 0,
            forwardY: 0,
            sideX: 0
        },
        rotation: {
            observePos: [0, 0],
            observePosLSConstrain: false,
            angle: 0
        },
        scale: {
            observePos: [0, 0],
            observePosLSConstrain: false,
            x: 1,
            y: 1
        },
        translation: [0, 0]
    };

    // Ê†πÊçÆÂΩìÂâçÊ†áÁ≠æÈ°µÂ∫îÁî®ÂØπÂ∫îÁöÑÂèòÊç¢
    switch (uiPropertyCurrentTab) {
        case 'props':
            return element;
        case 'flip':
            partialTransform.flip = element.transform.flip;
            break;
        case 'shear':
            partialTransform.shear = element.transform.shear;
            break;
        case 'rotation':
            partialTransform.rotation = element.transform.rotation;
            break;
        case 'scale':
            partialTransform.scale = element.transform.scale;
            break;
        case 'translation':
            partialTransform.translation = element.transform.translation;
            break;
    }

    // ÂàõÂª∫‰∏¥Êó∂ÂÖÉÁ¥†Áî®‰∫éÂèòÊç¢
    const tempElement = JSON.parse(JSON.stringify(element));
    tempElement.transform = partialTransform;

    return applyTransformToElement(tempElement);
}

// ÁªòÂà∂ÂÆåÊï¥ÂèòÊç¢ÁöÑÂº±ÂåñÈ¢ÑËßà
function drawTransformPreview(element) {
    if (!element.transform) return;

    const fullTransformedElement = applyTransformToElement(element);

    ctx.save();

    // ËÆæÁΩÆÂº±ÂåñÊ†∑Âºè
    ctx.globalAlpha = 0.3; // 30% ÈÄèÊòéÂ∫¶
    ctx.strokeStyle = '#999999'; // ÁÅ∞Ëâ≤
    ctx.fillStyle = '#999999';
    ctx.setLineDash([2, 2]); // ËôöÁ∫øÊ†∑Âºè

    // Ê†πÊçÆÂÖÉÁ¥†Á±ªÂûãÁªòÂà∂È¢ÑËßà
    const [props, attrs] = [fullTransformedElement.props, fullTransformedElement.attrs || {}];
    switch (fullTransformedElement.type) {
        case ElementTypes.POINT:
            drawPoint(props, attrs);
            break;
        case ElementTypes.SEG:
            drawSeg(props, attrs);
            break;
        case ElementTypes.RECTANGLE:
            drawPolygon(props, attrs); // ÂèòÊç¢ÂêéÁöÑÁü©ÂΩ¢ÂèòÊàêÂ§öËæπÂΩ¢
            break;
        case ElementTypes.CIRCLE:
            drawCircle(props, attrs);
            break;
        case ElementTypes.ARC:
            drawArc(props, attrs);
            break;
        case ElementTypes.POLYGON:
            drawPolygon(props, attrs);
            break;
        case ElementTypes.EASE:
            drawEase(props, attrs);
            break;
        case ElementTypes.BEZIER:
            drawBezier(props, attrs);
            break;
        case ElementTypes.FUNCTION:
            drawFunction(props, attrs);
            break;
    }

    ctx.restore();
}

/* ================================ */
/* ÂÖÉÁ¥†ËßÇÊµã */
/* ================================ */

// Ëé∑ÂèñËßÇÊµãÁöÑÁÇπ‰∏éÂÖÉÁ¥†ÁöÑÁõ∏ÂØπÂÖ≥Á≥ª
function getObserveRelativity(p, element) {

    const props = element.props;
    switch (selectedElement.type) {
        case ElementTypes.POINT:
            return [props.coords[0], props.coords[1], sameOfPoints(p, props.coords) ? 0 : 1];
        case ElementTypes.SEG:
            return ptBesideSeg(p, props.ft[0], props.ft[1]);
        case ElementTypes.RECTANGLE:
            return ptBesideRectangle(p, props.box[2], props.box[3], props.box[4], props.box[5]);
        case ElementTypes.CIRCLE:
            return ptBesideCircle(p, props.centroid, props.radius);
        case ElementTypes.ARC:
            return ptBesideArc(p, props.ft[0], props.radius, props.startRad, props.endRad, props.ft[1], props.ft[2], props.aux);
        case ElementTypes.POLYGON:
            return ptBesidePolygon(p, props.ft, props.aux);
        case ElementTypes.EASE:
            return ptBesideEase(p, props.ft[0], props.ft[1], props.amp, props.func, props.aux, props.convex);
        case ElementTypes.BEZIER:
            return ptBesideBezier(p, props.controls, props.convex);
        default:
            return null;
    }
}

// Ê£ÄÊµãÈº†Ê†áÊòØÂê¶ÁÇπÂáªÂú®ËßÇÊµãÁÇπ‰∏ä
function observePointHitTest(mouseX, mouseY) {

    // Âè™Êúâ flip/shear/rotation/scale ÂèòÊç¢ÊâçÊúâËßÇÊµãÁÇπ
    if (!selectedElement || !observingPointInScreen)
        return false;

    // Áõ¥Êé•‰ΩøÁî®È¢ÑËÆ°ÁÆóÁöÑÂ±èÂπïÂùêÊ†áËÆ°ÁÆóË∑ùÁ¶ª
    const distance = Math.sqrt(
        Math.pow(mouseX - observingPointInScreen[0], 2) +
        Math.pow(mouseY - observingPointInScreen[1], 2)
    );

    // ÁÇπÂáªËåÉÂõ¥Ôºà‰ΩøÁî®ÂÖ®Â±ÄÈÖçÁΩÆÁöÑÂçäÂæÑÔºâ
    return distance <= OBSERVE_POINT_HIT_RADIUS;
}

// ËÆæÁΩÆËßÇÊµãÁÇπ‰ΩçÁΩÆÔºàÊîØÊåÅÂ±ÄÂüüÂØπÁß∞ÊÄßÁ∫¶ÊùüÔºâ
function setObservePointTo(p) {

    if (!selectedElement || !observingPoint) return;

    // ÂÖàÊ£ÄÊü•ÂÖÉÁ¥†Á±ªÂûãÂ∏∏Èáè
    let relativity = getObserveRelativity(p, selectedElement);
    if (!relativity) return;

    // Â¶ÇÊûúÂêØÁî®Â±ÄÂüüÂØπÁß∞ÊÄßÁ∫¶ÊùüÔºå‰∏îÁõÆÊ†áÁÇπÂ∑≤ÁªèÂú®ÂÖÉÁ¥†ËæπÁïåÊàñÂ§ñÈÉ®
    if (constrainObservePosLocalSymmetry && relativity[2] >= 0) {
        observingPoint = relativity;
        observingPoint[2] = 0; // Âº∫Âà∂ËÆæ‰∏∫ËæπÁïåÁÇπ
    }
    else {
        observingPoint[0] = p[0]; observingPoint[1] = p[1];
        observingPoint[2] = relativity[2];
    }

    // Â¶ÇÊûúÁÇπÂú®ÂÖÉÁ¥†Â§ñÈÉ®ÔºåÂàôËÆ°ÁÆóÂ±ÄÂüüÂØπÁß∞ÊÄßÁ∫¶ÊùüËåÉÂõ¥
    observingRelevant = relativity[2] > 0 ? observeDirectionRangeForLocalSymmetry(observingPoint, selectedElement) : null;

    // Êõ¥Êñ∞ÂØπÂ∫îÁ±ªÂûãÁöÑËßÇÊµãÁÇπÂùêÊ†á
    let transform = null, input;
    switch (activeTransform) {
        case TRANSFORM.FLIP:
            transform = selectedElement.transform.flip;
            input = document.getElementById('flipObserveD');
            uiSetInputValue(document.getElementById('flipObserveX'), observingPoint[0]);
            uiSetInputValue(document.getElementById('flipObserveY'), observingPoint[1]);
            break;
        case TRANSFORM.SHEAR:
            transform = selectedElement.transform.shear;
            input = document.getElementById('shearObserveD');
            uiSetInputValue(document.getElementById('shearObserveX'), observingPoint[0]);
            uiSetInputValue(document.getElementById('shearObserveY'), observingPoint[1]);
            break;
        case TRANSFORM.ROTATION:
            uiSetInputValue(document.getElementById('rotationObserveX'), observingPoint[0]);
            uiSetInputValue(document.getElementById('rotationObserveY'), observingPoint[1]);
            break;
        case TRANSFORM.SCALE:
            uiSetInputValue(document.getElementById('scaleObserveX'), observingPoint[0]);
            uiSetInputValue(document.getElementById('scaleObserveY'), observingPoint[1]);
            break;
    }

    // Êõ¥Êñ∞Â±èÂπïÂùêÊ†áÁºìÂ≠ò
    observingPointInScreen = mathToScreen(observingPoint[0], observingPoint[1]);

    // ÂØπ‰∫éÂíåËßÇÊµãÊñπÂêëÊúâÂÖ≥ÁöÑÂèòÊç¢ÔºåÂ¶ÇÊûúËßÇÊµãÁÇπÂú®Â§ñÈÉ®ÔºåÂàôÊõ¥Êñ∞ËßÇÊµãÊñπÂêëÁ∫¶Êùü
    if (transform && relativity[2] > 0 && constrainObserveDirLocalSymmetry) {
        if (transform.observeDir !== null) {
            const constrained = observeDirectionConstrain(transform.observeDir);
            if (constrained !== transform.observeDir) {
                transform.observeDir = constrained;
                uiSetObserveDirInputValue(input, constrained);
            }
        }
    }

    // Â∫îÁî®ÂèòÊç¢
    applyTransformToElement(selectedElement);

    // ‰ΩøÁî®‰ºòÂåñÁöÑÂáΩÊï∞Êõ¥Êñ∞Â±ÄÈÉ®ÂØπÁß∞Á∫¶ÊùüÊúâÊïàÊÄß
    uiUpdateObserveDirLocalSymmetryConstrainValid();

    draw();
}

// ËÆ°ÁÆóÊª°Ë∂≥Â±ÄÈÉ®ÂØπÁß∞ÊÄßÁöÑÊñπÂêëËåÉÂõ¥ÔºåÂâçÊèêÊòØËßÇÊµãÁÇπ‰Ωç‰∫éÂÖÉÁ¥†Â§ñÈÉ®
function observeDirectionRangeForLocalSymmetry() {

    // ËßÇÊµãÁÇπÂøÖÈ°ªÂú®ÂÖÉÁ¥†Â§ñÈÉ®
    if (!selectedElement || !observingPoint || observingPoint[2] <= 0) return null;

    const props = selectedElement.props;
    switch (selectedElement.type) {
        case ElementTypes.SEG: return ptFaceSeg(observingPoint, props.ft[0], props.ft[1]);
        case ElementTypes.RECTANGLE: return ptFaceRectangle(observingPoint, props.box[2], props.box[3], props.box[4], props.box[5]);
        case ElementTypes.CIRCLE: return ptFaceCircle(observingPoint, props.centroid, props.radius);
        case ElementTypes.ARC: return ptFaceArc(observingPoint, props.ft[0], props.radius, props.startRad, props.endRad);
        case ElementTypes.POLYGON: return ptFacePolygon(observingPoint, props.centroid, props.convex);
        case ElementTypes.EASE: return ptFaceEase(observingPoint, props.centroid, props.convex);
        case ElementTypes.BEZIER: return ptFaceBezier(observingPoint, props.centroid, props.convex);
        default: return null;
    }
}

// Á∫¶ÊùüËßÇÊµãÊñπÂêë„ÄÇÊ≥®ÊÑèÔºåËøôÈáåÂπ∂‰∏çË¶ÅÊ±ÇËßÇÊµãÁÇπÂú®ÂÖÉÁ¥†Â§ñÈÉ®
function observeDirectionConstrain(angle) {

    // ËßÑËåÉÂåñËßíÂ∫¶Âà∞ -180 Âà∞ 180
    angle = normDegS(angle);

    // Êó†Á∫¶ÊùüËåÉÂõ¥ÊàñËßÇÊµãÁÇπÂú®ÂÜÖÈÉ®
    if (observingRelevant === null) {
        return angle;
    }

    const [l, r] = observingRelevant;
    if (l === r) return l; // ÈÄÄÂåñ‰∏∫ÂêåÂêë

    // Â¶ÇÊûú l, r ËåÉÂõ¥Êú™Âá∫Áé∞Ë∑®Âë®ÊúüÁöÑÊÉÖÂÜµ
    // + Ê≠£Â∏∏ÊÉÖÂÜµ‰∏ã l > rÔºåÂõ†‰∏∫ËøôÈáåÁöÑÊñπÂêëÊòØËßÇÊµãÁÇπÁúãÂêëÂÖÉÁ¥†ÁöÑÊñπÂêëÔºåÊâÄ‰ª•Â∑¶ÂàáÁ∫øÁõ∏ÊØîÂè≥ÂàáÁ∫øÊòØÈÄÜÊó∂ÈíàÊñπÂêë
    if (l > r) {
        // Â¶ÇÊûúÂú®ËåÉÂõ¥ÂÜÖÔºåÁõ¥Êé•ËøîÂõû
        if (angle >= r && angle <= l) return angle;
    }
    // Ë∑®Âë®ÊúüÊÉÖÂÜµ‰∏ãÔºåÊ≠§Êó∂ l < 0Ôºå r > 0
    else if (angle <= l || angle >= r) return angle;

    const dist1 = Math.abs(normDegS2(angle - l));
    const dist2 = Math.abs(normDegS2(angle - r));
    angle = dist1 < dist2 ? l : r;

    return angle;
}

// Ëé∑ÂèñËßÇÊµãÊñπÂêë
function getObserveDirection(transform) {

    if (transform.observeDir !== null) {
        return transform.observeDir;
    }

    // observeDir ‰∏∫ null Êó∂ÔºåËá™Âä®ËÆ°ÁÆóÊñπÂêëËßíÂ∫¶
    if (transform.observePos && selectedElement) {
        const elementCenter = selectedElement.type === ElementTypes.POINT
            ? selectedElement.props.coords
            : selectedElement.props.centroid;
        if (sameOfPoints(transform.observePos, elementCenter)) return 0;
        return dirOfPoints(transform.observePos, elementCenter);
    }

    // ÈªòËÆ§ËøîÂõû 0 Â∫¶
    return 0;
}

// ‰ªéÁÇπÂáª‰ΩçÁΩÆËÆæÁΩÆËßÇÊµãÊñπÂêë
function setObserveDirectionToPoint(x, y) {
    if (!selectedElement || !observingPoint || !observingPointInScreen) return false;

    // Áõ¥Êé•‰ΩøÁî®È¢ÑËÆ°ÁÆóÁöÑÂ±èÂπïÂùêÊ†áËÆ°ÁÆóËßíÂ∫¶
    const dx = x - observingPointInScreen[0];
    const dy = y - observingPointInScreen[1];
    let angle = Math.atan2(-dy, dx) * R2D; // Ë¥üdyÂõ†‰∏∫ÁîªÂ∏ÉYËΩ¥Âêë‰∏ã

    // Â∫îÁî®Â±ÄÂüüÂØπÁß∞ÊÄßÁ∫¶ÊùüÔºàÂ¶ÇÊûúÂêØÁî®Ôºâ- ‰ΩøÁî®ÁºìÂ≠òÂèòÈáè
    if (constrainObserveDirLocalSymmetry) {
        angle = observeDirectionConstrain(angle);
    }

    // Ê†πÊçÆÂΩìÂâçÊ¥ªË∑ÉÂèòÊç¢Á±ªÂûãÊõ¥Êñ∞ÂØπÂ∫îÁöÑÊï∞ÊçÆÂíåUI
    switch (activeTransform) {
        case TRANSFORM.FLIP:
            selectedElement.transform.flip.observeDir = angle;
            uiSetObserveDirInputValue(document.getElementById('flipObserveD'), angle);
            break;
        case TRANSFORM.SHEAR:
            selectedElement.transform.shear.observeDir = angle;
            uiSetObserveDirInputValue(document.getElementById('shearObserveD'), angle);
            break;
        default:
            return false;
    }

    // Â∫îÁî®ÂèòÊç¢
    applyTransformToElement(selectedElement);

    return true;
}

/* ================================ */
/* ÊäïÂΩ±‰∏éË∑üË∏™Á≥ªÁªü */
/* ================================ */

// ËÆ°ÁÆóÈº†Ê†á‰ΩçÁΩÆÂú®ÈÄâ‰∏≠ÂÖÉÁ¥†‰∏äÁöÑÊäïÂΩ±ÁÇπ
// + ÊäïÂΩ±ÊåáÁöÑÊòØÈº†Ê†áÁÇπ‰∏éÂÖÉÁ¥†ÊúÄ‰∏¥ËøëÁöÑÁÇπ
function calculateTrackingPoint(mathX, mathY) {
    if (!selectedElement || !selectedElement.visible) {
        return null;
    }

    // ËæìÂÖ•ÁöÑmathX, mathYÂ∑≤ÁªèÊòØÊï∞Â≠¶ÂùêÊ†áÁ≥ª‰∏≠ÁöÑÂùêÊ†á
    const props = selectedElement.props, p = [mathX, mathY];
    switch (selectedElement.type) {
        case ElementTypes.SEG:
            return projectOnSeg(p, props.ft[0], props.ft[1]);
        case ElementTypes.RECTANGLE:
            return projectOnRectangle(p, props.box[2], props.box[3], props.box[4], props.box[5]); // left, top, right, bottom
        case ElementTypes.CIRCLE:
            return projectOnCircle(p, props.centroid, props.radius);
        case ElementTypes.ARC:
            return projectOnArc(p, props.ft[0], props.radius, props.startRad, props.endRad);
        case ElementTypes.POLYGON:
            return projectOnPolygon(p, props.ft);
        case ElementTypes.EASE:
            return projectOnEase(p, props.ft[0], props.ft[1], props.amp, props.func, props.aux);
        case ElementTypes.BEZIER:
            return projectOnBezier(p, props.controls);
        case ElementTypes.FUNCTION:
            return projectOnFunction(p, props.expr, props.range, getViewportRange());
        default:
            return null;
    }
}

// ËÆ°ÁÆóË∑üË∏™ÁÇπÂ§ÑÁöÑÂàáÁ∫ø
function calculateTrackingTangent() {
    if (!selectedElement || !projectingPoint) {
        projectionTangent = null;
        return;
    }

    const props = selectedElement.props;
    const p = projectingPoint;

    switch (selectedElement.type) {
        case ElementTypes.SEG:
            projectionTangent = tangentOfSeg(p, props.ft[0], props.ft[1]);
            break;
        case ElementTypes.RECTANGLE:
            projectionTangent = tangentOfRectangle(p, props.box);
            break;
        case ElementTypes.CIRCLE:
            projectionTangent = tangentOfCircle(p, props.centroid, props.radius);
            break;
        case ElementTypes.ARC:
            projectionTangent = tangentOfArc(p, props.ft[0], props.radius, props.startRad, props.endRad);
            break;
        case ElementTypes.POLYGON:
            projectionTangent = tangentOfPolygon(p, props.ft);
            break;
        case ElementTypes.EASE:
            projectionTangent = tangentOfEase(p, props);
            break;
        case ElementTypes.BEZIER:
            projectionTangent = tangentOfBezier(p, props);
            break;
        case ElementTypes.FUNCTION:
            projectionTangent = tangentOfFunction(p, props.expr, props.range, getViewportRange());
            break;
        default: projectionTangent = null;
    }

    if (projectionTangent === null) projectionTangent = undefined;  // ÁÇπÊó†Êïà
}

/* ================================ */
/* ÂáΩÊï∞ÁªòÂà∂ÂäüËÉΩ */
/* ================================ */

// RGB ËΩ¨ Hex ÁöÑÂ∑•ÂÖ∑ÂáΩÊï∞
function rgbToHex(rgb) {
    if (rgb.startsWith('#')) return rgb;
    const match = rgb.match(/\d+/g);
    if (!match) return rgb;
    const hex = (r, g, b) => '#' + [r, g, b].map(x => {
        const hex = parseInt(x).toString(16);
        return hex.length === 1 ? '0' + hex : hex;
    }).join('');
    return hex(match[0], match[1], match[2]);
}

// Hex ËΩ¨ RGB ÁöÑÂ∑•ÂÖ∑ÂáΩÊï∞
function hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
    } : null;
}

// È¢úËâ≤ÂåπÈÖçÂáΩÊï∞ - ÊîØÊåÅÂ§öÁßçÈ¢úËâ≤Ê†ºÂºèÁöÑÊØîËæÉ
function isColorMatch(color1, color2) {
    if (!color1 || !color2) return false;

    // Áõ¥Êé•Áõ∏Á≠âÊØîËæÉ
    if (color1 === color2) return true;

    // ‰∏çÂå∫ÂàÜÂ§ßÂ∞èÂÜôÊØîËæÉ
    if (color1.toLowerCase() === color2.toLowerCase()) return true;

    // ËΩ¨Êç¢‰∏∫hexÊ†ºÂºèÊØîËæÉ
    try {
        const hex1 = rgbToHex(color1);
        const hex2 = rgbToHex(color2);
        return hex1.toLowerCase() === hex2.toLowerCase();
    } catch (e) {
        return false;
    }
}

/* ================================ */
/* Á≥ªÁªü‰∫ã‰ª∂Â§ÑÁêÜ
/* ================================ */

// ÊªöËΩÆÂÆûÁé∞ÂùêÊ†áÁ≥ªÁº©ÊîæÊú∫Âà∂
canvas.addEventListener('wheel', function(e) {
    e.preventDefault();

    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    // ËÆ°ÁÆóÊñ∞ÁöÑÁº©ÊîæÂÄº (Âêë‰∏äÊªöÂä®ÊîæÂ§ßÔºåÂêë‰∏ãÊªöÂä®Áº©Â∞è)
    // ‰ΩøÁî®È¢ÑÂÆö‰πâÁöÑÊªöËΩÆÊñπÂêëÈÄÇÈÖçÂ∏∏Èáè
    const zoomFactor = WHEEL_ZOOM_DIRECTION
        ? (e.deltaY > 0 ? 1.1 : 0.9)  // deltaY > 0 Êó∂ÊîæÂ§ß
        : (e.deltaY > 0 ? 0.9 : 1.1); // deltaY > 0 Êó∂Áº©Â∞è

    const newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, scale * zoomFactor));
    if (newScale !== scale) {

        // ÂÆûÁé∞‰ª•Èº†Ê†á‰∏∫‰∏≠ÂøÉÁöÑÁº©ÊîæÈÄªËæë
        // + ËÆ°ÁÆóÁº©ÊîæÂâçÈº†Ê†áÂú®Êï∞Â≠¶ÂùêÊ†áÁ≥ª‰∏≠ÁöÑ‰ΩçÁΩÆ
        let mathX, mathY;

        // ÂéüÁÇπÂ±Ö‰∏≠Ê®°ÂºèÔºöÂéüÁÇπÂú®Â±èÂπï‰∏≠ÂøÉ
        if (coordinateState === COORDINATE_STATES.CENTERED) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            mathX = (mouseX - centerX) / (UNIT_SIZE * scale);
            mathY = (centerY - mouseY) / (UNIT_SIZE * scale);
        }
        // ÂéüÁÇπÂú®Â±èÂπï‰∏ãÊñπ‰∏≠Èó¥Ôºåy ËΩ¥ÂíåÂ∑¶‰∏ãËßí‰∏ÄÊ†∑Âä† offsetY
        else if (coordinateState === COORDINATE_STATES.BOTTOM_CENTER) {
            const centerX = canvas.width / 2;
            mathX = (mouseX - centerX) / (UNIT_SIZE * scale);
            mathY = (canvas.height + offsetY - mouseY) / (UNIT_SIZE * scale);
        }
        // ÂéüÁÇπÂ∑¶‰∏ãÊ®°ÂºèÔºö‰ΩøÁî®offsetËÆ°ÁÆó
        else {
            mathX = (mouseX - offsetX) / (UNIT_SIZE * scale);
            mathY = (canvas.height + offsetY - mouseY) / (UNIT_SIZE * scale);
        }

        scale = newScale;

        // ÈáçÊñ∞ËÆ°ÁÆóÂÅèÁßªÈáèÔºåÁ°Æ‰øùÈº†Ê†á‰ΩçÁΩÆÂØπÂ∫îÁöÑÊï∞Â≠¶ÂùêÊ†á‰øùÊåÅ‰∏çÂèò
        if (coordinateState === COORDINATE_STATES.CENTERED) {
            // ÂéüÁÇπÂ±Ö‰∏≠Ê®°ÂºèÔºö‰øùÊåÅÂéüÁÇπÂ±Ö‰∏≠Ôºå‰∏çÈúÄË¶ÅË∞ÉÊï¥offset
            offsetX = canvas.width / 2;
            offsetY = -canvas.height / 2;
        } else if (coordinateState === COORDINATE_STATES.BOTTOM_CENTER) {
            // ÂéüÁÇπÂú®Â±èÂπï‰∏ãÊñπ‰∏≠Èó¥
            offsetX = canvas.width / 2;
            offsetY = 0;
        } else {
            // ÂéüÁÇπÂ∑¶‰∏ãÊ®°ÂºèÔºöË∞ÉÊï¥offset‰ª•‰øùÊåÅÈº†Ê†á‰ΩçÁΩÆ‰∏çÂèò
            offsetX = mouseX - mathX * UNIT_SIZE * scale;
            offsetY = mouseY - canvas.height + mathY * UNIT_SIZE * scale;
        }

        syncScreenCoords();
        
        // Ê†áËÆ∞ÂùêÊ†áÁ≥ªÁºìÂ≠òÈúÄË¶ÅÊõ¥Êñ∞ÔºàÁº©ÊîæÂèòÂåñÔºâ
        invalidateCoordinateCache();
        
        draw();

        // Êõ¥Êñ∞ÁºìÂ≠òÁöÑÂõæÂΩ¢ÁÇπÔºàÁº©ÊîæÂêéÈáçÊñ∞ÁîüÊàê‰ª•ÊèêÈ´òÁ≤æÂ∫¶Ôºâ
        setTimeout(() => invalidateDrawCache(true), 30); // Âª∂ËøüÊõ¥Êñ∞ÈÅøÂÖçÈ¢ëÁπÅËÆ°ÁÆó
    }
});

/**
 * ÂêØÂä®Èº†Ê†áÊçïËé∑
 * ÂΩìÂºÄÂßãÊãñÊãΩÊó∂ÔºåÂú® document ‰∏äÁªëÂÆö mousemove Âíå mouseup ‰∫ã‰ª∂
 * ËøôÊ†∑Âç≥‰ΩøÈº†Ê†áÁßªÂá∫ canvas ÁîöËá≥ÊµèËßàÂô®Á™óÂè£Ôºå‰ªçËÉΩÊé•Êî∂Âà∞‰∫ã‰ª∂
 */
function startMouseCapture() {
    if (capturedMouseMove || capturedMouseUp) {
        return; // Â∑≤ÁªèÂú®ÊçïËé∑‰∏≠
    }
    
    // ÂàõÂª∫ mousemove Â§ÑÁêÜÂáΩÊï∞ÔºàÂ§çÁî® canvas ÁöÑ mousemove ÈÄªËæëÔºâ
    capturedMouseMove = function(e) {
        // Â§ÑÁêÜÊãñÊãΩÊàñÁªòÂà∂Áä∂ÊÄÅ
        if (!dragging && drawing !== DRAWING.AUX_LINE) return;
        
        // ËÆ°ÁÆóÈº†Ê†áÂú®ÂùêÊ†áÁ≥ª‰∏≠ÁöÑ‰ΩçÁΩÆ
        const rect = canvas.getBoundingClientRect();
        mouseMath = screenToMath(mouseScreenX = e.clientX - rect.left, mouseScreenY = e.clientY - rect.top);
        if (isShiftPressed) { mouseMath[0] |= 0; mouseMath[1] |= 0; }
        
        // Â§ÑÁêÜÁªòÂà∂ËæÖÂä©Á∫ø
        if (drawing === DRAWING.AUX_LINE) {
            draw(); // ÈáçÁªò‰ª•ÊòæÁ§∫Ë∑üÈöèÈº†Ê†áÁöÑËæÖÂä©Á∫ø
            return;
        }
        
        let dx, dy;
        switch (dragging) {
            case DRAGGING.COORDS:  // ÂùêÊ†áÁ≥ªÊãñÊãΩÂ§ÑÁêÜÔºàZ + Â∑¶ÈîÆÊãñÊãΩÔºâ
                if (!isKeyZPressed) break;
                
                dx = e.clientX - dragDownClientX;
                dy = e.clientY - dragDownClientY;
                
                offsetX = dragOffsetX + dx;
                offsetY = dragOffsetY + dy;
                
                if (!window.cacheUpdatePending) {
                    window.cacheUpdatePending = true;
                    setTimeout(() => {
                        invalidateDrawCache();
                        window.cacheUpdatePending = false;
                    }, 30);
                }
                
                invalidateCoordinateCache();
                syncScreenCoords();
                
                const elementsPanel = document.querySelector('.elements-panel');
                const propertyPanel = document.querySelector('.property-panel');
                if (offsetX >= canvas.width / 2) {
                    elementsPanel?.classList.add('left-align');
                    propertyPanel?.classList.add('left-align');
                } else {
                    elementsPanel?.classList.remove('left-align');
                    propertyPanel?.classList.remove('left-align');
                }
                
                draw();
                break;
                
            case DRAGGING.ELEMENT:  // ÂÖÉÁ¥†ÊãñÊãΩÂ§ÑÁêÜ
                dx = mouseMath[0] - dragStart[0];
                dy = mouseMath[1] - dragStart[1];
                
                // Ë∞ÉÁî® moveElement Á°Æ‰øùÊâÄÊúâÂ±ûÊÄßÈÉΩË¢´Ê≠£Á°ÆÊõ¥Êñ∞
                moveElement(dragElement, dragCenterX + dx, dragCenterY + dy);
                break;
                
            case DRAGGING.OBSERVE_POINT:  // ËßÇÊµãÁÇπÊãñÊãΩÂ§ÑÁêÜ
                observePoint = mouseMath;
                updateTransformMatrixFromObservePoint();
                
                if (!window.cacheUpdatePending) {
                    window.cacheUpdatePending = true;
                    setTimeout(() => {
                        invalidateDrawCache();
                        window.cacheUpdatePending = false;
                    }, 30);
                }
                
                draw();
                break;
        }
    };
    
    // ÂàõÂª∫ mouseup Â§ÑÁêÜÂáΩÊï∞
    capturedMouseUp = function(e) {
        if (e.button !== 0) return; // Âè™Â§ÑÁêÜÂ∑¶ÈîÆ
        
        // ÊãñÊãΩÁªìÊùü
        if (dragging === DRAGGING.COORDS || dragging === DRAGGING.ELEMENT || dragging === DRAGGING.OBSERVE_POINT) {
            e.preventDefault();
            e.stopPropagation();
            dragging = 0;
            stopMouseCapture();
            
            // ÊÅ¢Â§çÂÖâÊ†á
            if (uiDrawMenuShown || selectedElement) {
                canvas.style.cursor = 'default';
            } else {
                canvas.style.cursor = isShiftPressed ? 'none' : getCrosshair();
            }
            return;
        }
        
        // ËæÖÂä©Á∫øÁªòÂà∂ÁªìÊùü
        if (drawing === DRAWING.AUX_LINE) {
            e.preventDefault();
            e.stopPropagation();
            handleAuxLineDrawingEnd(e);
            return;
        }
    };
    
    // ÁªëÂÆöÂà∞ document
    document.addEventListener('mousemove', capturedMouseMove, true);
    document.addEventListener('mouseup', capturedMouseUp, true);
}

/**
 * ÂÅúÊ≠¢Èº†Ê†áÊçïËé∑
 * ÁßªÈô§ document ‰∏äÁöÑ‰∫ã‰ª∂ÁõëÂê¨Âô®
 */
function stopMouseCapture() {
    if (capturedMouseMove) {
        document.removeEventListener('mousemove', capturedMouseMove, true);
        capturedMouseMove = null;
    }
    if (capturedMouseUp) {
        document.removeEventListener('mouseup', capturedMouseUp, true);
        capturedMouseUp = null;
    }
}

/* ÂÆûÁé∞ÂäüËÉΩ:
 * + Â∑¶ÈîÆÔºà‰ºòÂÖàÁ∫ßÁî±È´òÂà∞‰ΩéÔºâ
 *   > Êåâ‰Ωè Ctrl ÈîÆ + ÊãñÊãΩ ÁîªÂ∏ÉÔºåÁßªÂä®ÂùêÊ†áÁ≥ª
 *   > ÊãñÊãΩËßÇÊµãÁÇπÔºàÂèòÊç¢Èù¢ÊùøÊâìÂºÄÊó∂Ôºâ
 *   > Â∑¶ÈîÆÂçïÂáªÂèñÊ∂àÈÄâÊã©ÂÖÉÁ¥†
 *   > Êåâ‰Ωè Alt ÈîÆ + ÁÇπÂáªÔºåÁªòÂà∂Êñ∞ÁöÑÂ§öËæπÂΩ¢
 *   > ÈªòËÆ§ÂêØÂä®Êñ∞ÁöÑÊãñÊãΩÁªòÂà∂
 * + Âè≥ÈîÆÔºà‰ºòÂÖàÁ∫ßÁî±È´òÂà∞‰ΩéÔºâ
 *   > Âè≥ÈîÆÂçïÁÇπÂáªÈÄâÊã©ÂÖÉÁ¥†
 *   > Ctrl + Âè≥ÈîÆÊãñÊãΩÁßªÂä®ÂÖÉÁ¥†
 *   > Âè≥ÈîÆÂèåÁÇπÂáªËΩÆËØ¢ÈÄâÊã©ÈáçÂè†ÂÖÉÁ¥†
 */
canvas.addEventListener('mousedown', function(e) {
    e.preventDefault(); e.stopPropagation();
    
    // ÈòªÊ≠¢Âè≥ÈîÆÁöÑÈªòËÆ§Ë°å‰∏∫ÂíåÊâãÂäøÔºàÈíàÂØπ Edge ÊµèËßàÂô®Ôºâ
    if (e.button === 2) {
        e.stopImmediatePropagation();
    }

    // Â¶ÇÊûúÂ∑≤ÁªèÂºπÂá∫‰∫ÜËèúÂçïÔºåÁÇπÂáª‰ºöËá™Âä®ÈöêËóèËèúÂçï
    if (!uiMenuPopping) {
        const menu = document.getElementById('drawMenu');
        if (menu.style.display !== 'none' && !UIMenuHitTest(e)) {
            UIHideGeometryMenu();

            // ÂêåÊó∂ÂèñÊ∂àÁªòÂà∂
            drawing = 0;
            draw();
        }
    }

    // Â§ÑÁêÜÂ∑¶ÈîÆÊåâ‰∏ã‰∫ã‰ª∂
    if (e.button === 0) {

        // Êåâ‰Ωè Z ÈîÆÔºà‰∏îÊú™Êåâ Alt ÈîÆÔºâ+ ÁÇπÂáªÔºåÊãñÊãΩÂùêÊ†áÁ≥ª
        // + Ctrl + Alt ‰∏∫Â∏ÆÂä©Âø´Êç∑ÈîÆ
        if (isKeyZPressed && !e.altKey) {
            dragging = DRAGGING.COORDS; dragDownClientX = e.clientX; dragDownClientY = e.clientY;
            dragOffsetX = offsetX; dragOffsetY = offsetY;
            canvas.style.cursor = getGrabbing();
            startMouseCapture(); // ÂêØÁî®Èº†Ê†áÊçïËé∑
            return;
        }

        // Ctrl + Â∑¶ÈîÆÈÄâÊã©/ÊãñÊãΩÂÖÉÁ¥†
        if (e.ctrlKey && !e.altKey) {
            // Ëé∑ÂèñÈº†Ê†áÁöÑÊï∞Â≠¶ÂùêÊ†á
            const rect = canvas.getBoundingClientRect();
            mouseMath = screenToMath(mouseScreenX = e.clientX - rect.left, mouseScreenY = e.clientY - rect.top);
            
            // Ê£ÄÊµãÊòØÂê¶‰∏∫ÂèåÂáªÔºà‰ΩøÁî®Â∑¶ÈîÆÂèåÂáªÁä∂ÊÄÅÔºâ
            const currentTime = Date.now();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const isDoubleClick = lastLeftClickTime &&
                (currentTime - lastLeftClickTime) < DOUBLE_CLICK_DELAY &&
                lastLeftClickPosition &&
                Math.abs(mouseX - lastLeftClickPosition[0]) < DOUBLE_CLICK_THRESHOLD &&
                Math.abs(mouseY - lastLeftClickPosition[1]) < DOUBLE_CLICK_THRESHOLD;
            
            // ÈÄâÊã©ÊàñËΩÆËØ¢ÈÄâÊã©ÈáçÂè†ÁöÑÂÖÉÁ¥†
            const elementToSelect = cycleUnderElement(mouseMath[0], mouseMath[1], isDoubleClick);
            
            // Â¶ÇÊûúÈÄâ‰∏≠‰∫ÜÂÖÉÁ¥†ÔºåÂºÄÂßãÊãñÊãΩ
            if (elementToSelect) {
                dragging = DRAGGING.ELEMENT; dragStart = mouseMath;
                canvas.style.cursor = getGrabbing();
                
                // ËÆ∞ÂΩïÊãñÊãΩÂÖÉÁ¥†ÂèäÂÖ∂‰∏≠ÂøÉ‰ΩçÁΩÆ
                dragElement = elementToSelect;
                const props = dragElement.props;
                if (dragElement.type === ElementTypes.POINT) {
                    dragCenterX = props.coords[0];
                    dragCenterY = props.coords[1];
                } else {
                    dragCenterX = props.box[0];
                    dragCenterY = props.box[1];
                }
                
                startMouseCapture(); // ÂêØÁî®Èº†Ê†áÊçïËé∑
                
                // Êõ¥Êñ∞ÂèåÂáªÊ£ÄÊµãÁä∂ÊÄÅ
                if (isDoubleClick) {
                    lastLeftClickTime = 0;
                } else {
                    lastLeftClickTime = currentTime;
                    lastLeftClickPosition = [mouseX, mouseY];
                }
                
                return;
            }
        }

        // ÂÖÉÁ¥†ÁªòÂà∂ËøáÁ®ã‰∏≠Á¶ÅÊ≠¢ÂÖ∂‰ªñÈº†Ê†á down Êìç‰ΩúÔºà‰∏ªË¶ÅÈÅøÂÖçÊñ∞ÁöÑÁªòÂà∂Ôºâ
        // + Ê≥®ÊÑèÔºåÂ§öËæπÂΩ¢ÁöÑÁªòÂà∂Ôºå‰ºöÈÄöËøá mousedown Êù•ÈÄâÁÇπÔºåÊâÄ‰ª•‰∏çÈòªÊñ≠
        //   Ê≠§Â§ñÔºåÂùêÊ†áÁ≥ªÁöÑÊãñÊãΩ‰∏çÂèó drawing Áä∂ÊÄÅÈôêÂà∂
        if (drawing > DRAWING.POLYGON)
            return;

        // Â¶ÇÊûú‰πãÂâçÂ§Ñ‰∫é < DRAWING.POLYGON Áä∂ÊÄÅÔºåÂàôÂâçÈù¢Â∑≤ÁªèÂ∞Ü drawing ÂèñÊ∂àÔºåÂç≥Â∞ÜÁªòÂà∂ËèúÂçïÈöêËóè
        console.assert(!drawing ||drawing === DRAWING.POLYGON);

        // Êåâ‰Ωè Alt ÈîÆÔºà‰∏îÊú™Êåâ Ctrl ÈîÆÔºâ+ ÁÇπÂáªÔºåÁªòÂà∂Êñ∞ÁöÑÂ§öËæπÂΩ¢
        // + Ctrl + Alt ‰∏∫Â∏ÆÂä©Âø´Êç∑ÈîÆ
        if (e.altKey && !e.ctrlKey) {
            handlePolygonDrawing(e);
            return;
        }
        console.assert(!drawing);
        if (drawing) return;

        // Ëé∑ÂèñÈº†Ê†áÂùêÊ†á
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        // Â¶ÇÊûúÂ±ûÊÄßÈù¢ÊùøÊâìÂºÄÔºåÁ¶ÅÊ≠¢ÂèñÊ∂àÂÖÉÁ¥†ÈÄâÊã©„ÄÅ‰ª•ÂèäÂàõÂª∫Êñ∞ÂÖÉÁ¥†
        if (uiPropertyPanelShown) {

            // Ê£ÄÊµãËßÇÊµãÁÇπÊãñÊãΩ
            if (observePointHitTest(mouseX, mouseY)) {
                dragging = DRAGGING.OBSERVE_POINT;
                canvas.style.cursor = getGrabbing();
                startMouseCapture(); // ÂêØÁî®Èº†Ê†áÊçïËé∑
            }

            return;
        }

        // ÁÇπÂáªÁîªÂ∏ÉÂèñÊ∂àÂÖÉÁ¥†ÈÄâ‰∏≠
        if (selectedElement) {
            uiUnselectElement();
        }

        // ËÆ∞ÂΩïËµ∑ÁÇπÔºåÂºÄÂßãÊñ∞ÁöÑÁªòÂà∂
        drawing = DRAWING.AUX_LINE;
        drawDown = [ mouseX, mouseY ]; // ËÆ∞ÂΩïÂàùÂßãÊåâ‰∏ã‰ΩçÁΩÆÔºàÁî®‰∫éÊ£ÄÊµãÊòØÂê¶ÁßªÂä®Ôºâ
        drawStart = screenToMath(mouseX, mouseY);
        startMouseCapture(); // ÂêØÁî®Èº†Ê†áÊçïËé∑
        return;
    }

/*    
    // Â§ÑÁêÜÂè≥ÈîÆÊåâ‰∏ã‰∫ã‰ª∂
    if (e.button !== 2) return;

    // ÂÖÉÁ¥†ÁªòÂà∂ËøáÁ®ã‰∏≠Á¶ÅÊ≠¢ÂÖ∂‰ªñÈº†Ê†á down Êìç‰ΩúÔºà‰∏ªË¶ÅÈÅøÂÖçÊìç‰ΩúÂÖ∂‰ªñÂÖÉÁ¥†Ôºâ
    if (drawing)
        return;

    // Ëé∑ÂèñÈº†Ê†áÁöÑÊï∞Â≠¶ÂùêÊ†á
    // + Ê≥®ÊÑèÔºåËøôÈáå‰∏çÈúÄË¶ÅËÄÉËôë Shift ÈîÆÁöÑÁΩëÊ†ºÂØπÈΩê
    const rect = canvas.getBoundingClientRect();
    mouseMath = screenToMath(mouseScreenX = e.clientX - rect.left, mouseScreenY = e.clientY - rect.top);

    // Ê£ÄÊµãÊòØÂê¶‰∏∫Âè≥ÈîÆÂèåÂáª
    const currentTime = Date.now();
    const isDoubleClick = lastRightClickTime &&
        (currentTime - lastRightClickTime) < DOUBLE_CLICK_DELAY &&
        Math.abs(mouseScreenX - lastRightClickX) < DOUBLE_CLICK_THRESHOLD &&
        Math.abs(mouseScreenY - lastRightClickY) < DOUBLE_CLICK_THRESHOLD;

    // Âè≥ÈîÆÁÇπÂáª/ÂèåÂáªÔºöÈÄâÊã©ÊàñËΩÆËØ¢ÈÄâÊã©ÈáçÂè†ÁöÑÂÖÉÁ¥†
    cycleUnderElement(mouseMath[0], mouseMath[1], isDoubleClick);

    // Âè≥ÈîÆÂè™Áî®‰∫éÈÄâÊã©ÂÖÉÁ¥†Ôºå‰∏çÂÜçÊîØÊåÅÊãñÊãΩÔºàÊãñÊãΩÂ∑≤Êîπ‰∏∫ Ctrl + Â∑¶ÈîÆÔºâ

    // Êõ¥Êñ∞Âè≥ÈîÆÂèåÂáªÊ£ÄÊµãÁä∂ÊÄÅ
    if (isDoubleClick) {
        lastRightClickTime = 0;
    } else {
        lastRightClickTime = currentTime;
        lastRightClickX = mouseScreenX;
        lastRightClickY = mouseScreenY;
    }
*/
});

/* ÂÆûÁé∞ÂäüËÉΩ:
 * + ÊãñÊãΩÊìç‰Ωú
 *   > ÊãñÊãΩËßÇÊµãÁÇπ
 *   > ÊãñÊãΩÂÖÉÁ¥†
 *   > ÊãñÊãΩÂùêÊ†áÁ≥ª
 * + ÂÆûÊó∂Áä∂ÊÄÅÁªòÂà∂ÔºàËÆ∞ÂΩïÈº†Ê†á‰ΩçÁΩÆÔºåÂπ∂Âá∫ÂèëÈáçÊñ∞ÁªòÂà∂Ôºâ
 *   > ÂºßÁ∫øÁªòÂà∂ËøáÁ®ã‰∏≠ÔºåÊõ¥Êñ∞ÂºßÁ∫øÁä∂ÊÄÅ
 *   > Ë¥ùÂ°ûÂ∞îÊõ≤Á∫øÁªòÂà∂ËøáÁ®ã‰∏≠ÔºåÊõ¥Êñ∞ÊéßÂà∂ÁÇπ‰ΩçÁΩÆ
 *   > ÂÖ∂‰ªñÁªòÂà∂‰∏≠Áä∂ÊÄÅÔºåÂ¶ÇËæÖÂä©Á∫ø„ÄÅÂ§öËæπÂΩ¢È¢ÑËßà
 *   > ÁªòÂà∂Ë∑üË∏™ÁÇπ
 *   > ÁªòÂà∂ËßÇÊµãÊñπÂêëËæÖÂä©Á∫ø
 *   > ÂØπÈΩêÂà∞ÁΩëÊ†ºÁöÑÈº†Ê†áÂõæÊ†áÁªòÂà∂
 * + Èº†Ê†áÊåáÁ§∫ÂõæÊ†áËÆæÁΩÆ
 *   > ÂèØÊãñÊãΩÁöÑËßÇÊµãÁÇπ
 *   > ÂèØÊãñÊãΩÁöÑÂÖÉÁ¥†
 */
canvas.addEventListener('mousemove', function(e) {

    // ËÆ°ÁÆóÈº†Ê†áÂú®ÂùêÊ†áÁ≥ª‰∏≠ÁöÑ‰ΩçÁΩÆ
    const rect = canvas.getBoundingClientRect();
    mouseMath = screenToMath(mouseScreenX = e.clientX - rect.left, mouseScreenY = e.clientY - rect.top);
    if (isShiftPressed) { mouseMath[0] |= 0; mouseMath[1] |= 0; } // Shift ÁΩëÊ†ºÂØπÈΩêÈîÆ

    // Êåâ‰Ωè CtrlÈîÆÊãñÊãΩÂùêÊ†áÁ≥ª„ÄÇÊ≥®ÊÑèÔºåÂç≥‰ΩøÂ§Ñ‰∫éÊãñÊãΩÊ®°ÂºèÔºå‰πüÂøÖÈ°ªÊåâ‰Ωè Ctrl ÈîÆÊâçËÉΩÊãñÊãΩ
    if (dragging) {

        let dx, dy;
        switch (dragging) {
            case DRAGGING.COORDS :  // ÂùêÊ†áÁ≥ªÊãñÊãΩÂ§ÑÁêÜÔºàZ + Â∑¶ÈîÆÊãñÊãΩÔºâ
                if (!isKeyZPressed) break;

                dx = e.clientX - dragDownClientX;
                dy = e.clientY - dragDownClientY;

                offsetX = dragOffsetX + dx;
                offsetY = dragOffsetY + dy; // YËΩ¥Âêë‰∏ã‰∏∫Ë¥ü

                // ÊãñÊãΩËøáÁ®ã‰∏≠ÔºåÈÅøÂÖçÂÆûÊó∂Êõ¥Êñ∞ÁºìÂ≠òÂõæÂΩ¢ÁöÑÈáçÊñ∞ÁªòÂà∂
                if (!window.cacheUpdatePending) { window.cacheUpdatePending = true;
                    setTimeout(() => {
                        invalidateDrawCache();
                        window.cacheUpdatePending = false;
                    }, 30);
                }

                // Ê†áËÆ∞ÂùêÊ†áÁ≥ªÁºìÂ≠òÈúÄË¶ÅÊõ¥Êñ∞ÔºàÂπ≥ÁßªÂèòÂåñÔºâ
                invalidateCoordinateCache();

                syncScreenCoords();
                
                // Ê£ÄÊü•ÂéüÁÇπ‰ΩçÁΩÆÔºåÂä®ÊÄÅÊõ¥Êñ∞Èù¢Êùø‰ΩçÁΩÆ
                // ÂΩìÂéüÁÇπ X ÂùêÊ†áÂ§ß‰∫éÁ≠â‰∫éÂ±èÂπï‰∏≠Á∫øÊó∂ÔºåÈù¢ÊùøÂàáÊç¢Âà∞Â∑¶‰æß
                const elementsPanel = document.querySelector('.elements-panel');
                const propertyPanel = document.querySelector('.property-panel');
                if (offsetX >= canvas.width / 2) {
                    elementsPanel?.classList.add('left-align');
                    propertyPanel?.classList.add('left-align');
                } else {
                    elementsPanel?.classList.remove('left-align');
                    propertyPanel?.classList.remove('left-align');
                }
                
                draw();
                break;
            case DRAGGING.ELEMENT : // ÂÖÉÁ¥†ÊãñÊãΩÂ§ÑÁêÜÔºàCtrl + Â∑¶ÈîÆÊãñÊãΩÔºâ
                if (!isCtrlPressed) break;

                console.assert(dragElement && dragStart);

                dx = mouseMath[0] - dragStart[0];
                dy = mouseMath[1] - dragStart[1]; // YËΩ¥Âêë‰∏ã‰∏∫Ë¥ü

                // ÁßªÂä®ÂÖÉÁ¥†Âà∞Êñ∞‰ΩçÁΩÆ
                moveElement(dragElement, dragCenterX + dx, dragCenterY + dy);

                draw();
                break;
            case DRAGGING.OBSERVE_POINT :
                if (observingPoint) setObservePointTo(mouseMath);
        }

        // ÊãñÊãΩÊó∂‰∏çÊâßË°åÂÖ∂‰ªñÈÄªËæë
        return;
    }

    if (drawing) {

        switch (drawing) {
            case DRAWING.ARC: // ÂºßÁ∫øÁªòÂà∂ËøáÁ®ã‰∏≠ÔºåÊõ¥Êñ∞ÂºßÁ∫øÁä∂ÊÄÅ
                if (arcStartPoint && arcEndPoint)
                    updateArcCenterPosition(mouseMath[0], mouseMath[1], isShiftPressed);
                break;
            case DRAWING.BEZIER:
                if (bezierStartPoint && bezierEndPoint) {
                    updateBezierControlPoint(mouseMath[0], mouseMath[1], isShiftPressed);
                }
        }

        draw();
        return;
    }

    if (selectedElement && isAltPressed) {

        if (projectingPoint) {

            projectingPoint = calculateTrackingPoint(mouseMath[0], mouseMath[1]);
            // Êåâ‰∏ã Alt ÈîÆÊó∂ÊÄªÊòØËÆ°ÁÆóÂàáÁ∫ø‰ø°ÊÅØÔºå‰ª•‰æøÈöèÊó∂ÂèØ‰ª•ÊòæÁ§∫ÂàáÁ∫ø/Ê≥ïÁ∫ø
            calculateTrackingTangent();

            draw(); // ÈáçÁªò‰ª•Êõ¥Êñ∞Ë∑üË∏™ÁÇπÁªòÂà∂
        }
        else if (observingDirection) {

            draw(); // ÈáçÁªò‰ª•Êõ¥Êñ∞ËßÇÊµãÊñπÂêëÁªòÂà∂
        }
        else if (!uiPropertyPanelShown || uiPropertyCurrentTab === "props") {

            projectingPoint = calculateTrackingPoint(mouseMath[0], mouseMath[1]);
            calculateTrackingTangent();

            draw(); // ÈáçÁªò‰ª•Êõ¥Êñ∞Ë∑üË∏™ÁÇπÁªòÂà∂
        }
        else if (uiPropertyCurrentTab === "flip" || uiPropertyCurrentTab === "shear") {

            observingDirection = true;

            draw(); // ÈáçÁªò‰ª•Êõ¥Êñ∞ËßÇÊµãÊñπÂêëÁªòÂà∂
        } else if (isShiftPressed) {

            draw(); // ÈáçÁªò‰ª•Êõ¥Êñ∞ÁΩëÊ†ºÂØπÈΩêÊåáÁ§∫ÁªòÂà∂
        }
    }
    else if (isShiftPressed) {

        draw(); // ÈáçÁªò‰ª•Êõ¥Êñ∞ÁΩëÊ†ºÂØπÈΩêÊåáÁ§∫ÁªòÂà∂
    }

    // ÈöêËóèÁ≥ªÁªü cursor Áî®‰ª•ÊòæÁ§∫ËôöÊãü cursor
    if (isShiftPressed) {
        if (canvas.style.cursor !== 'none')
            canvas.style.cursor = 'none';
        return;
    }

    // Èº†Ê†áÊåáÁ§∫ÂõæÊ†áËÆæÁΩÆÔºàÂç≥ÊåáÂêëÂèØ‰∫§‰∫íÂÖÉÁ¥†Êó∂Ôºâ
    function hittest() {

        // Â¶ÇÊûúÊåáÂêëËßÇÊµãÁÇπ
        if (observePointHitTest(mouseScreenX, mouseScreenY)) {
            return true;
        }

        // todo ÊåáÂêëË∑üË∏™ÁÇπ/ÁâπÂæÅÁÇπ

        // todo Â¶ÇÊûúÊåáÂêëÂÖÉÁ¥†

        return false;
    }

    canvas.style.cursor = hittest() ? 'pointer' : isShiftPressed ? 'none' : getCrosshair();
});

/* ÂÆûÁé∞ÂäüËÉΩ:
 * + ÊãñÊãΩÊìç‰ΩúÁªìÊùü
 *   > ÊãñÊãΩËßÇÊµãÁÇπ
 *   > ÊãñÊãΩÂÖÉÁ¥†
 *   > ÊãñÊãΩÂùêÊ†áÁ≥ª
 * + ÁªòÂà∂ÂÆåÊàêÔºåÂºπÂá∫ËèúÂçï
 */
canvas.addEventListener('mouseup', function(e) {

    function cursorRecover() {

        // ÂºπÂá∫ËèúÂçï„ÄÅÊàñÂ≠òÂú®ÈÄâ‰∏≠ÂÖÉÁ¥†Êó∂ÔºåÊÅ¢Â§çÈªòËÆ§ÊåáÈíà
        if (uiDrawMenuShown || selectedElement)
            canvas.style.cursor = 'default';
        else // ÊòæÁ§∫ÂçÅÂ≠óÂèâÔºåË°®Á§∫Êï∞Â≠¶ÂùêÊ†áÁ≥ªÔºàÂèØÁªòÂà∂Ôºâ„ÄÇÊ≠§Â§ñÔºåÂ¶ÇÊûúÂ§Ñ‰∫éÁΩëÊ†ºÂØπÈΩêÊ®°ÂºèÔºåÂàôÈöêËóèÈº†Ê†áÊåáÈíàÔºàËá™ÂÆö‰πâÁªòÂà∂ÂØπÈΩêÊåáÁ§∫Ôºâ
            canvas.style.cursor = isShiftPressed ? 'none' : getCrosshair();
    }

    // Â§ÑÁêÜÂ∑¶ÈîÆÊä¨Ëµ∑
    if (e.button === 0) {

        // ÂùêÊ†áÁ≥ª„ÄÅÂÖÉÁ¥†„ÄÅËßÇÊµãÁÇπÊãñÊãΩÁªìÊùüÂ§ÑÁêÜ
        if (dragging) {
            e.preventDefault();e.stopPropagation();
            dragging = 0;
            stopMouseCapture(); // ÈáäÊîæÈº†Ê†áÊçïËé∑
            cursorRecover();
            return;
        }

        // Â¶ÇÊûúÊ≠£Âú®ÁªòÂà∂ËæÖÂä©Á∫øÔºåËÆ∞ÂΩïÁªàÁÇπÂπ∂ÊòæÁ§∫ËèúÂçï
        if (drawing === DRAWING.AUX_LINE) {
            e.preventDefault();e.stopPropagation();
            handleAuxLineDrawingEnd(e);
        }

        return;
    }
});

// ÈòªÊ≠¢ÊãñÊãΩÊâãÂäøÔºàÈíàÂØπ Edge ÊµèËßàÂô®Âè≥ÈîÆÊâãÂäøÔºâ
canvas.addEventListener('dragstart', function(e) {
    e.preventDefault();
    e.stopPropagation();
    return false;
}, { capture: true });

// ÈòªÊ≠¢ÈÄâÊã©Ë°å‰∏∫ÔºàÈò≤Ê≠¢ÊãñÊãΩÊó∂ÈÄâ‰∏≠ÂÜÖÂÆπÔºâ
canvas.addEventListener('selectstart', function(e) {
    e.preventDefault();
    return false;
}, { capture: true });

canvas.addEventListener('mouseleave', function() {

    // Èº†Ê†áÁ¶ªÂºÄÁîªÂ∏ÉÊó∂Ê∏ÖÈô§Èº†Ê†á‰ΩçÁΩÆË∑üË∏™
     mouseMath = null;
     projectingPoint = projectionTangent = null;

    // Èº†Ê†áÁ¶ªÂºÄÊó∂ÂÅúÊ≠¢ÂÖÉÁ¥†ÊãñÊãΩ ?
    // if (dragging) { dragging = 0;
    //     canvas.style.cursor = 'default';
    // }

    // ÊòØÂê¶Ëá™Âä®ÈöêËóèÂ∑≤ÁªèÂºπÂá∫ÁöÑËèúÂçï ?
    // if (uiDrawMenuShown) {
    //     UIHideGeometryMenu();
    // }
});

// Á™óÂè£Â§±ÂéªÁÑ¶ÁÇπÊó∂ÂèñÊ∂àÂ§öËæπÂΩ¢ÁªòÂà∂
// Âõ†‰∏∫Â§öËæπÂΩ¢ÁªòÂà∂‰æùËµñÊåÅÁª≠Êåâ‰Ωè Alt ÈîÆÔºåÂ§±ÁÑ¶‰ºöÂØºËá¥ÈîÆÁõòÁä∂ÊÄÅ‰∏¢Â§±
window.addEventListener('blur', function() {
    if (drawing === DRAWING.POLYGON) {
        resetPolygonDrawing();
    }
    // ÂêåÊó∂ÈáçÁΩÆÊâÄÊúâÈîÆÁõòÁä∂ÊÄÅÔºåÈò≤Ê≠¢Áä∂ÊÄÅÂç°‰Ωè
    isAltPressed = false;
    isCtrlPressed = false;
    isShiftPressed = false;
    isKeyZPressed = false;
    // Ê∏ÖÈô§ÊâÄÊúâÈîÆÁõòÁõ∏ÂÖ≥ËÆ°Êó∂Âô®
    if (ctrlAltKeyHoldTimer) {
        clearTimeout(ctrlAltKeyHoldTimer);
        ctrlAltKeyHoldTimer = null;
    }
    if (keyClickTimer) {
        clearTimeout(keyClickTimer);
        keyClickTimer = null;
    }
});

/* ÂÆûÁé∞ÂäüËÉΩ:
 * > Alt ÈîÆ + ÁÇπÂáªÔºàÂú® flip/shear tab ‰∏ãÔºâËÆæÁΩÆËßÇÊµãÊñπÂêë
 * > Âú® arc/ease ÁªòÂà∂Ê®°Âºè‰∏ãÔºåÁÇπÂáªÂÆåÊàêÁªòÂà∂
 * > Âú® bezier ÁªòÂà∂Ê®°Âºè‰∏ãÔºåÁÇπÂáªÂàáÊç¢Âà∞‰∏ã‰∏Ä‰∏™ÊéßÂà∂ÁÇπÂíåÂÆåÊàêÁªòÂà∂
 * > ÂèåÂáªÂàõÂª∫ÁÇπÂÖÉÁ¥†
 */
canvas.addEventListener('click', function(e) {
/* + click ‰∫ã‰ª∂Áõ∏ÂΩì‰∫éÂú® mouseup Ëß¶ÂèëÔºåÁõ∏ÊØî‰∫é mousedown Ëß¶ÂèëÔºå
 |   ÂÆÉÊõ¥ÂÖ∑ÊúâÂéüÂ≠êËß¶ÂèëÁâπÊÄßÔºåÂç≥‰∏çÂÖ≥Ê≥®ËøáÁ®ãÔºåÂêåÊó∂ÂÖ∑ÊúâÂèØ‰ª•ÂèñÊ∂àÁöÑÊÑüËßâ
 | + Âè¶Â§ñÔºåËøôÈáåËá™ÂÆö‰πâÂÆûÁé∞‰∫ÜÂèåÂáªÊ£ÄÊµãÊú∫Âà∂ÔºåÁõ∏ÊØî‰∫éÂéüÁîüÁöÑ dblclick ‰∫ã‰ª∂Ôºå
 |   ËøôÈáåÂèØ‰ª•Ê†πÊçÆ click ‰∫ã‰ª∂ÁöÑËß¶ÂèëÊù°‰ª∂ÔºåÊù•ÂÜ≥ÂÆöÊòØÂê¶Ëß¶ÂèëÂèåÂáªË°å‰∏∫
*/
    e.preventDefault();
    e.stopPropagation();

    // Â±ûÊÄßÈù¢ÊùøÊâìÂºÄÊó∂ÔºåÊìç‰ΩúÁöÑÂ∫îËØ•ÈÉΩÊòØÂΩìÂâçÈÄâ‰∏≠ÁöÑÂÖÉÁ¥†
    if (uiPropertyPanelShown) {

        // Alt ÈîÆ + ÁÇπÂáªÔºåÔºàÂú® flip/shear tab ‰∏ãÔºâËÆæÁΩÆËßÇÊµãÊñπÂêë
        if (selectedElement && isAltPressed &&
            (uiPropertyCurrentTab === 'flip' || uiPropertyCurrentTab === 'shear')) {

            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left, mouseY = e.clientY - rect.top;

            // ËÆæÁΩÆËßÇÊµãÊñπÂêëÔºàÊ≥®ÊÑèÔºåËÆæÁΩÆÁöÑÊñπÂêëÁÇπ‰∏çËÉΩÂíåËßÇÊµãÁÇπÈáçÂêàÔºåÂê¶ÂàôÊñπÂêëÊó†ÊïàÔºâ
            // + Âè¶Â§ñÊ≥®ÊÑèÔºåÊµèËßàÂô®ÁöÑ click ‰∫ã‰ª∂Âπ∂‰∏çË¶ÅÊ±ÇÁÇπÂáªËêΩÁÇπÂíåËµ∑ÁÇπ‰∏ÄËá¥Ôºå‰πüÂ∞±ÊòØÊãñÊãΩÊä¨Ëµ∑ÂêéÔºå‰ªçÁÑ∂‰ºöËß¶Âèë click
            //   ‰πüÂ∞±ÊòØÊãñÊãΩËßÇÊµãÁÇπÊä¨Ëµ∑ÂêéÔºå‰πü‰ºöËß¶ÂèëËøôÈáåÁöÑÈÄªËæëÔºåÂØπÂ∫îÁöÑÂ∞±ÊòØÊñπÂêëÁÇπÂíåËßÇÊµãÁÇπ‰ºöÈáçÂêà
            // + ÊãñÊãΩÁªìÊùü mouseup ÂÖà‰∫é click Ëß¶ÂèëÔºåÊâÄ‰ª•ËøôÈáåÊó†Ê≥ïÁü•ÈÅìÊòØÂê¶ÊòØÊãñÊãΩÔºåÊ≠§Â§ñ mouseup
            if (!observePointHitTest(mouseX, mouseY) && setObserveDirectionToPoint(mouseX, mouseY)) {
                draw();
            }
        }

        return;
    }

    // ÊãñÊãΩÂùêÊ†áÁ≥ª‰∏ç‰ºöÊâìÊñ≠ÂÖÉÁ¥†ÁöÑÁªòÂà∂Êìç‰Ωú
    if (dragging) return;

    if (drawing) {

        // Âú®easeËÆæÁΩÆÊ®°Âºè‰∏ãÔºåÈº†Ê†áÁÇπÂáªÁ°ÆËÆ§ÁªòÂà∂
        if (drawing === DRAWING.EASE)
            completeEaseDrawing();

        // arc ÂÖÉÁ¥†ÁöÑÁªòÂà∂Ôºå‰ºöÂú®ÁÇπÂáªÊó∂ÂÆåÊàêÁªòÂà∂
        else if (drawing === DRAWING.ARC)
            completeArcDrawing();

        // Ë¥ùÂ°ûÂ∞îÊõ≤Á∫øÂÖÉÁ¥†ÁöÑÁªòÂà∂Ôºå‰ºöÂú®ÊúÄÂêé‰∏Ä‰∏™ÊéßÂà∂ÁÇπËäÇÁÇπÁÇπÂáªÊó∂ÂÆåÊàêÁªòÂà∂
        else if (drawing === DRAWING.BEZIER)
            handleBezierControlClick();

        return;
    }

    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left, mouseY = e.clientY - rect.top;

    // Ctrl ÈîÆÊåâ‰∏ãÊó∂Ôºå‰∏çËøõË°åÂèåÂáªÊ£ÄÊµãÔºàCtrl Áõ∏ÂÖ≥ÁöÑÂèåÂáªÂú® mousedown ‰∏≠Â§ÑÁêÜÔºâ
    if (!e.ctrlKey) {
        // Ê£ÄÊµãÊòØÂê¶‰∏∫Â∑¶ÈîÆÂèåÂáª
        const currentTime = Date.now();
        const isDoubleClick = lastLeftClickTime &&
            (currentTime - lastLeftClickTime) < DOUBLE_CLICK_DELAY &&
            Math.abs(mouseX - lastLeftClickX) < DOUBLE_CLICK_THRESHOLD &&
            Math.abs(mouseY - lastLeftClickY) < DOUBLE_CLICK_THRESHOLD;

        // Â¶ÇÊûúÊ≤°ÊúâÂÖ∂‰ªñÊìç‰ΩúÔºå‰∏îÊ£ÄÊµãÂà∞ÂèåÂáªÔºåÂàõÂª∫ÁÇπÂÖÉÁ¥†
        if (isDoubleClick) {

            let [mathX, mathY] = screenToMath(mouseX, mouseY);
            if (e.shiftKey) { mathX |= 0; mathY |= 0; } // Â¶ÇÊûúÊåâ‰Ωè Shift ÈîÆÔºåÂØπÈΩêÂà∞ÁΩëÊ†º

            createPoint(mathX, mathY);
            draw();
            
            // ÈáçÁΩÆÂèåÂáªÊ£ÄÊµãÔºàÈÅøÂÖçËøûÁª≠Ëß¶ÂèëÔºâ
            lastLeftClickTime = 0;
            return;
        }
        
        // Êõ¥Êñ∞Â∑¶ÈîÆÂèåÂáªÊ£ÄÊµãÁä∂ÊÄÅ
        lastLeftClickTime = currentTime;
        lastLeftClickX = mouseX;
        lastLeftClickY = mouseY;
    }
});

// Â±èËîΩÈº†Ê†áÂè≥ÈîÆÁ≥ªÁªüËèúÂçïÔºåÂêåÊó∂Â§ÑÁêÜÂè≥ÈîÆÂèñÊ∂àÂ§öËæπÂΩ¢ÁªòÂà∂
// + Ê≥®: ÊµèËßàÂô®ÁöÑÂè≥ÈîÆÁÇπÂáª‰∫ã‰ª∂Ë¢´ÈªòËÆ§ÂëΩÂêç‰∏∫ contextmenuÔºå‰∏îÂÆûÁé∞‰∫ÜÂºπÂá∫Á≥ªÁªüËèúÂçïÁöÑÂäüËÉΩ
canvas.addEventListener('contextmenu', function(e) {
    e.preventDefault();
    e.stopPropagation();
    e.stopImmediatePropagation();

    // Â¶ÇÊûúÂ∏ÆÂä©ÂØπËØùÊ°ÜÂèØËßÅÔºåÂÆåÂÖ®ÈòªÊ≠¢Âè≥ÈîÆËèúÂçïÂ§ÑÁêÜ
    if (uiHelpShown) {
        return false;
    }

    // Âè™Â§ÑÁêÜÁúüÊ≠£ÁöÑÂè≥ÈîÆÁÇπÂáª
    // + Âú®‰∏Ä‰∫õÁ≥ªÁªüÔºåÂ¶Ç Mac ‰∏äÔºåCtrl + Â∑¶ÈîÆ‰πü‰ºöËß¶ÂèëÂè≥ÈîÆËèúÂçï‰∫ã‰ª∂ÔºåËÄå Ctrl ËøôÈáåÁî®‰∫éÊãñÊãΩÂùêÊ†áÁ≥ª
    if (e.button !== 2) return;

    // Âè≥ÈîÆÂèñÊ∂àÂ§öËæπÂΩ¢ÁªòÂà∂„ÄÅÂºßÁ∫øÁªòÂà∂ÊàñË¥ùÂ°ûÂ∞îÊõ≤Á∫øÁªòÂà∂
    switch (drawing) {
        case DRAWING.POLYGON: resetPolygonDrawing(); break;
        case DRAWING.ARC: resetArcDrawing(); break;
        case DRAWING.EASE: resetEaseDrawing(); break;
        case DRAWING.BEZIER: resetBezierDrawing(); break;
        default: break;
    }
    
    return false;
}, { capture: true });

// ÈîÆÁõò‰∫ã‰ª∂ÂÖºÂÆπÊÄßÂ§ÑÁêÜÂáΩÊï∞
function getKeyFromEvent(e) {
    // ‰ºòÂÖà‰ΩøÁî®Áé∞‰ª£ÁöÑ e.key
    if (e.key) return e.key;
    // ÂØπ‰∫éÊóßÁâàÊµèËßàÂô®ÁöÑÂÖºÂÆπÊÄßÂ§ÑÁêÜ
    const keyMap = {
        16: 'Shift',
        17: 'Control',
        18: 'Alt',
        27: 'Escape',
        91: 'Meta', // Â∑¶ Command/Windows ÈîÆ
        93: 'Meta', // Âè≥ Command/Windows ÈîÆ
        224: 'Meta' // Firefox ‰∏≠ÁöÑ Command ÈîÆ
    };
    return keyMap[e.keyCode] || String.fromCharCode(e.keyCode);
}

window.addEventListener('keydown', function(e) {

    function clearClicking() {
        if (keyClickTimer) {
            clearTimeout(keyClickTimer);
            keyClickTimer = keyClicking = null;
        }
    }
    function startHelp() {

        clearClicking();
        isAltPressed = isCtrlPressed = true;
        isShiftPressed = false;

        if (ctrlAltKeyHoldTimer) {
            return;
        }

        // ÂêØÂä®Âª∂ËøüÂêØÂä®ËÆ°Êó∂Âô®
        // Ê≥®ÊÑèÔºö‰∏çÂú®ÂõûË∞É‰∏≠Ê£ÄÊü•ÊåâÈîÆÁä∂ÊÄÅÔºåÂõ†‰∏∫Ë∞ÉÁî®Ê≠§ÂáΩÊï∞Êó∂Â∑≤ÁªèÁ°ÆËÆ§‰∏§ÈîÆÈÉΩÊåâ‰∏ã
        ctrlAltKeyHoldTimer = setTimeout(function() {
            ctrlAltKeyHoldTimer = null;
            // Âª∂ËøüÂêéÂÜçÊ¨°Á°ÆËÆ§‰∏§ÈîÆ‰ªçÁÑ∂Êåâ‰∏ã‰∏îÂ∏ÆÂä©Êú™ÊòæÁ§∫
            if (isCtrlPressed && isAltPressed && !uiHelpShown) {
                UIShowHelpDialog();
            }
        }, CTRL_ALT_HOLD_DELAY);
    }

    // Á°Æ‰øùÂú®ÊâÄÊúâÊµèËßàÂô®‰∏≠Ê≠£Á°ÆÂ§ÑÁêÜÈîÆÁõò‰∫ã‰ª∂
    const key = getKeyFromEvent(e);

    // Â∏ÆÂä©ÂØπËØùÊ°ÜÊâìÂºÄÊó∂ÁöÑÂú∫ÊôØ
    if (uiHelpShown) { console.assert(isCtrlPressed);
        e.preventDefault();

        if (key === 'Escape') {
            if (!window.preventHelpClose) UIHideHelpDialog();
        }
        else if (key === 'Alt') {

            // Ê≥®ÊÑèÔºåÂØπ‰∫é Êüê‰∫õÊµèËßàÂô®ÔºàÂ¶Ç EdgeÔºâÔºåÂΩìÈïøÊåâ‰∏Ä‰∏™ key Êó∂Ôºåkeydown ‰∫ã‰ª∂‰ºöÊåÅÁª≠Ëß¶Âèë
            if (isAltPressed) return;
            isAltPressed = true;
            uiNavigateHelpTab(1);
        }
        else if ((key === 'ArrowLeft')) {
            uiNavigateHelpTab(-1);
        }
        else if (key === 'ArrowRight') {
            uiNavigateHelpTab(1);
        }

        return;
    }

    // Ctrl + Alt ÁªÑÂêà‰Ωú‰∏∫Â∏ÆÂä©Ê®°ÂºèÂÖ•Âè£Ôºå‰∏çÂÜçÊâßË°åÂÖ∂‰ªñ‰∫§‰∫íÊìç‰Ωú
    if (isCtrlPressed && isAltPressed) return;

    // ÂáΩÊï∞ÂØπËØùÊ°ÜÊâìÂºÄÊó∂ÁöÑÂú∫ÊôØ
    if (document.querySelector('.function-overlay.show')) {

        if (key === 'Escape') {
            e.preventDefault();
            UICloseFunctionDialog();
        }
        return;
    }

    // ESCÈîÆÁªü‰∏ÄÂ§ÑÁêÜÔºöÊåâ‰ºòÂÖàÁ∫ßÈ°∫Â∫èÂ§ÑÁêÜÂêÑÁßçÂèñÊ∂àÊìç‰Ωú
    if (key === 'Escape') {

        // ‰ºòÂÖàÊ£ÄÊü•‰∏ä‰º†ÂØπËØùÊ°ÜÊòØÂê¶ÊâìÂºÄ
        if (uiUploadShown) {
            UIHideUploadDialog();
        }
        // ÁÑ∂ÂêéÊ£ÄÊü•Â∏ÆÂä©ÂØπËØùÊ°ÜÊòØÂê¶ÊâìÂºÄ
        // ÁÑ∂ÂêéÊ£ÄÊü•ÂáΩÊï∞ÂØπËØùÊ°ÜÊòØÂê¶ÊâìÂºÄ
        // Â¶ÇÊûúÁªòÂà∂ËèúÂçïÂèØËßÅÔºåÈöêËóèËèúÂçï
        else if (uiDrawMenuShown) {
            UIHideGeometryMenu();
            drawing = 0;
            draw();
        }
        // Â¶ÇÊûúÂ§Ñ‰∫éÁªòÂà∂‰∏≠Áä∂ÊÄÅÔºåÂèñÊ∂àÁªòÂà∂
        else if (drawing) {
            switch (drawing) {
                case DRAWING.POLYGON: resetPolygonDrawing(); break;
                case DRAWING.ARC: resetArcDrawing(); break;
                case DRAWING.EASE: resetEaseDrawing(); break;
                case DRAWING.BEZIER: resetBezierDrawing();break;
                default: drawing = 0; break;
            }
        }
        // Â¶ÇÊûúÂèòÊç¢Èù¢ÊùøÊâìÂºÄÔºåÂÖ≥Èó≠Èù¢Êùø
        else if (uiPropertyPanelShown) UIHidePropertyPanel();
        // ÊúÄÂêéÂ¶ÇÊûúÊúâÂÖÉÁ¥†Ë¢´ÈÄâ‰∏≠ÔºåÂèñÊ∂àÈÄâ‰∏≠
        else if (selectedElement) uiUnselectElement();
        // Â¶ÇÊûú‰ªÄ‰πàÈÉΩ‰∏çÂÅöÔºåÁõ¥Êé•ËøîÂõû
        else return;

        // ÈòªÊ≠¢‰∫ã‰ª∂ÁªßÁª≠‰º†Êí≠
        e.preventDefault();
        e.stopPropagation();
        return;
    }

    // ÊñπÂêëÈîÆ‰∏ä‰∏ã
    if (key === 'ArrowUp' || key === 'ArrowDown') {

        // ÂØºËà™ÂÖÉÁ¥†ÔºàÂâçÊèêÊòØÊ≤°ÊúâÊâìÂºÄÂ±ûÊÄßÈù¢ÊùøÔºâ
        if (!uiPropertyPanelShown && elements.length > 0) {
            navigateToElement(key === 'ArrowUp' ? -1 : 1);
            e.preventDefault();
        }
        return;
    }

    // Shift ÈîÆ‰∏ªË¶ÅÁî®‰∫éÁΩëÊ†ºÂØπÈΩêÔºåÊ≠§Â§ñ
    // > Shift + Ctrl ÁªÑÂêàÈîÆ‰∏ãËΩΩ JSON
    // > ÂèåÂáªÊòæÁ§∫/ÈöêËóèÂÖÉÁ¥†ÂàóË°®Èù¢Êùø
    if (key === 'Shift') {
        e.preventDefault(); e.stopPropagation();

        // Ê≥®ÊÑèÔºåÂØπ‰∫é Êüê‰∫õÊµèËßàÂô®ÔºàÂ¶Ç EdgeÔºâÔºåÂΩìÈïøÊåâ‰∏Ä‰∏™ key Êó∂Ôºåkeydown ‰∫ã‰ª∂‰ºöÊåÅÁª≠Ëß¶Âèë
        if (isShiftPressed) return;
        isShiftPressed = true;

        // ÊãñÊãΩËøáÁ®ã‰∏≠ÔºåÁ´ãÂàªËøõÂÖ•ÁΩëÁªúÂØπÈΩêÊ®°Âºè
        if (dragging) {

            isShiftPressed = true;
            if (mouseMath) {
                mouseMath[0] |= 0; mouseMath[1] |= 0;
            }

            draw();

            return;
        }

        // Ê£ÄÊµã Ctrl + Shift ÁªÑÂêàÈîÆÔºöÂç≥ÂÖàÊåâ CtrlÔºåÂÜçÊåâ Shift ‚Üí Âä†ËΩΩ JSON
        if (isCtrlPressed) { isCtrlPressed = false;

            clearClicking();

            UIShowUploadDialog();
            return;
        }

        // ÂèåÂáª shift ÈîÆÊòæÁ§∫/ÈöêËóèÂÖÉÁ¥†ÂàóË°®Èù¢Êùø
        if (keyClicking === key) {

            clearClicking();

            // ÊòæÁ§∫/ÈöêËóèÂÖÉÁ¥†ÂàóË°®Èù¢Êùø
            UIToggleElementsPanel();
            // Á°Æ‰øùÈù¢ÊùøÂÜÖÂÆπÊòØÊúÄÊñ∞ÁöÑ
            uiUpdateElementPanel();

            return;
        }

        // ÂºÄÂêØÂèåÂáªÊ£ÄÊµã
        if (keyClickTimer !== null)
            clearTimeout(keyClickTimer);
        keyClicking = key;
        keyClickTimer = setTimeout(function() {
            clearClicking();
        }, DOUBLE_CLICK_DELAY);

        // Shift ÈîÆÊåâ‰∏ã‰∏ç‰ºöÁ´ãÂàªËÆæÁΩÆ cursor ‰∏∫ noneÔºàÂπ∂Ëß¶ÂèëÂØπÈΩêËôöÊãü cursor ÁªòÂà∂Ôºâ
        // + Âè™ÊúâÂú®Ê≠§Âü∫Á°Ä‰∏äÈº†Ê†á move/down Êó∂ÔºåÊâç‰ºöÊòæÁ§∫ÂØπÈΩêËôöÊãü cursorÔºåËøôÈáå down ‰∏ªË¶ÅÊòØÂú® drag Êó∂Êõ¥Êñ∞
        return;
    }

    // Ctrl ÈîÆ‰∏ªË¶ÅÁî®‰∫éÊãñÊãΩÂÖÉÁ¥†ÔºåÊ≠§Â§ñ
    // > Ctrl + Alt ÁªÑÂêàÈîÆÈïøÊåâÊòæÁ§∫Â∏ÆÂä©ÂØπËØùÊ°Ü
    // > Shift + Ctrl ÁªÑÂêàÈîÆ‰øùÂ≠ò/Âä†ËΩΩ JSON
    if (key === 'Control') {
        e.preventDefault(); e.stopPropagation();

        if (isCtrlPressed) return;
        isCtrlPressed = true;

        // Â§Ñ‰∫éÊãñÊãΩÁä∂ÊÄÅÊó∂ÔºåÁ¶ÅÊ≠¢ÊâßË°åÂÖ∂‰ªñ‰∫§‰∫íÂä®‰Ωú
        if (dragging) return;

        // Ctrl + Alt ÁªÑÂêàÈîÆÔºåÂêØÂä®ÈïøÊåâËÆ°Êó∂Âô®ÊòæÁ§∫Â∏ÆÂä©
        // + ÈúÄË¶ÅÂØπ e.altKey Ê£ÄÊµãÔºåÂõ†‰∏∫ Ctrl Âíå Alt ÂèØËÉΩÂêåÊó∂ÂèëÁîüÔºåËÄåÊ≠§Êó∂Êüê‰∫õÊµèËßàÂô®ÔºàÂ¶Ç EdgeÔºâÂè™‰ºöÂá∫ÂèëÂÖ∂‰∏≠‰∏Ä‰∏™ÈîÆÁöÑ keydown ‰∫ã‰ª∂
        if (isAltPressed || e.altKey) {
            startHelp();
            return;
        }

        // Ê£ÄÊµã Shift + Ctrl ÁªÑÂêàÈîÆÔºöÂÖàÊåâ ShiftÔºåÂÜçÊåâ Ctrl ‚Üí ‰øùÂ≠ò JSON
        if (isShiftPressed) { isShiftPressed = false;

            clearClicking();

            saveElementsToJSON();
            return;
        }

        // Control ÈîÆÊåâ‰∏ã‰∏ç‰ºöÁ´ãÂàªËÆæÁΩÆ cursor ‰∏∫ noneÔºàÂπ∂ÊòæÁ§∫ dragging Áä∂ÊÄÅÔºâ
        // + Âè™ÊúâÂú®Ê≠§Âü∫Á°Ä‰∏äÁßªÂä®Èº†Ê†á downÔºåÊâç‰ºöÊòæÁ§∫ÊãñÊãΩ cursor
        return;
    }

    // Z ÈîÆÁî®‰∫éÂùêÊ†áÁ≥ªÊìç‰Ωú
    // > Z + Â∑¶ÈîÆÊãñÊãΩÁßªÂä®ÂùêÊ†áÁ≥ª
    // > ÂèåÂáªÂàáÊç¢ÂùêÊ†áÁ≥ªÊòæÁ§∫Ê®°Âºè
    if (e.code === 'KeyZ') {
        e.preventDefault();
        if (isKeyZPressed) return;
        isKeyZPressed = true;

        // Â§Ñ‰∫éÊãñÊãΩÁä∂ÊÄÅÊó∂ÔºåÁ¶ÅÊ≠¢ÊâßË°åÂÖ∂‰ªñ‰∫§‰∫íÂä®‰Ωú
        if (dragging) return;

        // ÂèåÂáªÂàáÊç¢ÂùêÊ†áÁ≥ªÊòæÁ§∫Ê®°Âºè
        if (keyClicking === 'KeyZ') {

            clearClicking();

            cycleCoordinateSystem();
            return;
        }

        // ÂºÄÂêØÂèåÂáªÊ£ÄÊµã
        if (keyClickTimer !== null)
            clearTimeout(keyClickTimer);
        keyClicking = 'KeyZ';
        keyClickTimer = setTimeout(function() {
            clearClicking();
        }, DOUBLE_CLICK_DELAY);

        return;
    }

    // Alt ÈîÆ‰∏ªË¶Å‰ΩúÁî®ÊòØÂØπÂÖÉÁ¥†ËøõË°åÊìç‰Ωú
    // > Âú® drawing Ê®°Âºè‰∏ãÔºåAlt ÈîÆÁî®‰∫éÂØπÁªòÂà∂ÁöÑÂÖÉÁ¥†ËøõË°åÁâπÂÆöÊìç‰Ωú
    // > ÂèåÂáªËΩÆËØ¢ÈÄâÊã©ÂÖÉÁ¥†
    // > ÂØπ‰∫éÈÄâÊã©ÁöÑÂÖÉÁ¥†ÔºåÊåâ‰Ωè Alt ÈîÆ + ÊòæÁ§∫ËßÇÊµãÁÇπ„ÄÅËßÇÊµãÊñπÂêëËæÖÂä©Á∫ø
    // + Ê≠§Â§ñÔºåCtrl + Alt ÁªÑÂêàÈîÆÈïøÊåâÊòæÁ§∫Â∏ÆÂä©ÂØπËØùÊ°Ü
    if (key === 'Alt') {
        e.preventDefault(); e.stopPropagation();

        if (isAltPressed) return;
        isAltPressed = true;

        // ÊãñÊãΩËßÇÊµãÁÇπÊó∂ÔºåÂÖÅËÆ∏ alt ÂºÄÂêØËßÜËßíËæÖÂä©Á∫øÔºå‰ΩÜÁ¶ÅÊ≠¢ÂÖ∂‰ªñ‰∫§‰∫íÊìç‰Ωú
        if (dragging === DRAGGING.OBSERVE_POINT) {

            draw();
            return;
        }

        // Â§Ñ‰∫éÊãñÊãΩÁä∂ÊÄÅÊó∂ÔºåÁ¶ÅÊ≠¢ÊâßË°åÂÖ∂‰ªñ‰∫§‰∫íÂä®‰Ωú
        if (dragging) return;

        // Ctrl + Alt ÁªÑÂêàÈîÆÔºåÂêØÂä®ÈïøÊåâËÆ°Êó∂Âô®ÊòæÁ§∫Â∏ÆÂä©
        // + ÈúÄË¶ÅÂØπ e.ctrlKey Ê£ÄÊµãÔºåÂõ†‰∏∫ Ctrl Âíå Alt ÂèØËÉΩÂêåÊó∂ÂèëÁîüÔºåËÄåÊ≠§Êó∂Êüê‰∫õÊµèËßàÂô®ÔºàÂ¶Ç EdgeÔºâÂè™‰ºöÂá∫ÂèëÂÖ∂‰∏≠‰∏Ä‰∏™ÈîÆÁöÑ keydown ‰∫ã‰ª∂
        if (isCtrlPressed || e.ctrlKey) {
            startHelp();
            return;
        }

        // ÂΩìÂâçÂ§Ñ‰∫éÁªòÂà∂ËøáÁ®ã‰∏≠
        if (drawing) { console.assert(!selectedElement);

            // Âú®ÁªòÂà∂Ë¥ùÂ°ûÂ∞îÊõ≤Á∫øÊó∂ÔºåAlt ÈîÆÁî®‰∫éÂàáÊç¢Èò∂Êï∞
            if (drawing === DRAWING.BEZIER) {
                cycleBezierControlPointCount();
            }
            // Âú®ÁªòÂà∂ ease Êõ≤Á∫øÊó∂ÔºåAlt ÈîÆÁî®‰∫éÂæ™ÁéØÁ±ªÂûã/ÂàÜÁªÑ
            else if (drawing === DRAWING.EASE) {
                cycleEaseProc();
                cycleEaseType();
            }

            // ÁªòÂà∂ËøáÁ®ã‰∏≠Êåâ‰∏ã Alt ÈîÆ‰∏çÊâßË°åÂÖ∂‰ªñÈÄªËæë
            return;
        }

        // ÂèåÂáªËΩÆËØ¢ÈÄâÊã©ÂÖÉÁ¥†ÔºöÂ¶ÇÊûúÊ≤°ÊúâÈÄâ‰∏≠ÂÖÉÁ¥†ÔºåÈÄâÊã©Á¨¨‰∏Ä‰∏™ÔºõÂ¶ÇÊûúÊúâÈÄâ‰∏≠ÂÖÉÁ¥†ÔºåÂØºËà™Âà∞‰∏ã‰∏Ä‰∏™
        if (keyClicking === key) { clearClicking();

            if (!selectedElement) {
                selectFirstElement();
            } else {
                navigateToElement(1);
            }
            return;
        }

        // ÂºÄÂêØÂèåÂáªÊ£ÄÊµã
        if (keyClickTimer !== null)
            clearTimeout(keyClickTimer);
        keyClicking = key;
        keyClickTimer = setTimeout(function() {
            clearClicking();
        }, DOUBLE_CLICK_DELAY);

        console.assert(!projectingPoint);

        if (selectedElement) {

            // Á´ãÂç≥ËÆ°ÁÆóË∑üË∏™ÁÇπÂπ∂ÈáçÁªò
            if (!uiPropertyPanelShown || uiPropertyCurrentTab === 'props') {

                // Â¶ÇÊûúË∑üË∏™ÁÇπÊó†ÊïàÔºå‰ΩÜ mouseMath ÊúâÊïàÔºåÂàôÂàùÂßãÂåñË∑üË∏™ÁÇπ
                // + ÂΩì tab ÂàáÊç¢Êó∂ÔºåÁî±‰∫éÈº†Ê†áÂ§Ñ‰∫éÈù¢Êùø‰∏äÔºåÊâÄ‰ª• mouseMath ÂèØËÉΩÊòØÊó†ÊïàÁöÑ
                if (mouseMath) {

                    projectingPoint = calculateTrackingPoint(mouseMath[0], mouseMath[0]);
                    calculateTrackingTangent();

                    draw();
                }
            }
            // Á´ãÂç≥ÊòæÁ§∫ËßÇÊµãÊñπÂêëËæÖÂä©Á∫ø
            else if (uiPropertyCurrentTab === 'flip' || uiPropertyCurrentTab === 'shear') {

                draw();
            }
        }
    }

    // Â§Ñ‰∫éÊãñÊãΩÁä∂ÊÄÅÊó∂ÔºåÁ¶ÅÊ≠¢ÊâßË°åÂÖ∂‰ªñ‰∫§‰∫íÂä®‰Ωú
    if (dragging) return;

    // Â§ÑÁêÜÂàáÁ∫ø/Ê≥ïÁ∫øÊòæÁ§∫Âø´Êç∑ÈîÆÔºàAlt + A / Alt + SÔºâ
    if (selectedElement && isAltPressed) {

        if (!uiPropertyPanelShown || uiPropertyCurrentTab === 'props') do {

            // Â≠óÊØçÈîÆAÔºöÂàáÊç¢ÂàáÁ∫øÊòæÁ§∫Ôºà‰ΩøÁî® e.code ‰ª•ÊîØÊåÅ Alt+S ÁªÑÂêàÔºâ
            if (e.code === 'KeyA') isKeyAPressed = !isKeyAPressed;
            // Â≠óÊØçÈîÆSÔºöÂàáÊç¢Ê≥ïÁ∫øÊòæÁ§∫Ôºà‰ΩøÁî® e.code ‰ª•ÊîØÊåÅ Alt+S ÁªÑÂêàÔºâ
            else if (e.code === 'KeyS') isKeySPressed = !isKeySPressed;
            else break;

            if (projectingPoint) {

                if (isKeyAPressed || isKeySPressed) calculateTrackingTangent();

                draw();
            }
            e.preventDefault();
        } while(0);
    }
});

window.addEventListener('keyup', function(e) {

    const key = getKeyFromEvent(e);

    // Â∏ÆÂä©ÂØπËØùÊ°ÜÊâìÂºÄÊó∂ÁöÑÂú∫ÊôØ
    if (uiHelpShown) { console.assert(isCtrlPressed);

        if (key === 'Control') {
            isCtrlPressed = isAltPressed = false;
            if (!window.preventHelpClose) {
                UIHideHelpDialog();
            }
        }
        else if (key === 'Alt') {
            isAltPressed = false;
        }

        return;
    }

    if (document.querySelector('.function-overlay.show')) return;

    if (key === 'Shift') { isShiftPressed = false;

        if (canvas.style.cursor === 'none') {

            // ÂéªÈô§ÁΩëÊ†ºÂØπÈΩêËôöÊãü cursor ÁªòÂà∂
            draw();
            // ÊÅ¢Â§çÈº†Ê†áÊåáÈíàÊòæÁ§∫
            canvas.style.cursor = getCrosshair();
        }
    }
    else if (key === 'Control') {   // ËøôÈáåÊòØÂê¶ÊúâÂøÖË¶ÅÂèñÊ∂àÁõ∏ÂÖ≥ÁöÑ dragging Áä∂ÊÄÅÔºü
        isCtrlPressed = false;
        // Ê∏ÖÈô§ÈïøÊåâËÆ°Êó∂Âô®
        if (ctrlAltKeyHoldTimer) {
            clearTimeout(ctrlAltKeyHoldTimer);
            ctrlAltKeyHoldTimer = null;
        }
    }
    else if (key === 'Alt') {
        isAltPressed = false;
        // Ê∏ÖÈô§ÈïøÊåâËÆ°Êó∂Âô®
        if (ctrlAltKeyHoldTimer) {
            clearTimeout(ctrlAltKeyHoldTimer);
            ctrlAltKeyHoldTimer = null;
        }

        if (drawing) {

            // ‰øÆÈ•∞ÈîÆÊä¨Ëµ∑Êó∂ÔºåÂÆåÊàêÂ§öËæπÂΩ¢ÁªòÂà∂
            if (drawing === DRAWING.POLYGON) {
                finishPolygonDrawing();
            }

            return;
        }

        if (selectedElement) {

            // Ê∏ÖÈô§Ë∑üË∏™ÁÇπÂíåÂàáÁ∫ø‰ø°ÊÅØ
            projectingPoint = null;
            projectionTangent = null;

            // ‰øÆÈ•∞ÈîÆÈáäÊîæÊó∂ÔºåÂêåÊó∂Ê∏ÖÈô§Â≠óÊØçÈîÆÁä∂ÊÄÅ
            isKeyAPressed = false;
            isKeySPressed = false;

            // Á´ãÂç≥ÈöêËóèËßÇÊµãÊñπÂêëËæÖÂä©Á∫øÂíåË∑üË∏™ÁÇπ
            draw();
        }
    }
    // Z ÈîÆÈáäÊîæ
    else if (e.code === 'KeyZ') {
        isKeyZPressed = false;
    }
});

///////////// ‰ºòÂåñÂ±èËîΩÊµèËßàÂô®ÈªòËÆ§Á≥ªÁªüÂäüËÉΩ /////////////

// Èò≤Ê≠¢ÊãñÊãΩÊó∂ÂºÄÂßãÊñáÊú¨ÈÄâÊã©
document.addEventListener('selectstart', function(e) {
    if (dragging && isCtrlPressed) {
        e.preventDefault();
        return false;
    }
});

///////////// ÂàùÂßãÂåñÁõ∏ÂÖ≥ /////////////

// ËÆæÁΩÆCanvasÂ∞∫ÂØ∏
function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // Â¶ÇÊûúÂΩìÂâçÊòØÂ±Ö‰∏≠Áä∂ÊÄÅÔºåÈáçÊñ∞Ë∞ÉÊï¥ÂÅèÁßªÈáè‰ª•‰øùÊåÅÂ±Ö‰∏≠
    if (coordinateState === COORDINATE_STATES.CENTERED) {
        offsetX = canvas.width / 2;
        offsetY = -canvas.height / 2; // Ê≥®ÊÑèÔºöÁî±‰∫é Y ËΩ¥ÁøªËΩ¨ÔºåÈúÄË¶Å‰ΩøÁî®Ë¥üÂÄº
    } else if (coordinateState === COORDINATE_STATES.BOTTOM_CENTER) {
        offsetX = canvas.width / 2;
        offsetY = INITIAL_OFFSET_Y;
    }

    // Ê†áËÆ∞ÂùêÊ†áÁ≥ªÁºìÂ≠òÈúÄË¶ÅÊõ¥Êñ∞ÔºàÁîªÂ∏ÉÂ∞∫ÂØ∏ÂèòÂåñÔºâ
    invalidateCoordinateCache();

    // Á™óÂè£Â§ßÂ∞èÂèòÂåñÊó∂ÔºåÈáçÊñ∞ÁîüÊàêÊâÄÊúâÁºìÂ≠òÁöÑÂõæÂΩ¢ÁÇπÔºàÂΩ±ÂìçÊòæÁ§∫Á≤æÂ∫¶Ôºâ
    invalidateDrawCache(true);
    draw();
}
window.addEventListener('resize', resizeCanvas);

UILang();                       // ÂàùÂßãÂåñÁïåÈù¢ËØ≠Ë®Ä
resizeCanvas();                 // ÂàùÂßãÂåñÁîªÂ∏ÉÂ∞∫ÂØ∏
initCoordinateCache();          // ÂàùÂßãÂåñÂùêÊ†áÁ≥ªÁºìÂ≠ò    
updatePanelPosition();          // ÂàùÂßãÂåñÈù¢Êùø‰ΩçÁΩÆ
uiUpdateElementPanel();         // ÂàùÂßãÂåñÂè≥‰æßÂÖÉÁ¥†ÁÆ°ÁêÜÈù¢Êùø

// ÂàùÂßãÂåñÂÖâÊ†áÔºàEdge ÈúÄË¶ÅËá™ÂÆö‰πâ SVG ÈÅøÂÖçÈ¢úËâ≤‰∏çÁ®≥ÂÆöÔºâ
canvas.style.cursor = getCrosshair();

// È°µÈù¢Âä†ËΩΩÂÆåÊàêÂêéËá™Âä®Ëé∑ÂèñÁÑ¶ÁÇπÔºå‰ª•‰æøÁ´ãÂç≥ÂìçÂ∫îÈîÆÁõò‰∫ã‰ª∂
window.focus();
</script>
</body>
</html>
